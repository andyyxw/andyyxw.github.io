<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>30分钟精通React Hooks</title>
    <url>/archives/66c2.html</url>
    <content><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.im/post/5be3ea136fb9a049f9121014" target="_blank" rel="noopener">https://juejin.im/post/5be3ea136fb9a049f9121014</a></p></blockquote><p>你还在为该使用无状态组件（Function）还是有状态组件（Class）而烦恼吗？ ——拥有了 hooks，你再也不需要写 Class 了，你的所有组件都将是 Function。</p><p>你还在为搞不清使用哪个生命周期钩子函数而日夜难眠吗？ ——拥有了 Hooks，生命周期钩子函数可以先丢一边了。</p><p>你在还在为组件中的 this 指向而晕头转向吗？ ——既然 Class 都丢掉了，哪里还有 this？你的人生第一次不再需要面对 this。</p><p>这样看来，说 React Hooks 是今年最劲爆的新特性真的毫不夸张。如果你也对 react 感兴趣，或者正在使用 react 进行项目开发，答应我，请一定抽出至少 30 分钟的时间来阅读本文好吗？</p><h2 id="一个最简单的-Hooks"><a href="#一个最简单的-Hooks" class="headerlink" title="一个最简单的 Hooks"></a>一个最简单的 Hooks</h2><p>首先让我们看一下一个简单的有状态组件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Example extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span><br><span class="line">          Click me</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们再来看一下使用 hooks 后的版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>是不是简单多了！可以看到，<code>Example</code>变成了一个函数，但这个函数却有自己的状态（count），同时它还可以更新自己的状态（setCount）。这个函数之所以这么了不得，就是因为它注入了一个 hook–<code>useState</code>，就是这个 hook 让我们的函数变成了一个有状态的函数。</p><p>除了<code>useState</code>这个 hook 外，还有很多别的 hook，比如<code>useEffect</code>提供了类似于<code>componentDidMount</code>等生命周期钩子的功能，<code>useContext</code>提供了上下文（context）的功能等等。</p><p>Hooks 本质上就是一类特殊的函数，它们可以为你的函数型组件（function component）注入一些特殊的功能。咦？这听起来有点像被诟病的 Mixins 啊？难道是 Mixins 要在 react 中死灰复燃了吗？当然不会了，等会我们再来谈两者的区别。总而言之，这些 hooks 的目标就是让你不再写 class，让 function 一统江湖。</p><h2 id="React-为什么要搞一个-Hooks？"><a href="#React-为什么要搞一个-Hooks？" class="headerlink" title="React 为什么要搞一个 Hooks？"></a>React 为什么要搞一个 Hooks？</h2><h3 id="想要复用一个有状态的组件太麻烦了"><a href="#想要复用一个有状态的组件太麻烦了" class="headerlink" title="想要复用一个有状态的组件太麻烦了"></a>想要复用一个有状态的组件太麻烦了</h3><p>我们都知道 react 都核心思想就是，将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。但假如你在大型的工作项目中用 react，你会发现你的项目中实际上很多 react 组件冗长且难以复用。尤其是那些写成 class 的组件，它们本身包含了状态（state），所以复用这类组件就变得很麻烦。</p><p>那之前，官方推荐怎么解决这个问题呢？答案是：<a href="https://link.juejin.im?target=https%3A%2F%2Freactjs.org%2Fdocs%2Frender-props.html" target="_blank" rel="noopener">渲染属性（Render Props）</a>和<a href="https://link.juejin.im?target=https%3A%2F%2Freactjs.org%2Fdocs%2Fhigher-order-components.html" target="_blank" rel="noopener">高阶组件（Higher-Order Components）</a>。我们可以稍微跑下题简单看一下这两种模式。</p><p>渲染属性指的是使用一个值为函数的 prop 来传递需要动态渲染的 nodes 或组件。如下面的代码可以看到我们的<code>DataProvider</code>组件包含了所有跟状态相关的代码，而<code>Cat</code>组件则可以是一个单纯的展示型组件，这样一来<code>DataProvider</code>就可以单独复用了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Cat from &apos;components/cat&apos;</span><br><span class="line">class DataProvider extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; target: &apos;Zac&apos; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;this.props.render(this.state)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;DataProvider render=&#123;data =&gt; (</span><br><span class="line">  &lt;Cat target=&#123;data.target&#125; /&gt;</span><br><span class="line">)&#125;/&gt;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>虽然这个模式叫 Render Props，但不是说非用一个叫 render 的 props 不可，习惯上大家更常写成下面这种：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;DataProvider&gt;</span><br><span class="line">  &#123;data =&gt; (</span><br><span class="line">    &lt;Cat target=&#123;data.target&#125; /&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/DataProvider&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>高阶组件这个概念就更好理解了，说白了就是一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。看下面的代码示例，<code>withUser</code>函数就是一个高阶组件，它返回了一个新的组件，这个组件具有了它提供的获取用户信息的功能。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const withUser = WrappedComponent =&gt; &#123;</span><br><span class="line">  const user = sessionStorage.getItem(&quot;user&quot;);</span><br><span class="line">  return props =&gt; &lt;WrappedComponent user=&#123;user&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const UserPage = props =&gt; (</span><br><span class="line">  &lt;div class=&quot;user-container&quot;&gt;</span><br><span class="line">    &lt;p&gt;My name is &#123;props.user&#125;!&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">export default withUser(UserPage);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上这两种模式看上去都挺不错的，很多库也运用了这种模式，比如我们常用的 React Router。但我们仔细看这两种模式，会发现它们会增加我们代码的层级关系。最直观的体现，打开 devtool 看看你的组件层级嵌套是不是很夸张吧。这时候再回过头看我们上一节给出的 hooks 例子，是不是简洁多了，没有多余的层级嵌套。把各种想要的功能写成一个一个可复用的自定义 hook，当你的组件想用什么功能时，直接在组件里调用这个 hook 即可。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/9/166f7bc8480d53c6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><h3 id="生命周期钩子函数里的逻辑太乱了吧"><a href="#生命周期钩子函数里的逻辑太乱了吧" class="headerlink" title="生命周期钩子函数里的逻辑太乱了吧"></a>生命周期钩子函数里的逻辑太乱了吧</h3><p>我们通常希望一个函数只做一件事情，但我们的生命周期钩子函数里通常同时做了很多事情。比如我们需要在<code>componentDidMount</code>中发起 ajax 请求获取数据，绑定一些事件监听等等。同时，有时候我们还需要在<code>componentDidUpdate</code>做一遍同样的事情。当项目变复杂后，这一块的代码也变得不那么直观。</p><h3 id="classes-真的太让人困惑了"><a href="#classes-真的太让人困惑了" class="headerlink" title="classes 真的太让人困惑了"></a>classes 真的太让人困惑了</h3><p>我们用 class 来创建 react 组件时，还有一件很麻烦的事情，就是 this 的指向问题。为了保证 this 的指向正确，我们要经常写这样的代码：<code>this.handleClick = this.handleClick.bind(this)</code>，或者是这样的代码：<code>&lt;button onClick={() =&gt; this.handleClick(e)}&gt;</code>。一旦我们不小心忘了绑定 this，各种 bug 就随之而来，很麻烦。</p><p>还有一件让我很苦恼的事情。我在之前的 react 系列文章当中曾经说过，尽可能把你的组件写成无状态组件的形式，因为它们更方便复用，可独立测试。然而很多时候，我们用 function 写了一个简洁完美的无状态组件，后来因为需求变动这个组件必须得有自己的 state，我们又得很麻烦的把 function 改成 class。</p><p>在这样的背景下，Hooks 便横空出世了！</p><h2 id="什么是-State-Hooks？"><a href="#什么是-State-Hooks？" class="headerlink" title="什么是 State Hooks？"></a>什么是 State Hooks？</h2><p>回到一开始我们用的例子，我们分解来看到底 state hooks 做了什么：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="声明一个状态变量"><a href="#声明一个状态变量" class="headerlink" title="声明一个状态变量"></a>声明一个状态变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>useState</code>是 react 自带的一个 hook 函数，它的作用就是用来声明状态变量。<code>useState</code>这个函数接收的参数是我们的状态初始值（initial state），它返回了一个数组，这个数组的第<code>[0]</code>项是当前当前的状态值，第<code>[1]</code>项是可以改变状态值的方法函数。</p><p>所以我们做的事情其实就是，声明了一个状态变量 count，把它的初始值设为 0，同时提供了一个可以更改 count 的函数 setCount。</p><p>上面这种表达形式，是借用了 es6 的数组解构（<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FDestructuring_assignment%23Array_destructuring" target="_blank" rel="noopener">array destructuring</a>），它可以让我们的代码看起来更简洁。不清楚这种用法的可以先去看下我的这篇文章 <a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000004365693" target="_blank" rel="noopener">30 分钟掌握 ES6/ES2015 核心内容（上）</a>。</p><p>如果不用数组解构的话，可以写成下面这样。实际上数组解构是一件开销很大的事情，用下面这种写法，或者改用对象解构，性能会有很大的提升。具体可以去这篇文章的分析 <a href="https://link.juejin.im?target=https%3A%2F%2Fdocs.google.com%2Fdocument%2Fd%2F1hWb-lQW4NSG9yRpyyiAA_9Ktytd5lypLnVLhPX9vamE%2Fedit%23" target="_blank" rel="noopener">Array destructuring for multi-value returns (in light of React hooks)</a>，这里不详细展开，我们就按照官方推荐使用数组解构就好。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let _useState = useState(0);</span><br><span class="line">let count = _useState[0];</span><br><span class="line">let setCount = _useState[1];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="读取状态值"><a href="#读取状态值" class="headerlink" title="读取状态值"></a>读取状态值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>是不是超简单？因为我们的状态 count 就是一个单纯的变量而已，我们再也不需要写成<code>{this.state.count}</code>这样了。</p><h3 id="更新状态"><a href="#更新状态" class="headerlink" title="更新状态"></a>更新状态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">    Click me</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当用户点击按钮时，我们调用 setCount 函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给 react 了，react 将会重新渲染我们的 Example 组件，并且使用的是更新后的新的状态，即 count=1。这里我们要停下来思考一下，Example 本质上也是一个普通的函数，为什么它可以记住之前的状态？</p><h3 id="一个至关重要的问题"><a href="#一个至关重要的问题" class="headerlink" title="一个至关重要的问题"></a>一个至关重要的问题</h3><p>这里我们就发现了问题，通常来说我们在一个函数中声明的变量，当函数运行完成后，这个变量也就销毁了（这里我们先不考虑闭包等情况），比如考虑下面的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(n) &#123;</span><br><span class="line">    const result = 0;</span><br><span class="line">    return result + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1); //1</span><br><span class="line">add(1); //1</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>不管我们反复调用 add 函数多少次，结果都是 1。因为每一次我们调用 add 时，result 变量都是从初始值 0 开始的。那为什么上面的 Example 函数每次执行的时候，都是拿的上一次执行完的状态值作为初始值？答案是：是 react 帮我们记住的。至于 react 是用什么机制记住的，我们可以再思考一下。</p><h3 id="假如一个组件有多个状态值怎么办？"><a href="#假如一个组件有多个状态值怎么办？" class="headerlink" title="假如一个组件有多个状态值怎么办？"></a>假如一个组件有多个状态值怎么办？</h3><p>首先，useState 是可以多次调用的，所以我们完全可以这样写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ExampleWithManyStates() &#123;</span><br><span class="line">  const [age, setAge] = useState(42);</span><br><span class="line">  const [fruit, setFruit] = useState(&apos;banana&apos;);</span><br><span class="line">  const [todos, setTodos] = useState([&#123; text: &apos;Learn Hooks&apos; &#125;]);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其次，useState 接收的初始值没有规定一定要是 string/number/boolean 这种简单数据类型，它完全可以接收对象或者数组作为参数。唯一需要注意的点是，之前我们的<code>this.setState</code>做的是合并状态后返回一个新状态，而<code>useState</code>是直接替换老状态后返回新状态。最后，react 也给我们提供了一个 useReducer 的 hook，如果你更喜欢 redux 式的状态管理方案的话。</p><p>从 ExampleWithManyStates 函数我们可以看到，useState 无论调用多少次，相互之间是独立的。这一点至关重要。为什么这么说呢？</p><p>其实我们看 hook 的 “形态”，有点类似之前被官方否定掉的 Mixins 这种方案，都是提供一种“插拔式的功能注入” 的能力。而 mixins 之所以被否定，是因为 Mixins 机制是让多个 Mixins 共享一个对象的数据空间，这样就很难确保不同 Mixins 依赖的状态不发生冲突。</p><p>而现在我们的 hook，一方面它是直接用在 function 当中，而不是 class；另一方面每一个 hook 都是相互独立的，不同组件调用同一个 hook 也能保证各自状态的独立性。这就是两者的本质区别了。</p><h3 id="react-是怎么保证多个-useState-的相互独立的？"><a href="#react-是怎么保证多个-useState-的相互独立的？" class="headerlink" title="react 是怎么保证多个 useState 的相互独立的？"></a>react 是怎么保证多个 useState 的相互独立的？</h3><p>还是看上面给出的 ExampleWithManyStates 例子，我们调用了三次 useState，每次我们传的参数只是一个值（如 42，‘banana’），我们根本没有告诉 react 这些值对应的 key 是哪个，那 react 是怎么保证这三个 useState 找到它对应的 state 呢？</p><p>答案是，react 是根据 useState 出现的顺序来定的。我们具体来看一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  //第一次渲染</span><br><span class="line">  useState(42);  //将age初始化为42</span><br><span class="line">  useState(&apos;banana&apos;);  //将fruit初始化为banana</span><br><span class="line">  useState([&#123; text: &apos;Learn Hooks&apos; &#125;]); //...</span><br><span class="line"></span><br><span class="line">  //第二次渲染</span><br><span class="line">  useState(42);  //读取状态变量age的值（这时候传的参数42直接被忽略）</span><br><span class="line">  useState(&apos;banana&apos;);  //读取状态变量fruit的值（这时候传的参数banana直接被忽略）</span><br><span class="line">  useState([&#123; text: &apos;Learn Hooks&apos; &#125;]); //...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>假如我们改一下代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let showFruit = true;</span><br><span class="line">function ExampleWithManyStates() &#123;</span><br><span class="line">  const [age, setAge] = useState(42);</span><br><span class="line">  </span><br><span class="line">  if(showFruit) &#123;</span><br><span class="line">    const [fruit, setFruit] = useState(&apos;banana&apos;);</span><br><span class="line">    showFruit = false;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  const [todos, setTodos] = useState([&#123; text: &apos;Learn Hooks&apos; &#125;]);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样一来，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  //第一次渲染</span><br><span class="line">  useState(42);  //将age初始化为42</span><br><span class="line">  useState(&apos;banana&apos;);  //将fruit初始化为banana</span><br><span class="line">  useState([&#123; text: &apos;Learn Hooks&apos; &#125;]); //...</span><br><span class="line"></span><br><span class="line">  //第二次渲染</span><br><span class="line">  useState(42);  //读取状态变量age的值（这时候传的参数42直接被忽略）</span><br><span class="line">  // useState(&apos;banana&apos;);  </span><br><span class="line">  useState([&#123; text: &apos;Learn Hooks&apos; &#125;]); //读取到的却是状态变量fruit的值，导致报错</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>鉴于此，react 规定我们必须把 hooks 写在函数的最外层，不能写在 ifelse 等条件语句当中，来确保 hooks 的执行顺序一致。</p><h2 id="什么是-Effect-Hooks"><a href="#什么是-Effect-Hooks" class="headerlink" title="什么是 Effect Hooks?"></a>什么是 Effect Hooks?</h2><p>我们在上一节的例子中增加一个新功能：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  // 类似于componentDidMount 和 componentDidUpdate:</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // 更新文档的标题</span><br><span class="line">    document.title = `You clicked $&#123;count&#125; times`;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们对比着看一下，如果没有 hooks，我们会怎么写？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Example extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    document.title = `You clicked $&#123;this.state.count&#125; times`;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    document.title = `You clicked $&#123;this.state.count&#125; times`;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span><br><span class="line">          Click me</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们写的有状态组件，通常会产生很多的副作用（side effect），比如发起 ajax 请求获取数据，添加一些监听的注册和取消注册，手动修改 dom 等等。我们之前都把这些副作用的函数写在生命周期函数钩子里，比如 componentDidMount，componentDidUpdate 和 componentWillUnmount。而现在的 useEffect 就相当与这些声明周期函数钩子的集合体。它以一抵三。</p><p>同时，由于前文所说 hooks 可以反复多次使用，相互独立。所以我们合理的做法是，给每一个副作用一个单独的 useEffect 钩子。这样一来，这些副作用不再一股脑堆在生命周期钩子里，代码变得更加清晰。</p><h3 id="useEffect-做了什么？"><a href="#useEffect-做了什么？" class="headerlink" title="useEffect 做了什么？"></a>useEffect 做了什么？</h3><p>我们再梳理一遍下面代码的逻辑：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Example() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    document.title = `You clicked $&#123;count&#125; times`;</span><br><span class="line">  &#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>首先，我们声明了一个状态变量<code>count</code>，将它的初始值设为 0。然后我们告诉 react，我们的这个组件有一个副作用。我们给<code>useEffect</code>hook 传了一个匿名函数，这个匿名函数就是我们的副作用。在这个例子里，我们的副作用是调用 browser API 来修改文档标题。当 react 要渲染我们的组件时，它会先记住我们用到的副作用。等 react 更新了 DOM 之后，它再依次执行我们定义的副作用函数。</p><p>这里要注意几点： 第一，react 首次渲染和之后的每次渲染都会调用一遍传给 useEffect 的函数。而之前我们要用两个声明周期函数来分别表示首次渲染（componentDidMount），和之后的更新导致的重新渲染（componentDidUpdate）。</p><p>第二，useEffect 中定义的副作用函数的执行不会阻碍浏览器更新视图，也就是说这些函数是异步执行的，而之前的 componentDidMount 或 componentDidUpdate 中的代码则是同步执行的。这种安排对大多数副作用说都是合理的，但有的情况除外，比如我们有时候需要先根据 DOM 计算出某个元素的尺寸再重新渲染，这时候我们希望这次重新渲染是同步发生的，也就是说它会在浏览器真的去绘制这个页面前发生。</p><h3 id="useEffect-怎么解绑一些副作用"><a href="#useEffect-怎么解绑一些副作用" class="headerlink" title="useEffect 怎么解绑一些副作用"></a>useEffect 怎么解绑一些副作用</h3><p>这种场景很常见，当我们在 componentDidMount 里添加了一个注册，我们得马上在 componentWillUnmount 中，也就是组件被注销之前清除掉我们添加的注册，否则内存泄漏的问题就出现了。</p><p>怎么清除呢？让我们传给 useEffect 的副作用函数返回一个新的函数即可。这个新的函数将会在组件下一次重新渲染之后执行。这种模式在一些 pubsub 模式的实现中很常见。看下面的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function FriendStatus(props) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] = useState(null);</span><br><span class="line"></span><br><span class="line">  function handleStatusChange(status) &#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    // 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup</span><br><span class="line">    return function cleanup() &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (isOnline === null) &#123;</span><br><span class="line">    return &apos;Loading...&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return isOnline ? &apos;Online&apos; : &apos;Offline&apos;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里有一个点需要重视！这种解绑的模式跟 componentWillUnmount 不一样。componentWillUnmount 只会在组件被销毁前执行一次而已，而 useEffect 里的函数，每次组件渲染后都会执行一遍，包括副作用函数返回的这个清理函数也会重新执行一遍。所以我们一起来看一下下面这个问题。</p><h3 id="为什么要让副作用函数每次组件更新都执行一遍？"><a href="#为什么要让副作用函数每次组件更新都执行一遍？" class="headerlink" title="为什么要让副作用函数每次组件更新都执行一遍？"></a>为什么要让副作用函数每次组件更新都执行一遍？</h3><p>我们先看以前的模式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  componentDidMount() &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(</span><br><span class="line">      this.props.friend.id,</span><br><span class="line">      this.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class="line">      this.props.friend.id,</span><br><span class="line">      this.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>很清除，我们在 componentDidMount 注册，再在 componentWillUnmount 清除注册。但假如这时候<code>props.friend.id</code>变了怎么办？我们不得不再添加一个 componentDidUpdate 来处理这种情况：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">  componentDidUpdate(prevProps) &#123;</span><br><span class="line">    // 先把上一个friend.id解绑</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class="line">      prevProps.friend.id,</span><br><span class="line">      this.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">    // 再重新注册新但friend.id</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(</span><br><span class="line">      this.props.friend.id,</span><br><span class="line">      this.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>看到了吗？很繁琐，而我们但 useEffect 则没这个问题，因为它在每次组件更新后都会重新执行一遍。所以代码的执行顺序是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.页面首次渲染</span><br><span class="line">2.替friend.id=1的朋友注册</span><br><span class="line"></span><br><span class="line">3.突然friend.id变成了2</span><br><span class="line">4.页面重新渲染</span><br><span class="line">5.清除friend.id=1的绑定</span><br><span class="line">6.替friend.id=2的朋友注册</span><br><span class="line">...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="怎么跳过一些不必要的副作用函数"><a href="#怎么跳过一些不必要的副作用函数" class="headerlink" title="怎么跳过一些不必要的副作用函数"></a>怎么跳过一些不必要的副作用函数</h3><p>按照上一节的思路，每次重新渲染都要执行一遍这些副作用函数，显然是不经济的。怎么跳过一些不必要的计算呢？我们只需要给 useEffect 传第二个参数即可。用第二个参数来告诉 react 只有当这个参数的值发生改变时，才执行我们传的副作用函数（第一个参数）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  document.title = `You clicked $&#123;count&#125; times`;</span><br><span class="line">&#125;, [count]); // 只有当count的值发生变化时，才会重新执行`document.title`这一句</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当我们第二个参数传一个空数组 [] 时，其实就相当于只在首次渲染的时候执行。也就是 componentDidMount 加 componentWillUnmount 的模式。不过这种用法可能带来 bug，少用。</p><h2 id="还有哪些自带的-Effect-Hooks"><a href="#还有哪些自带的-Effect-Hooks" class="headerlink" title="还有哪些自带的 Effect Hooks?"></a>还有哪些自带的 Effect Hooks?</h2><p>除了上文重点介绍的 useState 和 useEffect，react 还给我们提供来很多有用的 hooks：</p><p>useContext useReducer useCallback useMemo useRef useImperativeMethods useMutationEffect useLayoutEffect</p><p>我不再一一介绍，大家自行去查阅官方文档。</p><h2 id="怎么写自定义的-Effect-Hooks"><a href="#怎么写自定义的-Effect-Hooks" class="headerlink" title="怎么写自定义的 Effect Hooks?"></a>怎么写自定义的 Effect Hooks?</h2><p>为什么要自己去写一个 Effect Hooks? 这样我们才能把可以复用的逻辑抽离出来，变成一个个可以随意插拔的 “插销”，哪个组件要用来，我就插进哪个组件里，so easy！看一个完整的例子，你就明白了。</p><p>比如我们可以把上面写的 FriendStatus 组件中判断朋友是否在线的功能抽出来，新建一个 useFriendStatus 的 hook 专门用来判断某个 id 是否在线。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function useFriendStatus(friendID) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] = useState(null);</span><br><span class="line"></span><br><span class="line">  function handleStatusChange(status) &#123;</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return isOnline;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这时候 FriendStatus 组件就可以简写为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function FriendStatus(props) &#123;</span><br><span class="line">  const isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  if (isOnline === null) &#123;</span><br><span class="line">    return &apos;Loading...&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return isOnline ? &apos;Online&apos; : &apos;Offline&apos;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>简直 Perfect！假如这个时候我们又有一个朋友列表也需要显示是否在线的信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function FriendListItem(props) &#123;</span><br><span class="line">  const isOnline = useFriendStatus(props.friend.id);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;li style=&#123;&#123; color: isOnline ? &apos;green&apos; : &apos;black&apos; &#125;&#125;&gt;</span><br><span class="line">      &#123;props.friend.name&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>简直 Fabulous!</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>不知道你阅读完整篇文章的感受如何，或者对 hooks 有任何角度的看法和思考都欢迎在评论区一起讨论。</p>]]></content>
  </entry>
  <entry>
    <title>Git 设置代理和取消代理</title>
    <url>/archives/a16d.html</url>
    <content><![CDATA[<p>如果代理类型是 socks5 进行如下设置即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>如果是普通的 http/https 进行如下设置即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>取消代理设置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>JS Iframe与父级页面通信及IE9兼容性</title>
    <url>/archives/d4bd.html</url>
    <content><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.cnblogs.com/haosit/p/11301350.html" target="_blank" rel="noopener">https://www.cnblogs.com/haosit/p/11301350.html</a></p></blockquote><p><strong>一、 postMessage</strong></p><p>　　window.postMessage() 方法安全地启用 Window 对象之间的跨源通信；例如，在页面和它产生的弹出窗口之间，或者在页面和嵌入其中的 iframe 之间。</p><p><strong>二、语法</strong></p><p>　　otherWindow.postMessage(message, targetOrigin, [transfer]);</p><p>　　<strong>otherWindow：</strong>是接收对象的窗体引用，例如：子窗体 (iframe) 对父级窗体的引用 “window.parent” 或者其他 Iframe 的引用 “Window.frames + 索引值(命名或数字)”</p><p><strong>message：</strong>将要发送到其他 window 的数据。在 IE9 以下的浏览器, message 不支持 JSON 对象，必须是字符串类型</p><p>　　<strong>targetOrigin：</strong>通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串 “*”（表示无限制）或者一个 URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配 targetOrigin 提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</p><p>　　<strong>transfer：</strong>是一串和 message 同时传递的 <code>Transferable</code> 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</p><p><strong>三、应用子窗体和父窗体之间的通信</strong></p><p><strong>1. parent.html：</strong>添加有 Iframe(childIframe.html) 页面，并监听 message 事件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta  /&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        iframe&#123;</span><br><span class="line">            border:none;</span><br><span class="line">            width:100%;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;parent&lt;/h1&gt;</span><br><span class="line">    &lt;iframe src=&quot;childiframe.html&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.addEventListener(&quot;message&quot;, function (message) &#123;</span><br><span class="line">            alert(JSON.stringify(message.data));</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>2. childIframe.html：</strong>直接向 parent 发送一条消息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta  /&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;childIframe&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.parent.postMessage(&#123;type:&quot;open&quot;,url:&quot;iframe.html&quot;&#125;,&quot;*&quot;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>3. IE9 - 兼容问题：</strong></p><p>　　IE9 及以下的浏览器, message 不支持 JSON 对象，必须是字符串类型。发送时将 JSON 转换为字符串</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.parent.postMessage(JSON.stringify(&#123; type: &quot;open&quot;, url: &quot;iframe.html&quot; &#125;), &quot;*&quot;);</span><br></pre></td></tr></table></figure><p>　　IE9 还是 IE8 不兼容 addEventListener 和 “message” 监听方法和事件，兼容办法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//IE8,IE9兼容方法</span><br><span class="line">if (window.attachEvent) &#123;</span><br><span class="line">    window.attachEvent(&apos;onmessage&apos;, function (message) &#123;</span><br><span class="line">        console.log(JSON.parse(message.data));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    window.addEventListener(&apos;message&apos;, function (message) &#123;</span><br><span class="line">        console.log(JSON.parse(message.data));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>Iframe</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Iframe</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1047.删除字符串中的所有相邻重复项</title>
    <url>/archives/e442.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/1047.删除字符串中的所有相邻重复项.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=216931465&bvid=BV12a411P7mw&cid=801359937&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>遍历字符串：<ul><li>如果当前元素与栈顶元素相同，则进行出栈</li><li>如果不相同，则入栈</li></ul></li><li>最后栈里的所有元素就是结果</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/1047.删除字符串中的所有相邻重复项.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>思路一致</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeDuplicates</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack: <span class="built_in">string</span>[] = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> c of s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.length &amp;&amp; stack[stack.length - <span class="number">1</span>] === c) stack.pop()</span><br><span class="line">    <span class="keyword">else</span> stack.push(c)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-150.逆波兰表达式求值</title>
    <url>/archives/f533.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0150.逆波兰表达式求值.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=387057277&bvid=BV1kd4y1o7on&cid=804365306&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>遍历tokens：<ul><li>如果遇到数字入栈</li><li>如果遇到运算符，连续出栈两个数字进行运算，再将运算结果入栈用于后续计算</li></ul></li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0150.逆波兰表达式求值.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>get了二进制取整小tip</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>出栈两次得到的两个数字顺序与运算顺序时相反的</li><li>除法取整时需要处理一下</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evalRPN</span>(<span class="params">tokens: <span class="built_in">string</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack: <span class="built_in">number</span>[] = []</span><br><span class="line">  <span class="comment">// 注意调用时传入的两个数字是依次出栈得到的，顺序是反的</span></span><br><span class="line">  <span class="keyword">const</span> map = &#123;</span><br><span class="line">    <span class="string">'+'</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> b + a,</span><br><span class="line">    <span class="string">'-'</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> b - a,</span><br><span class="line">    <span class="string">'*'</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> b * a,</span><br><span class="line">    <span class="string">'/'</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> (b / a) | <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> c of tokens) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">in</span> map) stack.push(map[c](stack.pop(), stack.pop()))</span><br><span class="line">    <span class="keyword">else</span> stack.push(+c)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-142.环形链表II</title>
    <url>/archives/c4d8.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0142.环形链表II.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=300762117&bvid=BV1if4y1d7ob&cid=770074935&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="https://cdn.jsdelivr.net/gh/andyyxw/images/img/circular_linked_list.png" alt="环形链表"></p><ul><li>快慢指针。同起点，慢指针每次走一步，快指针每次走2步。如果链表有环 经数学分析可知：<ol><li>两个指针一定会在环内某一点相遇<ol><li>为什么在环内一定会相遇？因为快指针与慢指针的相对速度差了一步，即快指针以一步的相对速度去追慢指针，一定能追到！</li><li>相遇位置不确定，不一定是入环点</li></ol></li><li>相遇时快指针走的路程是慢指针的2倍</li><li>快指针比慢指针在环内多跑了几圈，路程设为m（即<code>m</code>是环长的整数倍）</li><li>综上分析可知：快指针走的总路程是<code>2m</code>，慢指针走的总路程是<code>m</code></li><li>现在只需要分析慢指针：<ol><li>慢指针的轨迹可以分为两部分：<ol><li>慢指针在入环前走了一段路程，设为<code>x</code></li><li>入环后走了一段路程后与快指针相遇，设为<code>y</code></li></ol></li><li>得到<code>x + y = m</code></li><li>回头看看我们的目标是找到入环点，一起分析可发现：<ol><li>两个指针相遇时，慢指针在环内走的路程是<code>y</code>，此时距离入环点的路程是未知的</li><li>但是如果再继续走一段路程<code>x</code>时，则慢指针在环内的总路程达到<code>x + y = m</code>，而<code>m</code>是环长的整数倍，也就是说慢指针跑了整数圈又回到了入环点</li><li>我们不知道<code>x</code>、<code>y</code>的实际长度，但是时机我们是有办法捕获到的：<ol><li>已知<code>x</code>就是起点与入环点的路程，而慢指针在相遇点跑了路程<code>x</code>也到达入环点</li><li>所以解决办法就是慢指针在相遇点开始跑时，同时起点也有一个指针开始跑，同路程同速度一定会在入环点相遇</li></ol></li></ol></li></ol></li></ol></li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0142.环形链表II.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>解法之前学习过，思路一致</li><li>我的解法主要是靠推理，卡尔给出了数学证明</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>入环点、相遇点的具体位置、距离都是未知的，只能通过特殊时机来巧妙地推理</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     next: ListNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectCycle</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> slow = head,</span><br><span class="line">    fast = head</span><br><span class="line">  <span class="keyword">while</span> (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">    slow = slow.next</span><br><span class="line">    fast = fast.next.next</span><br><span class="line">    <span class="keyword">if</span> (slow === fast) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow === head) <span class="keyword">return</span> head</span><br><span class="line">        slow = slow.next</span><br><span class="line">        head = head.next</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>活学活用指针，就像本题不需要知道入环点、相遇点的实际位置（实际上也无法得知，不同链表是不同的），但是只需要通过合理的推理能解决问题即可</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1.两数之和</title>
    <url>/archives/ce53.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/two-sum/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0001.两数之和.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=471096893&bvid=BV1aT41177mK&cid=776815010&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>我们需要记录每个元素出现的位置，所以用<code>hash map</code>即可</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0001.两数之和.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>思路一致</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>要搞清楚哈希表的<code>key</code>、<code>value</code>分别是什么</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">twoSum</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hash = <span class="keyword">new</span> Map&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> num = nums[i],</span><br><span class="line">      s = target - num</span><br><span class="line">    <span class="keyword">if</span> (hash.has(s)) <span class="keyword">return</span> [hash.get(s), i]</span><br><span class="line">    <span class="keyword">else</span> hash.set(num, i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li><code>hash map</code>的经典应用</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-151.反转字符串中的单词</title>
    <url>/archives/9090.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0151.翻转字符串里的单词.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=471513250&bvid=BV1uT41177fX&cid=790645275&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0151.翻转字符串里的单词.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>要保持最优空间复杂度，只能原地修改字符串（js中字符串是不可变数据类型，只能先转为数组，后续操作的算法思想是正确的）</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>移除多余空格时的边界条件处理</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseWords</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = s.split(<span class="string">''</span>)</span><br><span class="line">  removeExtraSpaces(strArr)</span><br><span class="line">  <span class="keyword">const</span> len = strArr.length</span><br><span class="line">  <span class="comment">// 先整体反转</span></span><br><span class="line">  reverse(strArr, <span class="number">0</span>, len - <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 再把每个单词反转回来</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[i] === <span class="string">' '</span> || i === len) &#123;</span><br><span class="line">      reverse(strArr, start, i - <span class="number">1</span>)</span><br><span class="line">      start = i + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strArr.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 删除多余空格 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeExtraSpaces</span>(<span class="params">strArr: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> slow = <span class="number">0</span>,</span><br><span class="line">    fast = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (fast &lt; strArr.length) &#123;</span><br><span class="line">    <span class="comment">// 移除开始位置和重复的空格</span></span><br><span class="line">    <span class="keyword">if</span> (strArr[fast] === <span class="string">' '</span> &amp;&amp; (fast === <span class="number">0</span> || strArr[fast - <span class="number">1</span>] === <span class="string">' '</span>))&#123;</span><br><span class="line">      fast++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      strArr[slow++] = strArr[fast++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  strArr.length = strArr[slow - <span class="number">1</span>] === <span class="string">' '</span> ? slow - <span class="number">1</span> : slow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 反转数组元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">strArr: <span class="built_in">string</span>[], start: <span class="built_in">number</span>, end: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    [strArr[start], strArr[end]] = [strArr[end], strArr[start]]</span><br><span class="line">    start++</span><br><span class="line">    end--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
        <tag>快慢指针</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-15.三数之和</title>
    <url>/archives/4d32.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/3sum/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0015.三数之和.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=941244988&bvid=BV1GW4y127qo&cid=780823635&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>之前做过的忘了。。。</p><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0015.三数之和.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>巧用双指针，看完视频后对去重细节理解了，自己写就一遍过了</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>对第一个数去重</li><li>对后两个数去重</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">threeSum</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span>[][] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">3</span>) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">const</span> res: <span class="built_in">number</span>[][] = []</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span> <span class="comment">// 剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span> <span class="comment">// 去重</span></span><br><span class="line">    <span class="keyword">let</span> left = i + <span class="number">1</span>,</span><br><span class="line">      right = len - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">const</span> sum = nums[i] + nums[left] + nums[right]</span><br><span class="line">      <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) left++</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) right--</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        res.push([nums[i], nums[left++], nums[right--]])</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left - <span class="number">1</span>]) left++ <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right + <span class="number">1</span>]) right-- <span class="comment">// 去重</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O($n^2$)<br>空间复杂度：O(n)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-160.相交链表</title>
    <url>/archives/71ca.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/面试题02.07.链表相交.html" target="_blank" rel="noopener">代码随想录</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>使用双指针分别从两个链表起点开始跑，一个链表跑完后再指向另一个链表</li><li>如果两个链表相交 一定会相遇，如果不相交 最终一定会同时指向null</li></ol><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/面试题02.07.链表相交.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>在链表要跑完时下一个节点的指向要注意，不能直接指向下一个链表(无缝衔接)，而是要先指向null下一轮再指向另一个链表。<ul><li>如果两个链表不存在相交，会有死循环；</li><li>如果两个链表存在相交，在最终同时指向null之前一定会相遇</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     next: ListNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Algorithm: Double Pointer</span></span><br><span class="line"><span class="comment"> * Time Complexity: O(m + n)</span></span><br><span class="line"><span class="comment"> * Space Complexity: O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIntersectionNode</span>(<span class="params">headA: ListNode | <span class="literal">null</span>, headB: ListNode | <span class="literal">null</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!headA || !headB) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> pA = headA,</span><br><span class="line">    pB = headB</span><br><span class="line">  <span class="comment">// 判断p而不是p.next的原因是：如果是判断p.next，那就是直接从一个链表过度到另一个链表，如果两个链表不相交，会存在死循环</span></span><br><span class="line">  <span class="comment">// 如果两个链表相交，在最终同时指向null之前一定会相遇</span></span><br><span class="line">  <span class="keyword">while</span> (pA !== pB) &#123;</span><br><span class="line">    pA = pA ? pA.next : headB</span><br><span class="line">    pB = pB ? pB.next : headA</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-18.四数之和</title>
    <url>/archives/98c7.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/4sum/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0018.四数之和.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=728760817&bvid=BV1DS4y147US&cid=783669679&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>与<a href="/archives/4d32.html">15.三数之和</a>思路一样，外面多了一层循环</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0018.四数之和.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>彻底理解了双指针解法，与Carl思路一致</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>去重</li><li>剪枝</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fourSum</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span>[][] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = nums.length</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">4</span>) <span class="keyword">return</span> []</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">  <span class="keyword">const</span> res: <span class="built_in">number</span>[][] = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; target &amp;&amp; nums[i] &gt; <span class="number">0</span> &amp;&amp; target &gt; <span class="number">0</span>) <span class="keyword">break</span> <span class="comment">// 剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span> <span class="comment">// 去重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] + nums[j] &gt; target &amp;&amp; nums[i] + nums[j] &gt; <span class="number">0</span> &amp;&amp; target &gt; <span class="number">0</span>) <span class="keyword">break</span> <span class="comment">// 剪枝</span></span><br><span class="line">      <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) <span class="keyword">continue</span> <span class="comment">// 去重</span></span><br><span class="line">      <span class="keyword">let</span> left = j + <span class="number">1</span>,</span><br><span class="line">        right = len - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">const</span> sum = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) left++</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) right--</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          res.push([nums[i], nums[j], nums[left++], nums[right--]])</span><br><span class="line">          <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left - <span class="number">1</span>]) left++ <span class="comment">// 去重</span></span><br><span class="line">          <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right + <span class="number">1</span>]) right-- <span class="comment">// 去重</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O($n^3$)<br>空间复杂度：O(n)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-19.删除链表的倒数第 N 个结点</title>
    <url>/archives/f12f.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0019.删除链表的倒数第N个节点.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=940659258&bvid=BV1vW4y1U7Gf&cid=767366533&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>本题关键是找到倒数第n个节点：<ol><li>快慢指针</li><li>快指针先跑n步</li><li>然后两个指针同步跑，最后快指针到达末尾时停止</li><li>慢指针则刚好到达倒数第n个节点</li></ol></li><li>需要用虚拟头节点，因为可能删除的是头结点</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0019.删除链表的倒数第N个节点.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>快慢指针迭代法与我的思路一致，学会了递归倒退n法</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>慢指针要停在删除节点的前一个节点</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p>快慢指针</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     next: ListNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNthFromEnd</span>(<span class="params">head: ListNode | <span class="literal">null</span>, n: <span class="built_in">number</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> ListNode()</span><br><span class="line">  dummyHead.next = head</span><br><span class="line">  <span class="keyword">let</span> slow = dummyHead,</span><br><span class="line">    fast = dummyHead</span><br><span class="line">  <span class="keyword">while</span> (n--) fast = fast.next</span><br><span class="line">  <span class="keyword">while</span> (fast.next) &#123;</span><br><span class="line">    slow = slow.next</span><br><span class="line">    fast = fast.next</span><br><span class="line">  &#125;</span><br><span class="line">  slow.next = slow.next.next</span><br><span class="line">  <span class="keyword">return</span> dummyHead.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* class ListNode &#123;</span></span><br><span class="line"><span class="comment">*     val: number</span></span><br><span class="line"><span class="comment">*     next: ListNode | null</span></span><br><span class="line"><span class="comment">*     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment">*         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment">*         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNthFromEnd</span>(<span class="params">head: ListNode | <span class="literal">null</span>, n: <span class="built_in">number</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> ListNode()</span><br><span class="line">  dummyHead.next = head</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recursion</span>(<span class="params">node : ListNode | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">    recursion(node.next)</span><br><span class="line">    count++</span><br><span class="line">    <span class="keyword">if</span> (count === n + <span class="number">1</span>) node.next = node.next.next</span><br><span class="line">  &#125;</span><br><span class="line">  recursion(dummyHead)</span><br><span class="line">  <span class="keyword">return</span> dummyHead.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-20.有效的括号</title>
    <url>/archives/c7da.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/valid-parentheses/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0020.有效的括号.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=301823875&bvid=BV1AF411w78g&cid=799270643&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>遍历字符串<ul><li>遇到左括号-&gt;入栈;</li><li>遇到右括号-&gt;出栈 并判断出栈元素是否与当前的遍历到的右括号成对，不成对则终止</li></ul></li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0020.有效的括号.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>使用字典来简化判断逻辑</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isValid</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s.length % <span class="number">2</span> !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> stack: <span class="built_in">string</span>[] = []</span><br><span class="line">  <span class="keyword">const</span> map = &#123;</span><br><span class="line">    <span class="string">'('</span>: <span class="string">')'</span>,</span><br><span class="line">    <span class="string">'['</span>: <span class="string">']'</span>,</span><br><span class="line">    <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> c of s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">in</span> map) stack.push(c)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (map[stack.pop()] !== c) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !stack.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li><strong>数据结构与算法的应用往往隐藏在我们看不到的地方</strong></li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-202.快乐数</title>
    <url>/archives/971d.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/happy-number/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0202.快乐数.html" target="_blank" rel="noopener">代码随想录</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>题目中说了如果不是快乐数就会出现无限循环，那么用哈希表记录n的每次迭代值：<ul><li>出现1则为快乐数</li><li>出现重复值则不是</li></ul></li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0202.快乐数.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>思路一致</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>计算迭代值时要细心点</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p>哈希表</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHappy</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hash = <span class="keyword">new</span> Set&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">  <span class="keyword">while</span> (n !== <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hash.has(n)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    hash.add(n)</span><br><span class="line">    n = getNext(n)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    sum += (n % <span class="number">10</span>) ** <span class="number">2</span></span><br><span class="line">    n = <span class="built_in">Math</span>.floor(n / <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p></li><li><p>快慢指针（空间复杂度较好）</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHappy</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> slow = n,</span><br><span class="line">    fast = n</span><br><span class="line">  <span class="comment">// 环形链表的思想，如果有环，快慢指针一定会在环内相遇</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    slow = getNext(slow)</span><br><span class="line">    fast = getNext(getNext(fast))</span><br><span class="line">    <span class="keyword">if</span> (slow === fast) <span class="keyword">return</span> slow === <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    sum += (n % <span class="number">10</span>) ** <span class="number">2</span></span><br><span class="line">    n = <span class="built_in">Math</span>.floor(n / <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p></li></ul><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>要透过现象发现本质。本题看上去像是数学问题，其实不是。</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
        <tag>快慢指针</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-206.反转链表</title>
    <url>/archives/7a3f.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/reverse-linked-list/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0206.翻转链表.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=598107226&bvid=BV1nB4y1i7eL&cid=763421475&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>遍历一遍链表，利用双指针将每个节点的指向反转</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0206.翻转链表.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>学会了递归写法</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li><code>while</code>循环的终止条件，最终返回值需要注意 容易出错</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>双指针迭代</li></ul><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     next: ListNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>,</span><br><span class="line">    cur = head</span><br><span class="line">  <span class="keyword">while</span> (cur) [cur.next, prev, cur] = [prev, cur, cur.next]</span><br><span class="line">  <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><ul><li>递归</li></ul><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     next: ListNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> reverse(head, <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">cur: ListNode | <span class="literal">null</span>, prev: ListNode | <span class="literal">null</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!cur) <span class="keyword">return</span> prev</span><br><span class="line">  <span class="keyword">const</span> tmp = cur.next</span><br><span class="line">  cur.next = prev</span><br><span class="line">  <span class="keyword">return</span> reverse(tmp, cur)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>链表的操作顺序一定要理清楚 不能乱，否则很容易断链</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-209.长度最小的子数组</title>
    <url>/archives/6abf.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0209.长度最小的子数组.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=384964151&bvid=BV1tZ4y1q7XE&cid=745986197&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>滑动窗口，先滑右边界，直至 <code>sum &gt;= target</code>，再收缩左边界直至不符合 <code>sum &gt;= target</code></li><li>重复循环上面的过程，直至窗口滑到右边界，且不符合 <code>sum &gt;= target</code> 时结束</li></ol><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0209.长度最小的子数组.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><p>主要确定如下三点：</p><ul><li>窗口内是什么？窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</li><li>如何移动窗口的起始位置？如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）</li><li>如何移动窗口的结束位置？窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>边界条件、窗口滑动的时机、统计子数组长度 这些点都需要注意，容易出错</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minSubArrayLen</span>(<span class="params">target: <span class="built_in">number</span>, nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = nums.length</span><br><span class="line">  <span class="keyword">let</span> res = len + <span class="number">1</span>,</span><br><span class="line">    left = <span class="number">0</span>,</span><br><span class="line">    right = <span class="number">0</span>,</span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">    sum += nums[right++]</span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">      res = <span class="built_in">Math</span>.min(res, right - left)</span><br><span class="line">      sum -= nums[left++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res &gt; len ? <span class="number">0</span>: res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>学会了滑动窗口的通用解题思路：外层循环移动窗口终止位置，内层循环移动窗口起始位置</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-203.移除链表元素</title>
    <url>/archives/da77.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0203.移除链表元素.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=600158049&bvid=BV18B4y1s7R9&cid=753794207&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>生成一个<em>虚拟头节点</em><code>dummyHead</code>指向<code>head</code></li><li>然后从<code>dummyHead</code>开始完整的遍历链表：判断当前节点的后一个节点val是否是否是目标值，如果是则将当前节点的next指向下下个节点（即跳过目标节点，从而达到删除效果）</li></ol><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0203.移除链表元素.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>与我想法一致</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">* class ListNode &#123;</span></span><br><span class="line"><span class="comment">*     val: number</span></span><br><span class="line"><span class="comment">*     next: ListNode | null</span></span><br><span class="line"><span class="comment">*     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment">*         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment">*         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeElements</span>(<span class="params">head: ListNode | <span class="literal">null</span>, val: <span class="built_in">number</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> ListNode()</span><br><span class="line">  dummyHead.next = head</span><br><span class="line">  <span class="keyword">let</span> cur = dummyHead</span><br><span class="line">  <span class="keyword">while</span> (cur.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.next.val === val) cur.next = cur.next.next</span><br><span class="line">    <span class="keyword">else</span> cur = cur.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummyHead.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li><a href="/tags/链表/">链表</a>进行增删操作时通常可以使用<em>虚拟头节点</em>，就不需要单独处理头节点了，使得处理方法统一，代码更清爽。</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-225.用队列实现栈</title>
    <url>/archives/fd25.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0225.用队列实现栈.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=344329109&bvid=BV1Fd4y1K7sm&cid=797278452&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>两个队列互相倒腾：<ul><li>pop时将队列1中的元素队列并入队到队列2，剩最后一个即pop的目标元素</li><li>如果pop时队列为空，则将队列2与队列1内容互换</li></ul></li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0225.用队列实现栈.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>学会了只用一个队列也能实现栈</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p>一个队列实现栈</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* var obj = new MyStack()</span></span><br><span class="line"><span class="comment">* obj.push(x)</span></span><br><span class="line"><span class="comment">* var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment">* var param_3 = obj.top()</span></span><br><span class="line"><span class="comment">* var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MyStack &#123;</span><br><span class="line">  queue: <span class="built_in">number</span>[]</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push(x: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.push(x)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = <span class="keyword">this</span>.queue.length</span><br><span class="line">    <span class="keyword">while</span> (--len) <span class="keyword">this</span>.queue.push(<span class="keyword">this</span>.queue.shift())</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.shift()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  top(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> top = <span class="keyword">this</span>.pop()</span><br><span class="line">    <span class="keyword">this</span>.queue.push(top)</span><br><span class="line">    <span class="keyword">return</span> top</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  empty(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="keyword">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>两个队列实现栈</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* var obj = new MyStack()</span></span><br><span class="line"><span class="comment">* obj.push(x)</span></span><br><span class="line"><span class="comment">* var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment">* var param_3 = obj.top()</span></span><br><span class="line"><span class="comment">* var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MyStack &#123;</span><br><span class="line">  queue1: <span class="built_in">number</span>[]</span><br><span class="line">  queue2: <span class="built_in">number</span>[]</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue1 = []</span><br><span class="line">    <span class="keyword">this</span>.queue2 = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push(x: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue1.push(x)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.queue1.length) [<span class="keyword">this</span>.queue1, <span class="keyword">this</span>.queue2] = [<span class="keyword">this</span>.queue2, <span class="keyword">this</span>.queue1]</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.queue1.length &gt; <span class="number">1</span>) <span class="keyword">this</span>.queue2.push(<span class="keyword">this</span>.queue1.shift())</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue1.shift()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  top(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> top = <span class="keyword">this</span>.pop()</span><br><span class="line">    <span class="keyword">this</span>.queue1.push(top)</span><br><span class="line">    <span class="keyword">return</span> top</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  empty(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="keyword">this</span>.queue1.length &amp;&amp; !<span class="keyword">this</span>.queue2.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>学会了极致的的代码复用。本题中<code>top</code>函数就完全复用了<code>pop</code>函数逻辑</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-239.滑动窗口最大值</title>
    <url>/archives/6798.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0239.滑动窗口最大值.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=729559279&bvid=BV1XS4y1p7qj&cid=806301877&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>使用双端队列实现单调递减队列，队顶始终是最大值</li><li>每次滑动窗口时，均有元素入队和出对，然后队顶元素就是当前窗口的最大值</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0239.滑动窗口最大值.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>将单调队列的代码抽离封装好，主流程十分简单已读</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>实现单调队列时入队逻辑</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxSlidingWindow</span>(<span class="params">nums: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res: <span class="built_in">number</span>[] = [],</span><br><span class="line">    queue = <span class="keyword">new</span> MonoQueue&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    queue.enqueue(nums[i])</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k) queue.dequeue(nums[i - k])</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) res.push(queue.top())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 单调递减队列 */</span></span><br><span class="line"><span class="keyword">class</span> MonoQueue&lt;T&gt; &#123;</span><br><span class="line">  queue: T[]</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  enqueue(value: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// 比value小的都剔除</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.queue.length &amp;&amp; value &gt; <span class="keyword">this</span>.queue[<span class="keyword">this</span>.queue.length - <span class="number">1</span>]) <span class="keyword">this</span>.queue.pop()</span><br><span class="line">    <span class="keyword">this</span>.queue.push(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dequeue(value: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// value可能在前面元素push的时候已经被剔除了</span></span><br><span class="line">    <span class="keyword">if</span> (value === <span class="keyword">this</span>.top()) <span class="keyword">this</span>.queue.shift()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  top(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>学习了单调队列</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>队列</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-232.用栈实现队列</title>
    <url>/archives/5c9c.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0232.用栈实现队列.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=644140871&bvid=BV1nY4y1w7VC&cid=794448489&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>利用两个栈来模拟</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0232.用栈实现队列.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>重点是利用第二个栈来模拟出队列行为</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>注意<code>popStack</code>中已有元素时，不能再向其中push了，否则就乱了（因为<code>popStack</code>的栈顶元素实际是模拟队列顶：即将要出队列的元素）</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyQueue()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MyQueue &#123;</span><br><span class="line">  pushStack: <span class="built_in">number</span>[]</span><br><span class="line">  popStack: <span class="built_in">number</span>[]</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.pushStack = []</span><br><span class="line">    <span class="keyword">this</span>.popStack = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push(x: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.pushStack.push(x)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.popStack.length) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">this</span>.pushStack.length) <span class="keyword">this</span>.popStack.push(<span class="keyword">this</span>.pushStack.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.popStack.pop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  peek(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> top = <span class="keyword">this</span>.pop()</span><br><span class="line">    <span class="keyword">this</span>.popStack.push(top)</span><br><span class="line">    <span class="keyword">return</span> top</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  empty(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(<span class="keyword">this</span>.pushStack.length || <span class="keyword">this</span>.popStack.length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li><strong>一定要懂得复用，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出问题！（踩过坑的人自然懂）</strong></li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-24.两两交换链表中的节点</title>
    <url>/archives/6ba3.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=470747611&bvid=BV1YT411g7br&cid=765323235&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>使用虚拟头节点，交换头结点的后两个节点</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>为什么第一时间想到使用虚拟头结点呢，因为如果想要交换两个节点，<code>cur</code>必须指向这两个节点的前一个节点</li><li>只需要操作<code>cur</code>一个指针就够了</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>循环的终止条件容易出错</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p>迭代</p><p>我原本的写法：</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     next: ListNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapPairs</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> ListNode()</span><br><span class="line">  dummyHead.next = head</span><br><span class="line">  <span class="keyword">let</span> cur = dummyHead</span><br><span class="line">  <span class="keyword">while</span> (head &amp;&amp; head.next) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = head.next</span><br><span class="line">    head.next = next.next</span><br><span class="line">    next.next = head</span><br><span class="line">    cur.next = next</span><br><span class="line">    cur = head</span><br><span class="line">    head = head.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummyHead.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的写法：</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     next: ListNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapPairs</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> ListNode()</span><br><span class="line">  dummyHead.next = head</span><br><span class="line">  <span class="keyword">let</span> cur = dummyHead</span><br><span class="line">  <span class="keyword">while</span> (cur.next &amp;&amp; cur.next.next) &#123;</span><br><span class="line">    <span class="keyword">let</span> next1 = cur.next,</span><br><span class="line">      next2 = next1.next.next</span><br><span class="line">    cur.next = next1.next</span><br><span class="line">    next1.next.next = next1</span><br><span class="line">    next1.next = next2</span><br><span class="line">    cur = next1</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummyHead.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p></li><li><p>递归</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     next: ListNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, next?: ListNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapPairs</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head</span><br><span class="line">  <span class="keyword">let</span> next = head.next</span><br><span class="line">  head.next = swapPairs(next.next)</span><br><span class="line">  next.next = head</span><br><span class="line">  <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p></li></ul><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>链表操作要谨慎，熟练使用虚拟头节点和<code>temp</code>，避免断链</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-242.有效的字母异位词</title>
    <url>/archives/6aa1.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/valid-anagram/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0242.有效的字母异位词.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=428486350&bvid=BV1YG411p7BA&cid=772001165&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>使用hash表记录每个字符出现的次数再比较</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0242.有效的字母异位词.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>原本我用的是hashMap，后来发现不需要，用数组即可</li><li>只创建一个hash数组即可，并且两个字符串只需要分别遍历一遍，一遍累加一遍累减即可</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p>Hash Array</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isAnagram</span>(<span class="params">s: <span class="built_in">string</span>, t: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s.length !== t.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> hash: <span class="built_in">number</span>[] = <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> base = <span class="string">'a'</span>.codePointAt(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) hash[s.codePointAt(i) - base]++</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">    hash[t.codePointAt(i) - base]--</span><br><span class="line">    <span class="keyword">if</span> (hash[t.codePointAt(i) - base] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p></li><li><p>Hash Map</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isAnagram</span>(<span class="params">s: <span class="built_in">string</span>, t: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s.length !== t.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> hash = <span class="keyword">new</span> Map&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> c of s) hash.set(c, (hash.get(c) || <span class="number">0</span>) + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> c of t) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = hash.get(c)</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) hash.set(c, count  - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p></li></ul><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-27.移除元素</title>
    <url>/archives/64f.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/remove-element/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0027.移除元素.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=896973525&bvid=BV12A4y1Z7LP&cid=731188361&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>先排序，再使用双指针去遍历找到需要移除的那段区间移除掉</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0027.移除元素.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>原来不需要排序，只遍历一遍就可以，原地修改数组</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeElement</span>(<span class="params">nums: <span class="built_in">number</span>[], val: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> slow = <span class="number">0</span>, <span class="comment">// 慢指针指向新数组的元素</span></span><br><span class="line">    fast = <span class="number">0</span> <span class="comment">// 快指针指向原数组的元素</span></span><br><span class="line">  <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[fast] !== val) nums[slow++] = nums[fast]</span><br><span class="line">    fast++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
        <tag>快慢指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-28.找出字符串中第一个匹配项的下标</title>
    <url>/archives/c765.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0028.实现strStr.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=712030093&bvid=BV1PD4y1o7nd&cid=493095580&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><br><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=457239548&bvid=BV1M5411j7Xx&cid=496522111&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>解决字符串匹配问题的经典算法：KMP</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0028.实现strStr.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>学习理解KMP算法<ul><li>理解KMP算法的原理，它是如何加速字符串匹配的</li><li>生成前缀表</li><li>利用前缀表写出匹配过程</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strStr</span>(<span class="params">haystack: <span class="built_in">string</span>, needle: <span class="built_in">string</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prefix = getPrefix(needle)</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; haystack.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] !== needle[j]) j = prefix[j - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (haystack[i] === needle[j]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j === needle.length - <span class="number">1</span>) <span class="keyword">return</span> i - j</span><br><span class="line">      j++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 求KMP最长公共前后缀 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPrefix</span>(<span class="params">str: <span class="built_in">string</span></span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> prefix: <span class="built_in">number</span>[] = [j]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str[i] !== str[j]) j = prefix[j - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (str[i] === str[j]) j++</span><br><span class="line">    prefix[i] = j</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prefix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(m+n)<br>空间复杂度：O(n)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>系统学习了KMP算法</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-344.反转字符串</title>
    <url>/archives/f3c.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/reverse-string/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0344.反转字符串.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=856322054&bvid=BV1fV4y17748&cid=785729810&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>双指针收缩，每次交换两个指针的元素值</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0344.反转字符串.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>思路一致</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString</span>(<span class="params">s: <span class="built_in">string</span>[]</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">    right = s.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    [s[left], s[right]] = [s[right], s[left]]</span><br><span class="line">    left++</span><br><span class="line">    right--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>在算法的解题思路上，字符串和数组是差不多的，只不过在不同编程语言中有着不同的操作</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-34.在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/archives/a130.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0034.在排序数组中查找元素的第一个和最后一个位置.html" target="_blank" rel="noopener">代码随想录</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>用双指针二分法</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0034.在排序数组中查找元素的第一个和最后一个位置.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li><p>我的解法只用了一次二分，找到目标值后再向两边延伸：</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchRange</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">    right = nums.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = left + ((right - left) &gt;&gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === target) &#123;</span><br><span class="line">      left = right = mid</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> right = mid - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">while</span> (nums[--left] === target) &#123;&#125;</span><br><span class="line">  <span class="keyword">while</span> (nums[++right] === target) &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> [++left, --right]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然ac了，但是因为最后的遍历寻找边界导致时间复杂度实际是O(n)，不符合题目要求的O($\log n$)</p></li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>边界不好判断</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p>两遍二分法分别寻找左边界和右边界：</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchRange</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!nums.length) <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">const</span> leftBorder = getLeftBorder(nums, target)</span><br><span class="line">  <span class="keyword">const</span> rightBorder = getRightBorder(nums, target)</span><br><span class="line">  <span class="keyword">if</span> (leftBorder === nums.length || rightBorder === <span class="number">0</span>) <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>] <span class="comment">// target在nums区间两侧</span></span><br><span class="line">  <span class="keyword">if</span> (rightBorder - leftBorder &lt;= <span class="number">1</span>) <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>] <span class="comment">// target不存在nums中</span></span><br><span class="line">  <span class="keyword">return</span> [leftBorder + <span class="number">1</span>, rightBorder - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLeftBorder</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">    right = nums.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = left + ((right - left) &gt;&gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> right = mid - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRightBorder</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">    right = nums.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = left + ((right - left) &gt;&gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> left = mid + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O($\log n$)<br>空间复杂度：O(1)</p></li></ul><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><ul><li>二分法的灵活运用</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>数组</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode.349.两个数组的交集</title>
    <url>/archives/4dd2.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0349.两个数组的交集.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=258484486&bvid=BV1ba411S7wu&cid=774679429&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>选择一个合适的数据结构：本题需要判断一个元素在集合中是否出现过，典型的哈希表的使用场景，又不需要记录出现次数 那就用<code>hash set</code>即可</li></ol><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0349.两个数组的交集.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>思路一致</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params">nums1: <span class="built_in">number</span>[], nums2: <span class="built_in">number</span>[]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hash = <span class="keyword">new</span> Set(nums1)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(</span><br><span class="line">    nums2.reduce(</span><br><span class="line">      (acc, cur) =&gt; (hash.has(cur) &amp;&amp; acc.add(cur), acc),</span><br><span class="line">      <span class="keyword">new</span> Set&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-35.搜索插入位置</title>
    <url>/archives/b702.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/search-insert-position/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0035.搜索插入位置.html" target="_blank" rel="noopener">代码随想录</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>经典的双指针二分法</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0035.搜索插入位置.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>之前在 <a href="/archives/4f45.html">LeetCode-704.二分查找</a> 已经掌握了Carl教的二分法使用开闭区间判断边界条件的精髓，做完题后检查了一遍与Carl的题解一致！</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p>二分法（左闭右闭）</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchInsert</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">    right = nums.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = left + ((right - left) &gt;&gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === target) <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> right = mid - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O($\log n$)<br>空间复杂度：O(1)</p></li><li><p>二分法（左闭右开）</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchInsert</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">    right = nums.length</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = left + ((right - left) &gt;&gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === target) <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> right = mid</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O($\log n$)<br>空间复杂度：O(1)</p></li></ul><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>二分法玩明白了</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-383.赎金信</title>
    <url>/archives/9001.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/ransom-note/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0383.赎金信.html" target="_blank" rel="noopener">代码随想录</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>哈希表记录每个字符串出现的次数</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0383.赎金信.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>思路一致</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p>Hash Array</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canConstruct</span>(<span class="params">ransomNote: <span class="built_in">string</span>, magazine: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hash = <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> base = <span class="string">'a'</span>.codePointAt(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; magazine.length; i++) hash[magazine.codePointAt(i) - base]++</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ransomNote.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = ransomNote.codePointAt(i) - base</span><br><span class="line">    hash[index]--</span><br><span class="line">    <span class="keyword">if</span> (hash[index] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p></li><li><p>Hash Map</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canConstruct</span>(<span class="params">ransomNote: <span class="built_in">string</span>, magazine: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hash = <span class="keyword">new</span> Map&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> c of magazine) hash.set(c, (hash.get(c) || <span class="number">0</span>) + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> c of ransomNote) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = hash.get(c)</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) hash.set(c, count - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p></li></ul><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>已经轻车熟路了，与<a href="/archives/6aa1.html">242.有效的字母异位词</a>解法一致</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-454.四数相加II</title>
    <url>/archives/4a6c.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/4sum-ii/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0454.四数相加II.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=386006485&bvid=BV1Md4y1Q7Yh&cid=778751921&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0454.四数相加II.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>将数组分为两部分的思路很好，之前没想到</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fourSumCount</span>(<span class="params">nums1: <span class="built_in">number</span>[], nums2: <span class="built_in">number</span>[], nums3: <span class="built_in">number</span>[], nums4: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> hash = <span class="keyword">new</span> Map&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> v1 of nums1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> v2 of nums2) &#123;</span><br><span class="line">      <span class="keyword">const</span> v = v1 + v2</span><br><span class="line">      hash.set(v, (hash.get(v) || <span class="number">0</span>) + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> v1 of nums3) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> v2 of nums4) &#123;</span><br><span class="line">      res += (hash.get(<span class="number">0</span> - (v1 + v2)) || <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O($n^2$)<br>空间复杂度：O(n)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>哈希法的经典题目</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-541.反转字符串II</title>
    <url>/archives/c80d.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/reverse-string-ii/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0541.反转字符串II.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=471495028&bvid=BV1dT411j7NN&cid=787669511&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>模拟字符串遍历，分段拼接字符串</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0541.反转字符串II.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>可以将字符串先转化成数组，便于原地进行字符反转(同<a href="/archives/f3c.html">344.反转字符串</a>)，最后再转回字符串</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseStr</span>(<span class="params">s: <span class="built_in">string</span>, k: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = s.split(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = res.length; i &lt; len; i += k * <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = i,</span><br><span class="line">      right = <span class="built_in">Math</span>.min(i + k - <span class="number">1</span>, len - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">      [res[left], res[right]] = [res[right], res[left]]</span><br><span class="line">      left++</span><br><span class="line">      right--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>js中字符串是基本类型，不能直接修改，可转化为数组便于操作</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-59.螺旋矩阵II</title>
    <url>/archives/631e.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0059.螺旋矩阵II.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=855058314&bvid=BV1SL4y1N7mV&cid=748302443&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>模拟顺时针旋转路线，每一圈有4个边，实际就是每圈包含4次遍历</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0059.螺旋矩阵II.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>遵循<em>循环不变量规则</em>：对每条边的处理规则要统一。每条边的遍历都是左闭右开</li><li>需要转<code>Math.floor(n/2)</code>圈，如果<code>n</code>是奇数，跑完圈还剩下中心点再赋值一下</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>模拟旋转时循环的边界条件太多，很难处理</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateMatrix</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="title">number</span>[][] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res: <span class="built_in">number</span>[][] = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(n), <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Array</span>(n)),</span><br><span class="line">    loop = n &gt;&gt;&gt; <span class="number">1</span> <span class="comment">// 需要的旋转圈数</span></span><br><span class="line">  <span class="keyword">let</span> offset = <span class="number">0</span>, <span class="comment">// 当前已旋转圈数</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">  <span class="comment">// 循环不变量规则：每条边遍历时均使用左开右闭区间</span></span><br><span class="line">  <span class="keyword">while</span> (offset &lt; loop) &#123;</span><br><span class="line">    <span class="keyword">let</span> row = offset,</span><br><span class="line">      col = offset</span><br><span class="line">    <span class="keyword">while</span> (col &lt; n - offset - <span class="number">1</span>) res[row][col++] = count++</span><br><span class="line">    <span class="keyword">while</span> (row &lt; n - offset - <span class="number">1</span>) res[row++][col] = count++</span><br><span class="line">    <span class="keyword">while</span> (col &gt; offset) res[row][col--] = count++</span><br><span class="line">    <span class="keyword">while</span> (row &gt; offset) res[row--][col] = count++</span><br><span class="line">    offset++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果n是奇数，一定剩下中心点没有赋值</span></span><br><span class="line">  <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res[loop][loop] = count</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O($n^2$)<br>空间复杂度：O($n^2$)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>get了<em>循环不变量规则</em>，尤其是在<a href="/tags/模拟/">模拟</a>类题目很有用。</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>数组</tag>
        <tag>矩阵</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-459.重复的子字符串</title>
    <url>/archives/e0bf.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/repeated-substring-pattern/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0459.重复的子字符串.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=514040419&bvid=BV1cg41127fw&cid=792550174&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>想到了用KMP，但是没想明白前缀表的用处</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0459.重复的子字符串.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>get了移动字符串匹配解法</li><li>利用前缀表 通过数学推导出最小重复子串：除去最大公共前后缀的剩余部分就是最小重复子串</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>KMP求前缀表</li><li>前缀表的作用</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p>移动字符串匹配</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatedSubstringPattern</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (s + s).slice(<span class="number">1</span>, s.length * <span class="number">2</span> - <span class="number">1</span>).includes(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>KMP</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatedSubstringPattern</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prefix = getPrefix(s),</span><br><span class="line">    lastPrefix = prefix[prefix.length - <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">return</span> lastPrefix !== <span class="number">0</span> &amp;&amp; (s.length % (s.length - lastPrefix)) === <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPrefix</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> prefix: <span class="built_in">number</span>[] = [j]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] !== s[j]) j = prefix[j - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (s[i] === s[j]) j++</span><br><span class="line">    prefix[i] = j</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prefix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>get了利用KMP求最小重复子串的方法</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-707.设计链表</title>
    <url>/archives/2ed3.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/design-linked-list/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0707.设计链表.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=685492340&bvid=BV1FU4y1X7WD&cid=758264222&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>先定义节点类<code>ListNode</code>，在他基础上实现链表类<code>MyLinkedList</code></li><li><code>MyLinkedList</code>的构造函数中需要链表的头结点<code>head</code>和长度<code>size</code>，后续的方法操作会更新相应的值</li></ol><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0707.设计链表.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>链表的增删操作都可以直接用<em>虚拟头节点</em></li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><p>边界情况总是忘记处理，出现空指针异常，提交了多次才ac，比如：</p><ul><li><code>addAtTail</code>时如果链表为空，实际就是<code>addAtHead</code></li><li><code>addAtIndex`</code>index &lt;= 0<code>时实际就是</code>addAtHead<code>，</code>index === this.size<code>时实际就是</code>addAtTail`</li><li><code>deleteAtIndex</code>可能会删头结点，需要用一个<code>dummyHead</code>来处理</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> LinkNode &#123;</span><br><span class="line">  val: <span class="built_in">any</span></span><br><span class="line">  next: LinkNode | <span class="literal">null</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">val?: <span class="built_in">any</span>, next?: LinkNode | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val</span><br><span class="line">    <span class="keyword">this</span>.next = next || <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* var obj = new MyLinkedList()</span></span><br><span class="line"><span class="comment">* var param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment">* obj.addAtHead(val)</span></span><br><span class="line"><span class="comment">* obj.addAtTail(val)</span></span><br><span class="line"><span class="comment">* obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment">* obj.deleteAtIndex(index)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> MyLinkedList &#123;</span><br><span class="line">  size: <span class="built_in">number</span></span><br><span class="line">  head: LinkNode | <span class="literal">null</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span>(index: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; index--) cur = cur.next</span><br><span class="line">    <span class="keyword">return</span> cur ? cur.val : <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addAtHead(val: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkNode(val, <span class="keyword">this</span>.head)</span><br><span class="line">    <span class="keyword">this</span>.size++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addAtTail(val: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.addAtHead(val)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">while</span> (cur.next) cur = cur.next</span><br><span class="line">    cur.next = <span class="keyword">new</span> LinkNode(val)</span><br><span class="line">    <span class="keyword">this</span>.size++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addAtIndex(index: <span class="built_in">number</span>, val: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="keyword">this</span>.size) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.addAtHead(val)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="keyword">this</span>.size) &#123;</span><br><span class="line">      <span class="keyword">this</span>.addAtTail(val)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">while</span> (index-- &gt; <span class="number">1</span>) cur = cur.next</span><br><span class="line">    cur.next = <span class="keyword">new</span> LinkNode(val, cur.next)</span><br><span class="line">    <span class="keyword">this</span>.size++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  deleteAtIndex(index: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> dummyHead = <span class="keyword">new</span> LinkNode()</span><br><span class="line">    dummyHead.next = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">let</span> cur = dummyHead</span><br><span class="line">    <span class="keyword">while</span> (index--) cur = cur.next</span><br><span class="line">    cur.next = cur.next.next</span><br><span class="line">    <span class="keyword">this</span>.head = dummyHead.next</span><br><span class="line">    <span class="keyword">this</span>.size--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>对<a href="/tags/链表/">链表</a>操作和手写数据结构有了更多认识</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-704.二分查找</title>
    <url>/archives/4f45.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/binary-search/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0704.二分查找.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=896855273&bvid=BV1fA4y1o715&cid=783305542&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用双指针二分法，确定左右区间分别为数组的起点和终点，每次取中间元素<code>mid</code>跟<code>target</code>对比：</p><ul><li>如果<code>mid</code>较小，收缩左区间到<code>mid</code>；</li><li>如果<code>mid</code>较大，收缩有区间到<code>mid</code>。</li><li>直到左右区间相遇</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0704.二分查找.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>使用开闭区间来辅助判断循环的终止条件和区间迭代变化，写起来更轻松流畅</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>对边界条件判断模糊</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p>二分法（左闭右闭）</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mid: <span class="built_in">number</span>,</span><br><span class="line">    left = <span class="number">0</span>,</span><br><span class="line">    right = nums.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    mid = left + ((right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === target) <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> right = mid - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O($\log n$)<br>空间复杂度：O(1)</p></li><li><p>二分法（左闭右开）</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mid: <span class="built_in">number</span>, </span><br><span class="line">    left = <span class="number">0</span>,</span><br><span class="line">    right = nums.length</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    mid = left + ((right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === target) <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> right = mid</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O($\log n$)<br>空间复杂度：O(1)</p></li></ul><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>对双指针理解更深刻了，可以两端收缩，可以是快慢指针</li><li>对二分法的边界条件判断更清晰了，用开闭区间的方法辅助判断（一般用<code>左闭右闭</code>/<code>左闭右开</code>）</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-977.有序数组的平方</title>
    <url>/archives/bc1e.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/0977.有序数组的平方.html" target="_blank" rel="noopener">代码随想录</a></li></ul><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=597240875&bvid=BV1QB4y1D7ep&cid=737799572&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen></iframe><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目要求了时间复杂度O(n)，那就不应该有排序过程</li><li>我们知道一个可能有负数的非递减顺序，最大绝对值一定在两端</li><li>所以用双指针收缩区间，每次对比两端的值就能拿到剩余的最大值，再从后往前的放置在新数组中即可</li></ol><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/0977.有序数组的平方.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><p>与我的思路一致</p><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>每次迭代只能往新数组里放一个，因为第二个端值可能不是最大的（可能比另一端的倒数第二个值小）</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortedSquares</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ans: <span class="built_in">number</span>[] = <span class="built_in">Array</span>(nums.length)</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">    right = nums.length - <span class="number">1</span>,</span><br><span class="line">    i = nums.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">const</span> dLeft = <span class="built_in">Math</span>.pow(nums[left], <span class="number">2</span>),</span><br><span class="line">      dRight = <span class="built_in">Math</span>.pow(nums[right], <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (dLeft &gt; dRight) &#123;</span><br><span class="line">      ans[i--] = dLeft</span><br><span class="line">      left++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ans[i--] = dRight</span><br><span class="line">      right--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-剑指Offer-58-II.左旋转字符串</title>
    <url>/archives/8a8.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/剑指Offer58-II.左旋转字符串.html" target="_blank" rel="noopener">代码随想录</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>便历一遍，前面部分动态填充到数组尾部</li><li>后面部分原地修改数组</li><li>截取长度</li></ol><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/剑指Offer58-II.左旋转字符串.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>学习到了<code>局部反转+整体反转</code>的解法</li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p>局部反转+整体反转</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseLeftWords</span>(<span class="params">s: <span class="built_in">string</span>, n: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = s.split(<span class="string">''</span>),</span><br><span class="line">    len = s.length</span><br><span class="line">  reverse(strArr, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">  reverse(strArr, n, len - <span class="number">1</span>)</span><br><span class="line">  reverse(strArr, <span class="number">0</span>, len - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> strArr.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 反转数组元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">strArr: <span class="built_in">string</span>[], start: <span class="built_in">number</span>, end: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    [strArr[start], strArr[end]] = [strArr[end], strArr[start]]</span><br><span class="line">    start++</span><br><span class="line">    end--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p></li><li><p>填充</p><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseLeftWords</span>(<span class="params">s: <span class="built_in">string</span>, n: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strArr = s.split(<span class="string">''</span>),</span><br><span class="line">    len = s.length</span><br><span class="line">  <span class="keyword">let</span> slow = <span class="number">0</span>,</span><br><span class="line">    fast = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (fast &lt; len + n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fast &lt; n) strArr.push(strArr[fast++])</span><br><span class="line">    <span class="keyword">else</span> strArr[slow++] = strArr[fast++]</span><br><span class="line">  &#125;</span><br><span class="line">  strArr.length = len</span><br><span class="line">  <span class="keyword">return</span> strArr.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p></li></ul><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>字符串反转有时候 局部反转、整体反转 能更巧妙的解决问题</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
        <tag>快慢指针</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器重置密码</title>
    <url>/archives/fe92.html</url>
    <content><![CDATA[<p>有时候会忘记服务器密码，但是可以通过官网面板等方式连上时，可使用下面的命令修改root密码：<br>整段赋值下面的命令（”新密码”处 替换为要修改的密码）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo root:新密码 |sudo chpasswd root</span><br><span class="line">sudo sed -i &apos;s/^.*PermitRootLogin.*/PermitRootLogin yes/g&apos; /etc/ssh/sshd_config;</span><br><span class="line">sudo sed -i &apos;s/^.*PasswordAuthentication.*/PasswordAuthentication yes/g&apos; /etc/ssh/sshd_config;</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>重启后用root账户登录即可。</p>]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Linux</tag>
        <tag>重置密码</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-剑指Offer-05.替换空格</title>
    <url>/archives/56e6.html</url>
    <content><![CDATA[<h2 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">题目</a>详解</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://programmercarl.com/剑指Offer05.替换空格.html" target="_blank" rel="noopener">代码随想录</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>遍历一遍字符串，然后拼接</li></ul><h3 id="看完代码随想录之后的想法"><a href="#看完代码随想录之后的想法" class="headerlink" title="看完代码随想录之后的想法"></a>看完<a href="https://programmercarl.com/剑指Offer05.替换空格.html" target="_blank" rel="noopener">代码随想录</a>之后的想法</h3><ul><li>可以数组填充法（预先给数组扩容带填充后的大小，然后在从后向前进行操作），原地修改<ul><li>注意要从后向前填充，因为原数组会被膨胀（从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动）</li><li>类似于<a href="/archives/64f.html">27.移除元素</a>，我们是从前向后覆盖原数组，因为原数组是在做删除操作会被收缩</li></ul></li></ul><h3 id="实现过程中遇到的困难"><a href="#实现过程中遇到的困难" class="headerlink" title="实现过程中遇到的困难"></a>实现过程中遇到的困难</h3><ul><li>注意要从后往前填充</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ts"><figcaption><span>TypeScript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceSpace</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = s.split(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">const</span> spaceNum = res.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> cur === <span class="string">' '</span> ? acc + <span class="number">1</span> : acc, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">let</span> left = s.length - <span class="number">1</span>,</span><br><span class="line">    right = left + spaceNum * <span class="number">2</span></span><br><span class="line">  <span class="keyword">while</span> (left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[left] === <span class="string">' '</span>) &#123;</span><br><span class="line">      res[right--] = <span class="string">'0'</span></span><br><span class="line">      res[right--] = <span class="string">'2'</span></span><br><span class="line">      res[right--] = <span class="string">'%'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res[right--] = res[left]</span><br><span class="line">    &#125;</span><br><span class="line">    left--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)（这种解法的空间复杂度已经最优了。由于js中字符串是一个基本数据类型，即不可变类型，只能先转为数组再处理，后续操作的算法思想是正确的。如果字符串在你使用的编程语言中是一种可变数据类型，这种算法的空间复杂度就是O(1)）</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>将字符串转化为数组便于操作</li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>代码随想录</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>React 设计思想</title>
    <url>/archives/7615.html</url>
    <content><![CDATA[<h1 id="React-设计思想"><a href="#React-设计思想" class="headerlink" title="React 设计思想"></a>React 设计思想</h1><blockquote><p>译者序：本文是 React 核心开发者、有 React API 终结者之称的 Sebastian Markbåge 撰写，阐述了他设计 React 的初衷。阅读此文，你能站在更高的高度思考 React 的过去、现在和未来。原文地址：<a href="https://github.com/reactjs/react-basic" target="_blank" rel="noopener">https://github.com/reactjs/react-basic</a></p></blockquote><a id="more"></a><p>我写此文是想正式地阐述我心中 React 的<a href="http://baike.baidu.com/view/2333986.htm" target="_blank" rel="noopener">心智模型</a>。目的是解释为什么我们会这样设计 React，同时你也可以根据这些论点反推出 React。</p><p>不可否认，此文中的部分论据或前提尚存争议，而且部分示例的设计可能存在 bug 或疏忽。这只是正式确定它的最初阶段。如果你有更好的完善它的想法可以随时提交 pull request。本文不会介绍框架细节中的奇技淫巧，相信这样能提纲挈领，让你看清 React 由简单到复杂的设计过程。</p><p>React.js 的真实实现中充满了具体问题的解决方案，渐进式的解法，算法优化，历史遗留代码，debug 工具以及其他一些可以让它真的具有高可用性的内容。这些代码可能并不稳定，因为未来浏览器的变化和功能权重的变化随时面临改变。所以具体的代码很难彻底解释清楚。</p><p>我偏向于选择一种我能完全 hold 住的简洁的心智模型来作介绍。</p><h2 id="变换（Transformation）"><a href="#变换（Transformation）" class="headerlink" title="变换（Transformation）"></a>变换（Transformation）</h2><p>设计 React 的核心前提是认为 UI 只是把数据通过映射关系变换成另一种形式的数据。同样的输入必会有同样的输出。这恰好就是纯函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NameBox</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">fontWeight</span>: <span class="string">'bold'</span>, <span class="attr">labelContent</span>: name &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;Sebastian Markbåge&apos; -&gt;</span><br><span class="line">&#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125;;</span><br></pre></td></tr></table></figure><h2 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h2><p>你不可能仅用一个函数就能实现复杂的 UI。重要的是，你需要把 UI 抽象成多个隐藏内部细节，又可复用的函数。通过在一个函数中调用另一个函数来实现复杂的 UI，这就是抽象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyUserBox</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    borderStyle: <span class="string">'1px solid blue'</span>,</span><br><span class="line">    childContent: [</span><br><span class="line">      <span class="string">'Name: '</span>,</span><br><span class="line">      NameBox(user.firstName + <span class="string">' '</span> + user.lastName)</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; firstName: &apos;Sebastian&apos;, lastName: &apos;Markbåge&apos; &#125; -&gt;</span><br><span class="line">&#123;</span><br><span class="line">  borderStyle: &apos;1px solid blue&apos;,</span><br><span class="line">  childContent: [</span><br><span class="line">    &apos;Name: &apos;,</span><br><span class="line">    &#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h2><p>为了真正达到重用的特性，只重用叶子然后每次都为他们创建一个新的容器是不够的。你还需要可以包含其他抽象的容器再次进行组合。我理解的“组合”就是将两个或者多个不同的抽象合并为一个。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBox</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    borderStyle: <span class="string">'1px solid blue'</span>,</span><br><span class="line">    children: children</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserBox</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox([</span><br><span class="line">    <span class="string">'Name: '</span>,</span><br><span class="line">    NameBox(user.firstName + <span class="string">' '</span> + user.lastName)</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h2><p>UI 不单单是对服务器端或业务逻辑状态的复制。实际上还有很多状态是针对具体的渲染目标。举个例子，在一个 text field 中打字。它不一定要复制到其他页面或者你的手机设备。滚动位置这个状态是一个典型的你几乎不会复制到多个渲染目标的。</p><p>我们倾向于使用不可变的数据模型。我们把可以改变 state 的函数串联起来作为原点放置在顶层。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyNameBox</span>(<span class="params">user, likes, onClick</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox([</span><br><span class="line">    <span class="string">'Name: '</span>, NameBox(user.firstName + <span class="string">' '</span> + user.lastName),</span><br><span class="line">    <span class="string">'Likes: '</span>, LikeBox(likes),</span><br><span class="line">    LikeButton(onClick)</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现细节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> likes = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOneMoreLike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  likes++;</span><br><span class="line">  rerender();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">FancyNameBox(</span><br><span class="line">  &#123; <span class="attr">firstName</span>: <span class="string">'Sebastian'</span>, <span class="attr">lastName</span>: <span class="string">'Markbåge'</span> &#125;,</span><br><span class="line">  likes,</span><br><span class="line">  addOneMoreLike</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><em>注意：本例更新状态时会带来副作用（addOneMoreLike 函数中）。我实际的想法是当一个“update”传入时我们返回下一个版本的状态，但那样会比较复杂。此示例待更新</em></p><h2 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h2><p>对于纯函数，使用相同的参数一次次调用未免太浪费资源。我们可以创建一个函数的 memorized 版本，用来追踪最后一个参数和结果。这样如果我们继续使用同样的值，就不需要反复执行它了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cachedArg;</span><br><span class="line">  <span class="keyword">var</span> cachedResult;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cachedArg === arg) &#123;</span><br><span class="line">      <span class="keyword">return</span> cachedResult;</span><br><span class="line">    &#125;</span><br><span class="line">    cachedArg = arg;</span><br><span class="line">    cachedResult = fn(arg);</span><br><span class="line">    <span class="keyword">return</span> cachedResult;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MemoizedNameBox = memoize(NameBox);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NameAndAgeBox</span>(<span class="params">user, currentTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox([</span><br><span class="line">    <span class="string">'Name: '</span>,</span><br><span class="line">    MemoizedNameBox(user.firstName + <span class="string">' '</span> + user.lastName),</span><br><span class="line">    <span class="string">'Age in milliseconds: '</span>,</span><br><span class="line">    currentTime - user.dateOfBirth</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h2><p>大部分 UI 都是展示列表数据中不同 item 的列表结构。这是一个天然的层级。</p><p>为了管理列表中的每一个 item 的 state ，我们可以创造一个 Map 容纳具体 item 的 state。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserList</span>(<span class="params">users, likesPerUser, updateUserLikes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> users.map(<span class="function"><span class="params">user</span> =&gt;</span> FancyNameBox(</span><br><span class="line">    user,</span><br><span class="line">    likesPerUser.get(user.id),</span><br><span class="line">    () =&gt; updateUserLikes(user.id, likesPerUser.get(user.id) + <span class="number">1</span>)</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> likesPerUser = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateUserLikes</span>(<span class="params">id, likeCount</span>) </span>&#123;</span><br><span class="line">  likesPerUser.set(id, likeCount);</span><br><span class="line">  rerender();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserList(data.users, likesPerUser, updateUserLikes);</span><br></pre></td></tr></table></figure><p><em>注意：现在我们向 FancyNameBox 传了多个不同的参数。这打破了我们的 memoization 因为我们每次只能存储一个值。更多相关内容在下面。</em></p><h2 id="连续性（Continuations）"><a href="#连续性（Continuations）" class="headerlink" title="连续性（Continuations）"></a>连续性（Continuations）</h2><p>不幸的是，自从 UI 中有太多的列表，明确的管理就需要大量的重复性样板代码。</p><p>我们可以通过推迟一些函数的执行，进而把一些模板移出业务逻辑。比如，使用“柯里化”（JavaScript 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener"><code>bind</code></a>）。然后我们可以从核心的函数外面传递 state，这样就没有样板代码了。</p><p>下面这样并没有减少样板代码，但至少把它从关键业务逻辑中剥离。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyUserList</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox(</span><br><span class="line">    UserList.bind(<span class="literal">null</span>, users)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> box = FancyUserList(data.users);</span><br><span class="line"><span class="keyword">const</span> resolvedChildren = box.children(likesPerUser, updateUserLikes);</span><br><span class="line"><span class="keyword">const</span> resolvedBox = &#123;</span><br><span class="line">  ...box,</span><br><span class="line">  children: resolvedChildren</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="State-Map"><a href="#State-Map" class="headerlink" title="State Map"></a>State Map</h2><p>之前我们知道可以使用组合避免重复执行相同的东西这样一种重复模式。我们可以把执行和传递 state 逻辑挪动到被复用很多的低层级的函数中去。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBoxWithState</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  stateMap,</span></span></span><br><span class="line"><span class="function"><span class="params">  updateState</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox(</span><br><span class="line">    children.map(<span class="function"><span class="params">child</span> =&gt;</span> child.continuation(</span><br><span class="line">      stateMap.get(child.key),</span><br><span class="line">      updateState</span><br><span class="line">    ))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserList</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> users.map(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">    continuation: FancyNameBox.bind(<span class="literal">null</span>, user),</span><br><span class="line">    key: user.id</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyUserList</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBoxWithState.bind(<span class="literal">null</span>,</span><br><span class="line">    UserList(users)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> continuation = FancyUserList(data.users);</span><br><span class="line">continuation(likesPerUser, updateUserLikes);</span><br></pre></td></tr></table></figure><h2 id="Memoization-Map"><a href="#Memoization-Map" class="headerlink" title="Memoization Map"></a>Memoization Map</h2><p>一旦我们想在一个 memoization 列表中 memoize 多个 item 就会变得很困难。因为你需要制定复杂的缓存算法来平衡调用频率和内存占有率。</p><p>还好 UI 在同一个位置会相对的稳定。相同的位置一般每次都会接受相同的参数。这样以来，使用一个集合来做 memoization 是一个非常好用的策略。</p><p>我们可以用对待 state 同样的方式，在组合的函数中传递一个 memoization 缓存。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg, memoizationCache</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memoizationCache.arg === arg) &#123;</span><br><span class="line">      <span class="keyword">return</span> memoizationCache.result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = fn(arg);</span><br><span class="line">    memoizationCache.arg = arg;</span><br><span class="line">    memoizationCache.result = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBoxWithState</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  stateMap,</span></span></span><br><span class="line"><span class="function"><span class="params">  updateState,</span></span></span><br><span class="line"><span class="function"><span class="params">  memoizationCache</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FancyBox(</span><br><span class="line">    children.map(<span class="function"><span class="params">child</span> =&gt;</span> child.continuation(</span><br><span class="line">      stateMap.get(child.key),</span><br><span class="line">      updateState,</span><br><span class="line">      memoizationCache.get(child.key)</span><br><span class="line">    ))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MemoizedFancyNameBox = memoize(FancyNameBox);</span><br></pre></td></tr></table></figure><h2 id="代数效应（Algebraic-Effects）"><a href="#代数效应（Algebraic-Effects）" class="headerlink" title="代数效应（Algebraic Effects）"></a>代数效应（Algebraic Effects）</h2><p>多层抽象需要共享琐碎数据时，一层层传递数据非常麻烦。如果能有一种方式可以在多层抽象中快捷地传递数据，同时又不需要牵涉到中间层级，那该有多好。React 中我们把它叫做“context”。</p><p>有时候数据依赖并不是严格按照抽象树自上而下进行。举个例子，在布局算法中，你需要在实现他们的位置之前了解子节点的大小。</p><p>现在，这个例子有一点超纲。我会使用 <a href="http://math.andrej.com/eff/" target="_blank" rel="noopener">代数效应</a> 这个由我发起的 <a href="https://esdiscuss.org/topic/one-shot-delimited-continuations-with-effect-handlers" target="_blank" rel="noopener">ECMAScript 新特性提议</a>。如果你对函数式编程很熟悉，它们 在避免由 monad 强制引入的仪式一样的编码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeBorderColorRequest</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBox</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> color = raise <span class="keyword">new</span> ThemeBorderColorRequest();</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    borderWidth: <span class="string">'1px'</span>,</span><br><span class="line">    borderColor: color,</span><br><span class="line">    children: children</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlueTheme</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">    children();</span><br><span class="line">  &#125; <span class="keyword">catch</span> effect ThemeBorderColorRequest -&gt; [, continuation] &#123;</span><br><span class="line">    continuation(<span class="string">'blue'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BlueTheme(</span><br><span class="line">    FancyUserList.bind(<span class="literal">null</span>, data.users)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React 技术栈</title>
    <url>/archives/4a9b.html</url>
    <content><![CDATA[<h1 id="React-技术栈"><a href="#React-技术栈" class="headerlink" title="React 技术栈"></a>React 技术栈</h1><p>React 是目前最热门的前端框架。</p><ul><li>Facebook 公司2013年推出</li><li>现在最好的社区支持和生态圈</li><li>大量的第三方工具</li></ul><p><img src="./images/react-logo.png" alt></p><hr><h2 id="React-的优点"><a href="#React-的优点" class="headerlink" title="React 的优点"></a>React 的优点</h2><ul><li>组件模式：代码复用和团队分工</li><li>虚拟 DOM：性能优势</li><li>移动端支持：跨终端</li></ul><hr><h2 id="React-的缺点"><a href="#React-的缺点" class="headerlink" title="React 的缺点"></a>React 的缺点</h2><ul><li>学习曲线较陡峭</li><li>全新的一套概念，与其他所有框架截然不同</li><li>只有采用它的整个技术栈，才能发挥最大威力</li></ul><p>总结：React 非常先进和强大，但是学习和实现成本都不低</p><hr><h2 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h2><p>React 使用 JSX 语法，JavaScript 代码中可以写 HTML 代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myTitle = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><hr><h2 id="JSX-语法解释"><a href="#JSX-语法解释" class="headerlink" title="JSX 语法解释"></a>JSX 语法解释</h2><p>（1）JSX 语法的最外层，只能有一个节点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">let</span> myTitle = &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;;</span><br></pre></td></tr></table></figure><p>（2）JSX 语法中可以插入 JavaScript 代码，使用大括号。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myTitle = &lt;p&gt;&#123;'Hello ' + 'World'&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="Babel-转码器"><a href="#Babel-转码器" class="headerlink" title="Babel 转码器"></a>Babel 转码器</h2><p>JavaScript 引擎（包括浏览器和 Node）都不认识 JSX，需要首先使用 Babel 转码，然后才能运行。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"react.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"react-dom.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"babel.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// ** Our code goes here! **</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React 需要加载两个库：React 和 React-DOM，前者是 React 的核心库，后者是 React 的 DOM 适配库。</p><p>Babel 用来在浏览器转换 JSX 语法，如果服务器已经转好了，浏览器就不需要加载这个库。</p><hr><h2 id="课堂练习：JSX-语法"><a href="#课堂练习：JSX-语法" class="headerlink" title="课堂练习：JSX 语法"></a>课堂练习：JSX 语法</h2><p>浏览器打开<code>demos/jsx-demo/index.html</code>，按照<a href="../demos/README.md#jsx">《操作说明》</a>，完成练习。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;span&gt;Hello World!&lt;<span class="regexp">/span&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('example')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><hr><h2 id="示例：React-组件"><a href="#示例：React-组件" class="headerlink" title="示例：React 组件"></a>示例：React 组件</h2><p>React 允许用户定义自己的组件，插入网页。</p><p>浏览器打开<code>demos/react-component-demo/index1.html</code>，按照<a href="../demos/README.md#react-组件语法">《操作说明》</a>，仔细查看源码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTitle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MyTitle/&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h2 id="课堂练习：组件的参数"><a href="#课堂练习：组件的参数" class="headerlink" title="课堂练习：组件的参数"></a>课堂练习：组件的参数</h2><p>组件可以从外部传入参数，内部使用<code>this.props</code>获取参数。</p><p>打开<code>demos/react-component-demo/index2.html</code>，按照<a href="../demos/README.md#react-组件的参数">《操作说明》</a>，完成练习。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTitle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span></span></span></span><br><span class="line"><span class="xml">      style=&#123;&#123;color: this.props.color&#125;&#125;</span></span><br><span class="line"><span class="xml">    &gt;Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;MyTitle color=<span class="string">"red"</span> /&gt;,</span><br></pre></td></tr></table></figure><hr><h2 id="示例：组件的状态"><a href="#示例：组件的状态" class="headerlink" title="示例：组件的状态"></a>示例：组件的状态</h2><p>组件往往会有内部状态，使用<code>this.state</code>表示。</p><p>浏览器打开<code>demos/react-component-demo/index3.html</code>，按照<a href="../demos/README.md#react-组件的状态">《操作说明》</a>，仔细查看源码。</p><p><img src="./images/react-component-state.png" alt></p><hr><h2 id="课堂练习：React-组件实战"><a href="#课堂练习：React-组件实战" class="headerlink" title="课堂练习：React 组件实战"></a>课堂练习：React 组件实战</h2><p>浏览器打开<code>demos/react-component-demo/index4.html</code>，按照<a href="../demos/README.md#react-组件实战">《操作说明》</a>，完成练习。</p><hr><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>React 为组件的不同生命阶段，提供了近十个钩子方法。</p><ul><li><code>componentWillMount()</code>：组件加载前调用</li><li><code>componentDidMount()</code>：组件加载后调用</li><li><code>componentWillUpdate()</code>: 组件更新前调用</li><li><code>componentDidUpdate()</code>: 组件更新后调用</li><li><code>componentWillUnmount()</code>：组件卸载前调用</li><li><code>componentWillReceiveProps()</code>：组件接受新的参数时调用</li></ul><p>我们可以利用这些钩子，自动完成一些操作。</p><hr><h2 id="课堂练习：组件的生命周期"><a href="#课堂练习：组件的生命周期" class="headerlink" title="课堂练习：组件的生命周期"></a>课堂练习：组件的生命周期</h2><p>组件可以通过 Ajax 请求，从服务器获取数据。Ajax 请求一般在<code>componentDidMount</code>方法里面发出。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">'...'</span>;</span><br><span class="line">  $.getJSON(url)</span><br><span class="line">    .done()</span><br><span class="line">    .fail();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开<code>demos/react-lifecycle-demo/index.html</code>，按照<a href="../demos/README.md#react-组件的生命周期">《操作说明》</a>，完成练习。</p><hr><h2 id="React-组件库"><a href="#React-组件库" class="headerlink" title="React 组件库"></a>React 组件库</h2><p>React 的一大优势，就是网上有很多已经写好的组件库，可以使用。</p><p>React-Bootstrap：<a href="https://react-bootstrap.github.io/" target="_blank" rel="noopener">https://react-bootstrap.github.io/</a></p><p><img src="./images/react-bootstrap.png" alt></p><hr><h2 id="示例：ReCharts"><a href="#示例：ReCharts" class="headerlink" title="示例：ReCharts"></a>示例：ReCharts</h2><p>ReCharts 是一个 React 图表组件库。<a href="http://recharts.org/" target="_blank" rel="noopener">http://recharts.org/</a></p><p>浏览器打开<code>demos/recharts-demo/index.html</code>，按照<a href="../demos/README.md#recharts">《操作说明》</a>，仔细查看源码，体会 JSX 语法对表达复杂组件的优势。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LineChart</span> <span class="attr">width</span>=<span class="string">&#123;1000&#125;</span> <span class="attr">height</span>=<span class="string">&#123;400&#125;</span> <span class="attr">data</span>=<span class="string">&#123;data&#125;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">XAxis</span> <span class="attr">dataKey</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">YAxis</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CartesianGrid</span> <span class="attr">stroke</span>=<span class="string">"#eee"</span> <span class="attr">strokeDasharray</span>=<span class="string">"5 5"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Line</span> <span class="attr">type</span>=<span class="string">"monotone"</span> <span class="attr">dataKey</span>=<span class="string">"uv"</span> <span class="attr">stroke</span>=<span class="string">"#8884d8"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Line</span> <span class="attr">type</span>=<span class="string">"monotone"</span> <span class="attr">dataKey</span>=<span class="string">"pv"</span> <span class="attr">stroke</span>=<span class="string">"#82ca9d"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LineChart</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="React-的核心思想"><a href="#React-的核心思想" class="headerlink" title="React 的核心思想"></a>React 的核心思想</h2><p>View 是 State 的输出。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">view = f(state)</span><br></pre></td></tr></table></figure><p>上式中，<code>f</code>表示函数关系。只要 State 发生变化，View 也要随之变化。</p><hr><p>React 的本质是将图形界面（GUI）函数化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"michel"</span>,</span><br><span class="line">  age: <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">&#123; person &#125;</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123; person.name &#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">person</span>=<span class="string">&#123;person&#125;</span> /&gt;</span></span>, <span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure><hr><h2 id="React-没有解决的问题"><a href="#React-没有解决的问题" class="headerlink" title="React 没有解决的问题"></a>React 没有解决的问题</h2><p>React 本身只是一个 DOM 的抽象层，使用组件构建虚拟 DOM。</p><p>如果开发大应用，还需要解决两个问题。</p><ul><li>架构：大型应用程序应该如何组织代码？</li><li>通信：组件之间如何通信？</li></ul><hr><h2 id="架构问题"><a href="#架构问题" class="headerlink" title="架构问题"></a>架构问题</h2><p>React 只是视图层的解决方案，可以用于任何一种架构。</p><ul><li>MVC</li><li>MVVM</li><li>Observer</li><li>Reactive</li><li>…</li></ul><p>到底哪一种架构最合适 React ？</p><hr><h2 id="通信问题"><a href="#通信问题" class="headerlink" title="通信问题"></a>通信问题</h2><p>组件会发生三种通信。</p><ul><li>向子组件发消息</li><li>向父组件发消息</li><li>向其他组件发消息</li></ul><p>React 只提供了一种通信手段：传参。对于大应用，很不方便。</p><hr><h2 id="状态的同步"><a href="#状态的同步" class="headerlink" title="状态的同步"></a>状态的同步</h2><p>通信的本质是状态的同步。</p><p>React 同步状态的基本方法：找到通信双方最近的共同父组件，通过它的<code>state</code>，使得子组件的状态保持同步。</p><hr><h2 id="Flux-架构"><a href="#Flux-架构" class="headerlink" title="Flux 架构"></a>Flux 架构</h2><p>Facebook 提出 Flux 架构的概念，被认为是 React 应用的标准架构。</p><p><img src="./images/flow.png" alt></p><p>最大特点：数据单向流动。与 MVVM 的数据双向绑定，形成鲜明对比。</p><hr><h2 id="Flux-的核心思想"><a href="#Flux-的核心思想" class="headerlink" title="Flux 的核心思想"></a>Flux 的核心思想</h2><ul><li>不同组件的<code>state</code>，存放在一个外部的、公共的 Store 上面。</li><li>组件订阅 Store 的不同部分。</li><li>组件发送（dispatch）动作（action），引发 Store 的更新。</li></ul><p>Flux 只是一个概念，有30多种实现。</p><hr><h2 id="目前最流行的两个-React-架构"><a href="#目前最流行的两个-React-架构" class="headerlink" title="目前最流行的两个 React 架构"></a>目前最流行的两个 React 架构</h2><p>React 架构的最重要作用：管理 Store 与 View 之间的关系。</p><ul><li>MobX：响应式（Reactive）管理，state 是可变对象，适合中小型项目</li><li>Redux：函数式（Functional）管理，state 是不可变对象，适合大型项目</li></ul><hr><h2 id="MobX-架构"><a href="#MobX-架构" class="headerlink" title="MobX 架构"></a>MobX 架构</h2><p>MobX 的核心是观察者模式。</p><ul><li>Store 是被观察者（observable）</li><li>组件是观察者（observer）</li></ul><p>一旦<code>Store</code>有变化，会立刻被组件观察到，从而引发重新渲染。</p><hr><h2 id="MobX-的最简单例子"><a href="#MobX-的最简单例子" class="headerlink" title="MobX 的最简单例子"></a>MobX 的最简单例子</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;observable&#125; = mobx;</span><br><span class="line"><span class="keyword">const</span> &#123;observer&#125; = mobxReact;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = observable(&#123;<span class="attr">name</span>: <span class="string">"张三"</span>, <span class="attr">age</span>: <span class="number">31</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = observer(</span><br><span class="line">  (&#123; person &#125;) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123; person.name &#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">person</span>=<span class="string">&#123;person&#125;</span> /&gt;</span></span>, <span class="built_in">document</span>.body);</span><br><span class="line">person.name = <span class="string">"李四"</span>;</span><br></pre></td></tr></table></figure><p>代码：<code>demos/mobx-demo/browser-demo</code>目录</p><hr><h2 id="示例：MobX"><a href="#示例：MobX" class="headerlink" title="示例：MobX"></a>示例：MobX</h2><p>进入<code>demos/mobx-demo</code>目录，按照<a href="../demos/README.md#mobx">《操作说明》</a>，理解 MobX 框架。</p><hr><p>UI 层是观察者，Store 是被观察者。</p><p>Store 所有的属性，分成两大类：直接被观察的属性和自动计算出来的属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  @observable name = <span class="string">'Bartek'</span>;</span><br><span class="line">  @computed <span class="keyword">get</span> decorated() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is awesome!`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UI 会观察到 Store 的变化，自动重新渲染。</p><hr><h2 id="Redux-架构"><a href="#Redux-架构" class="headerlink" title="Redux 架构"></a>Redux 架构</h2><p>Redux 的核心概念</p><ul><li>所有的状态存放在<code>Store</code>。组件每次重新渲染，都必须由状态变化引起。</li><li>用户在 UI 上发出<code>action</code>。</li><li><code>reducer</code>函数接收<code>action</code>，然后根据当前的<code>state</code>，计算出新的<code>state</code>。</li></ul><p><img src="./images/redux-architecture.png" alt></p><hr><h2 id="Redux-应用的架构"><a href="#Redux-应用的架构" class="headerlink" title="Redux 应用的架构"></a>Redux 应用的架构</h2><p><img src="./images/architecture-redux.png" alt></p><p>Redux 层保存所有状态，React 组件拿到状态以后，渲染出 HTML 代码。</p><hr><h2 id="示例：Redux"><a href="#示例：Redux" class="headerlink" title="示例：Redux"></a>示例：Redux</h2><p>进入<code>demos/redux-demo</code>目录，按照<a href="../demos/README.md#redux">《操作说明》</a>，理解 Redux 框架。</p><hr><ul><li>Redux 将组件分成 UI 组件和容器组件两类。</li><li>UI 组件是纯组件，不包含 state 和生命周期方法，不涉及组件的行为，只涉及组件的外观。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div className=<span class="string">"index"</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;<span class="keyword">this</span>.props.text&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input</span></span><br><span class="line"><span class="regexp">    defaultValue=&#123;this.props.name&#125;</span></span><br><span class="line"><span class="regexp">    onChange=&#123;this.props.onChange&#125;</span></span><br><span class="line"><span class="regexp">  /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><hr><p>容器组件正好相反。</p><ul><li>不涉及组件的外观，只涉及组件的行为。</li><li>负责订阅 Store，将 Store 的数据处理以后，再通过参数传给 UI 组件。</li><li>用户给出配置以后，由 Redux 生成。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// MyComponent 是纯的 UI 组件</span><br><span class="line">const App = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(MyComponent);</span><br></pre></td></tr></table></figure><ul><li>mapStateToProps: 定义 UI 组件参数与 State 之间的映射</li><li>mapDispatchToProps：定义 UI 组件与 Action 之间的映射</li></ul><hr><h2 id="拆分-UI-组件和容器组件的好处"><a href="#拆分-UI-组件和容器组件的好处" class="headerlink" title="拆分 UI 组件和容器组件的好处"></a>拆分 UI 组件和容器组件的好处</h2><ul><li>UI 组件与后台数据无关，可以由设计师负责</li><li>容器组件只负责数据和行为，一旦 Store 的数据结构变化，只要调整容器组件即可</li><li>表现层和功能层脱钩，有利于代码重用，也有利于看清应用的数据结构和业务逻辑</li></ul><hr><h2 id="Reducer-函数"><a href="#Reducer-函数" class="headerlink" title="Reducer 函数"></a>Reducer 函数</h2><p><code>reducer</code>是一个纯函数，用来接收<code>action</code>，算出新的<code>state</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  text: <span class="string">'你好，访问者'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  name: <span class="string">'访问者'</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'change'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        name: action.payload,</span><br><span class="line">        text: <span class="string">'你好，'</span> + action.payload</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><code>Store</code>由 Redux 提供的<code>createStore</code>方法生成，该方法接受<code>reducer</code>作为参数。</li><li>为了把<code>Store</code>传入组件，必须使用 Redux 提供的<code>Provider</code>组件在应用的最外面，包裹一层。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.body.appendChild(document.createElement('div'))</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React中的state和props</title>
    <url>/archives/992.html</url>
    <content><![CDATA[<p>整理一下React中关于state和props的知识点。</p><hr><p>在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在<code>props</code>和<code>state</code>中，这两个属性有啥子区别呢？</p><a id="more"></a><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>React的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。</p><p>组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是<code>props</code>，所以可以把<code>props</code>理解为从外部传入组件内部的数据。由于React是单向数据流，所以<code>props</code>基本上也就是从服父级组件向子组件传递的数据。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：<code>&lt;ItemList/&gt;</code>和<code>&lt;Item/&gt;</code>。</p><p>先看看<code>&lt;ItemList/&gt;</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Item from &quot;./item&quot;;</span><br><span class="line">export default class ItemList extends React.Component&#123;</span><br><span class="line">  const itemList = data.map(item =&gt; &lt;Item item=item /&gt;);</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &#123;itemList&#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>列表的数据我们就暂时先假设是放在一个<code>data</code>变量中，然后通过<code>map</code>函数返回一个每一项都是<code>&lt;Item item=&#39;数据&#39;/&gt;</code>的数组，也就是说这里其实包含了<code>data.length</code>个<code>&lt;Item/&gt;</code>组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。</p><p>在<code>&lt;Item /&gt;</code>中是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class Item extends React.Component&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;li&gt;&#123;this.props.item&#125;&lt;/li&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>render</code>函数中可以看出，组件内部是使用<code>this.props</code>来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个<code>item</code>属性，所以通过<code>this.props.item</code>来获取即可。</p><h3 id="只读性"><a href="#只读性" class="headerlink" title="只读性"></a>只读性</h3><p><code>props</code>经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的<code>props</code>是只读的，不可改变的。如果<code>props</code>在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的<code>props</code>传入组件中。</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>在组件中，我们最好为<code>props</code>中的参数设置一个<code>defaultProps</code>，并且制定它的类型。比如，这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Item.defaultProps = &#123;</span><br><span class="line">  item: &apos;Hello Props&apos;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Item.propTypes = &#123;</span><br><span class="line">  item: PropTypes.string,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于<code>propTypes</code>，可以声明为以下几种类型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optionalArray: PropTypes.array,</span><br><span class="line">optionalBool: PropTypes.bool,</span><br><span class="line">optionalFunc: PropTypes.func,</span><br><span class="line">optionalNumber: PropTypes.number,</span><br><span class="line">optionalObject: PropTypes.object,</span><br><span class="line">optionalString: PropTypes.string,</span><br><span class="line">optionalSymbol: PropTypes.symbol,</span><br></pre></td></tr></table></figure><p>注意，<code>bool</code>和<code>func</code>是简写。</p><p>这些知识基础数据类型，还有一些复杂的，附上链接：</p><p><a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">https://facebook.github.io/react/docs/typechecking-with-proptypes.html</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>props</code>是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的<code>props</code>来重新渲染子组件，否则子组件的<code>props</code>以及展现形式不会改变。</p><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p><code>state</code>是什么呢？</p><blockquote><p>State is similar to props, but it is private and fully controlled by the component.</p></blockquote><p>一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是<code>props</code>，而数据状态就是<code>state</code>。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class ItemList extends React.Component&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      itemList:&apos;一些数据&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &#123;this.state.itemList&#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，在组件初始化的时候，通过<code>this.state</code>给组件设定一个初始的<code>state</code>，在第一次<code>render</code>的时候就会用这个数据来渲染组件。</p><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p><code>state</code>不同于<code>props</code>的一点是，<code>state</code>是可以被改变的。不过，不可以直接通过<code>this.state=</code>的方式来修改，而需要通过<code>this.setState()</code>方法来修改<code>state</code>。</p><p>比如，我们经常会通过异步操作来获取数据，我们需要在<code>didMount</code>阶段来执行异步操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">  fetch(&apos;url&apos;)</span><br><span class="line">    .then(response =&gt; response.json())</span><br><span class="line">    .then((data) =&gt; &#123;</span><br><span class="line">      this.setState(&#123;itemList:item&#125;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数据获取完成后，通过<code>this.setState</code>来修改数据状态。</p><p>当我们调用<code>this.setState</code>方法时，React会更新组件的数据状态<code>state</code>，并且重新调用<code>render</code>方法，也就是会对组件进行重新渲染。</p><p><strong>注意：通过<code>this.state=</code>来初始化<code>state</code>，使用<code>this.setState</code>来修改<code>state</code>，<code>constructor</code>是唯一能够初始化的地方。</strong></p><p><code>setState</code>接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class ItemList extends React.Component&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name:&apos;axuebin&apos;,</span><br><span class="line">      age:25,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    this.setState(&#123;age:18&#125;)  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行完<code>setState</code>之后的<code>state</code>应该是<code>{name:&#39;axuebin&#39;,age:18}</code>。</p><p><code>setState</code>还可以接受第二个参数，它是一个函数，会在<code>setState</code>调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">  name:&apos;xb&apos;</span><br><span class="line">&#125;,()=&gt;console.log(&apos;setState finished&apos;))</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>state</code>的主要作用是用于组件保存、控制以及修改自己的状态，它只能在<code>constructor</code>中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的<code>this.setState</code>来修改，修改<code>state</code>属性会导致组件的重新渲染。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li><code>state</code>是组件自己管理数据，控制自己的状态，可变；</li><li><code>props</code>是外部传入的数据参数，不可变；</li><li>没有<code>state</code>的叫做无状态组件，有<code>state</code>的叫做有状态组件；</li><li>多用<code>props</code>，少用<code>state</code>。也就是多写无状态组件。</li></ol>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>What are React Hooks</title>
    <url>/archives/ef81.html</url>
    <content><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.robinwieruch.de/react-hooks/" target="_blank" rel="noopener">https://www.robinwieruch.de/react-hooks/</a></p></blockquote><p>October 29, 2018 - <a href="https://github.com/rwieruch/blog_robinwieruch_content/blob/master/react-hooks.md" target="_blank" rel="noopener">Edit this Post on GitHub</a></p><p><img src="https://www.robinwieruch.de/img/posts/react-hooks/banner_1024.jpg" alt></p><p>React Hooks were introduced at <a href="https://www.youtube.com/watch?v=dpw9EHDh2bM" target="_blank" rel="noopener">React Conf October 2018</a> as a way to use state and side-effects in React function components. Whereas function components have been called functional stateless components (FSC) before, they are finally able to use state with React Hooks. Therefore, many people refer to them as function components now.</p><p>In this walkthrough, I want to explain the motivation behind hooks, what will change in React and why we shouldn’t panic, and how React hooks can be used in function components by showcasing common React Hooks such as the state and effect hooks by example.</p><p>React Hooks were invented by the React team to introduce state management and side-effects in function components. It’s their way of making it more effortless to use only React function components without the need to refactor a React function component to a React class component for using lifecycle methods, in order to use have side-effects, or local state. React Hooks enable us to write React applications with only function components.</p><p><strong>Unnecessary Component Refactorings:</strong> Previously, only React class components were used for local state management and lifecycle methods. The latter have been essential for introducing side-effects, such as listeners or data fetching, in React class components.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;() =&gt;</span><br><span class="line">            this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &gt;</span><br><span class="line">          Click me</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Counter;</span><br></pre></td></tr></table></figure><p>Only if you didn’t need state or lifecycle methods, React functional <em>stateless</em> components could be used. And because React function components are more lightweight (and elegant), people already used plenty of function components. This came with the drawback of refactoring components from React function components to React class components every time state or lifecycle methods were needed (and vice versa).</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">// how to use the state hook in a React function component</span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Counter;</span><br></pre></td></tr></table></figure><p>With Hooks there is no need for this refactoring. Side-effects and state are finally available in React function components. That’s why a rebranding from functional stateless components to function components would be reasonable.</p><p><strong>Side-effect Logic:</strong> In React class components, side-effects were mostly introduced in lifecycle methods (e.g. componentDidMount, componentDidUpdate, componentWillUnmount). A side-effect could be <a href="https://www.robinwieruch.de/react-fetching-data/" target="_blank" rel="noopener">fetching data in React</a> or <a href="https://www.robinwieruch.de/react-intersection-observer-api/" target="_blank" rel="noopener">interacting with the Browser API</a>. Usually these side-effects came with a setup and clean up phase. For instance, if you would miss to remove your listener, you could run into <a href="https://www.robinwieruch.de/react-warning-cant-call-setstate-on-an-unmounted-component/" target="_blank" rel="noopener">React performance issues</a>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// side-effects in a React class component</span><br><span class="line">class MyComponent extends Component &#123;</span><br><span class="line">  // setup phase</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    // add listener for feature 1</span><br><span class="line">    // add listener for feature 2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // clean up phase</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    // remove listener for feature 1</span><br><span class="line">    // remove listener for feature 2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// side-effects in React function component with React Hooks</span><br><span class="line">function MyComponent() &#123;</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // add listener for feature 1 (setup)</span><br><span class="line">    // return function to remove listener for feature 1 (clean up)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // add listener for feature 2 (setup)</span><br><span class="line">    // return function to remove listener for feature 2 (clean up)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, if you would introduce more than one of these side-effects in a React class component’s lifecycle methods, all side-effects would be grouped by lifecycle method but not by side-effect. That’s what React Hooks are going to change by encapsulating a side-effect in one hook whereas every hook has its own side-effect with a setup and clean up phase. You will see later in a tutorial how this works for real by adding and removing listeners in a React Hook.</p><p><strong>React’s Abstraction Hell:</strong> Abstraction and thus reusability were introduced with <a href="https://www.robinwieruch.de/gentle-introduction-higher-order-components/" target="_blank" rel="noopener">Higher-Order Components</a> and <a href="https://www.robinwieruch.de/react-render-props-pattern/" target="_blank" rel="noopener">Render Prop Components</a> in React. There is also <a href="https://www.robinwieruch.de/react-context-api/" target="_blank" rel="noopener">React’s Context with its Provider and Consumer Components</a> that introduce another level of abstraction. All of these advanced patterns in React are using so called wrapping components. The implementation of the following components shouldn’t be foreign to developers who are creating larger React applications.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; compose &#125; from &apos;recompose&apos;;</span><br><span class="line">import &#123; withRouter &#125; from &apos;react-router-dom&apos;;</span><br><span class="line"></span><br><span class="line">function App(&#123; history, state, dispatch &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;theme =&gt;</span><br><span class="line">        &lt;Content theme=&#123;theme&#125;&gt;</span><br><span class="line">          ...</span><br><span class="line">        &lt;/Content&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default compose(</span><br><span class="line">  withRouter,</span><br><span class="line">  withReducer(reducer, initialState)</span><br><span class="line">)(App);</span><br></pre></td></tr></table></figure><p>Sophie Alpert coined it “the wrapper hell” in React. You are not only seeing it in the implementation, but also when inspecting your components in the browser. There are dozens of wrapped components due to Render Prop Components (including Consumer components from React’s Context) and Higher-Order Components. It becomes an unreadable component tree, because all the abstracted logic is covered up in other React components. The actual visible components are hard to track down in the browser’s DOM. So what if these additional components were not needed because the logic is only encapsulated in functions as side-effects instead? Then you would remove all these wrapping components and flatten your component tree’s structure:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const theme = useTheme();</span><br><span class="line">  const history = useRouter();</span><br><span class="line">  const [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Content theme=&#123;theme&#125;&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/Content&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>That’s what React Hooks are bringing on the table. All side-effects are sitting directly in the component without introducing other components as container for business logic. The container disappears and the logic just sits in React Hooks that are only functions. <a href="https://github.com/acdlite/recompose/commit/7867de653abbb57a49934e52622a60b433bda918" target="_blank" rel="noopener">Andrew Clark already left a statement in favor of React Hooks in his popular Higher-Order Component library called recompose.</a></p><p><strong>JavaScript Class Confusion:</strong> JavaScript mixes two worlds pretty well: Object-oriented programming (OOP) and functional programming. React introduces many developers to both worlds. On the one side, React (and Redux) introduced people to functional programming (FP) with function compositions, general programming concepts with functions (e.g. higher-order functions, JavaScript built-in methods like map, reduce, filter) and other terms such as immutability and side-effects. React itself didn’t really introduce these things, because they are features of the language or the programming paradigm itself, but they are heavily used in React whereas <a href="https://www.robinwieruch.de/javascript-fundamentals-react-requirements/" target="_blank" rel="noopener">every React developer becomes automatically a better JavaScript developer</a>.</p><p>On the other side, React uses JavaScript classes as one way to define React components. A class is only the declaration whereas the actual usage of the component is the instantiation of it. It creates a class instance whereas the <code>this</code> object of the class instance is used to interact with class methods (e.g. setState, forceUpdate, other custom class methods). However, classes come with a steeper learning curve for React beginners who are not coming from an OOP background. That’s why class bindings, the <code>this</code> object and inheritance can be confusing. I have <a href="https://www.robinwieruch.de/the-road-to-learn-react/" target="_blank" rel="noopener">a few chapters in my React book</a> focusing only on this aspect of React which is always the most confusing thing about React for beginners.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// I THOUGHT WE ARE USING A CLASS. WHY IS IT EXTENDING FROM SOMETHING?</span><br><span class="line">class Counter extends Component &#123;</span><br><span class="line">  // WAIT ... THIS WORKS???</span><br><span class="line">  state = &#123; value: 0 &#125;;</span><br><span class="line"></span><br><span class="line">  // I THOUGH IT&apos;S THIS WAY, BUT WHY DO I NEED PROPS HERE?</span><br><span class="line">  // constructor(props) &#123;</span><br><span class="line">  //  SUPER???</span><br><span class="line">  //  super(props);</span><br><span class="line">  //</span><br><span class="line">  //  this.state = &#123;</span><br><span class="line">  //    value: 0,</span><br><span class="line">  //  &#125;;</span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">  // WHY DO I HAVE TO USE AN ARROW FUNCTION???</span><br><span class="line">  onIncrement = () =&gt; &#123;</span><br><span class="line">    this.setState(state =&gt; (&#123;</span><br><span class="line">      value: state.value + 1</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // SHOULDN&apos;T IT BE this.onDecrement = this.onDecrement.bind(this); in the constructor???</span><br><span class="line">  // WHAT&apos;S this.onDecrement = this.onDecrement.bind(this); DOING ANYWAY?</span><br><span class="line">  onDecrement = () =&gt; &#123;</span><br><span class="line">    this.setState(state =&gt; (&#123;</span><br><span class="line">      value: state.value - 1</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;this.state.value&#125;</span><br><span class="line"></span><br><span class="line">        &#123;/* WHY IS EVERYTHING AVAILABLE ON &quot;THIS&quot;??? */&#125;</span><br><span class="line">        &lt;button onClick=&#123;this.onIncrement&#125;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.onDecrement&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, many people argue React shouldn’t take JavaScript classes away because people don’t understand them. After all, they belong to the language. However, one of the hypotheses of introducing the Hooks API is a smoother learning curve for React beginners when writing their React components without JavaScript classes in the first place.</p><p>Every time a new feature is introduced, people are concerned about it. There is one side of the group that is ecstatic about the change, and the other side that fears the change. I heard the most common concerns for React Hooks are:</p><ul><li>Everything changes! <em>Subtle panic mode …</em></li><li>React is becoming bloated like Angular!</li><li>It’s useless, classes worked fine.</li><li>It’s magic!</li></ul><p><strong>Let me address these concerns here:</strong></p><p><strong>Everything changes:</strong> React Hooks will change how we write React applications in the future. However, at the moment, nothing changes. You can still write class components with local state and lifecycle methods and deploy advanced patterns such as Higher-Order Components or Render Prop Components. Nobody takes these learnings away from you. See how I upgraded all my open source projects from older versions to React 16.6. and none of of these projects had problems. They are using HOCs, Render Props and I believe even the old context API (correct me if am wrong). Everything I have learned all these years still works. The React team makes sure that React stays backward compatible. It will be the same with React 16.7.</p><p><img src="https://www.robinwieruch.de/img/posts/react-hooks/react-upgrades_1024.jpg" alt></p><p><strong>React is becoming bloated like Angular:</strong> React was always seen as a library with a slim API. That’s true and shall be true in the future. However, in order to adjust things that were the status quo of building component-based applications a few years ago, and not to be overtaken by other libraries who adapt to the new status quo, React introduces changes in favor of older APIs. If React would start out fresh this year, maybe there would be only function components and hooks. But React was released a couple of years ago and needs to adapt to keep up with the status quo or to invent a status quo. Maybe there will follow deprecations of React class components and lifecycle methods in a few years in favor of React function components and hooks, but at the moment, the React team keeps React class components in their repertoire of tools. After all, the React team utilizes hooks as an invention to run a marathon with React an not to win a sprint. Obviously, React Hooks add yet another API to React, but it is in favor to simplify React’s API in the future. I like this transition more than having a React 2 where everything is different.</p><p><strong>It’s useless, classes worked fine:</strong> Imagine you would start from zero to learn React and you would be introduced to React with Hooks. Maybe <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a> wouldn’t start out with a React class component but with a React function component. Everything you need to learn for your components would be React Hooks. They manage state and side-effects, so you would only need to know about the state and the effect hook. It’s everything a React class component did for you before. It will be simpler for React beginners to learn React without all the other overhead that comes with JavaScript classes (inheritance, this, bindings, super, …). Imagine React Hooks as a new way of how to write React components - It’s a new mindset. I am a skeptical person myself, but once I wrote a couple of simpler scenarios with React Hooks, I was convinced that this is the simplest way to write but also to learn React. As someone who is doing lots of React workshops, I argue that it takes away all the frustration classes bring on the table for React beginners.</p><p><strong>It’s magic:</strong> React is known to be down to earth with JavaScript. Writing React applications makes you a better JavaScript developer - that’s one of the best things about React when someone asks me: “Why should I learn React?”. Whether there comes another library in the future or not, everyone is prepared by honing their JavaScript skills and general programming skills when using React. It’s one of the things that made Redux, often used in React, popular: There is no magic, it is plain JavaScript. Now these React Hooks come along the way, introduce something stateful in a previously often pure function component, a couple of not easily to accept rules, and many don’t understand what’s going on under the hood. But think about it this way: A function component in React is not a mere function. You still have to import React as library to your source code file. It does something with your function, because the function becomes a function component in React land. This function component comes with hidden implementations that were there all the time. How else would it have been possible to use functions as function components as we did it before React Hooks were introduced? And people accepted it too, even though it’s kinda magic. Now, the only thing changed (and maybe it has already been this way before) is that these function components come with an extra hidden object that keeps track of hooks. To quote Dan Abramov from <a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889" target="_blank" rel="noopener">his article about hooks</a>: <em>“Perhaps you’re wondering where React keeps the state for Hooks. The answer is it’s kept in the exact same place where React keeps state for classes. React has an internal update queue which is the source of truth for any state, no matter how you define your components.”</em>.</p><p><strong>Finally, think about it this way:</strong> Component-based solutions such as Angular, Vue, and React are pushing the boundaries of web development with every release. They build up on top of technologies that were invented more than two decades ago. They adapt them to make web development effortless in 2018 and not 1998. They optimize them like crazy to meet the needs in the here and now. We are building web applications with components and not with HTML templates anymore. We are not there yet, but I imagine a future where we sit together and invent a component-based standard for the browser. Angular, Vue and React are only the spearhead of this movement.</p><p>In the following, I want to dive into a few popular React Hooks by example to get you up to speed. All examples can be found in this <a href="https://github.com/the-road-to-learn-react/react-hooks-introduction" target="_blank" rel="noopener">GitHub repository</a>.</p><p>You have seen the useState Hook before in a code snippet for a typical counter example. It is used to manage local state in function components. Let’s use the hook in a more elaborate example where we are going to manage an array of items. In another article of mine, you can learn more about <a href="https://www.robinwieruch.de/react-state-array-add-update-remove/" target="_blank" rel="noopener">managing arrays as state in React</a>, but this time we are doing it with React hooks. Let’s get started:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const INITIAL_LIST = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: &apos;0&apos;,</span><br><span class="line">    title: &apos;React with RxJS for State Management Tutorial&apos;,</span><br><span class="line">    url:</span><br><span class="line">      &apos;https://www.robinwieruch.de/react-rxjs-state-management-tutorial/&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: &apos;1&apos;,</span><br><span class="line">    title: &apos;A complete React with Apollo and GraphQL Tutorial&apos;,</span><br><span class="line">    url: &apos;https://www.robinwieruch.de/react-graphql-apollo-tutorial&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [list, setList] = useState(INITIAL_LIST);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;list.map(item =&gt; (</span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>The useState hook accepts an initial state as argument and returns, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring" target="_blank" rel="noopener">by using array destructuring</a>, two variables that can be named however you want to name them. Whereas the first variable is the actual state, the second variable is a function to update the state by providing a new state.</p><p>The goal of this scenario is to remove an item from the list. In order to accomplish it, every item in the rendered list has a button with a click handler. The click handler can be inlined in the function component, because it will make use of <code>list</code> and <code>setList</code> later. Hence you don’t need to pass these variables to the handler, because they are already available from the outer scope of the component.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [list, setList] = useState(INITIAL_LIST);</span><br><span class="line"></span><br><span class="line">  function onRemoveItem() &#123;</span><br><span class="line">    // remove item from &quot;list&quot;</span><br><span class="line">    // set the new list in state with &quot;setList&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;list.map(item =&gt; (</span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt;</span><br><span class="line">          &lt;button type=&quot;button&quot; onClick=&#123;onRemoveItem&#125;&gt;</span><br><span class="line">            Remove</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Somehow we need to know about the item that should be removed from the list. Using a higher-order function, we can pass the identifier of the item to the handler function. Otherwise we wouldn’t be able to identify the item that should be removed from the list.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [list, setList] = useState(INITIAL_LIST);</span><br><span class="line"></span><br><span class="line">  function onRemoveItem(id) &#123;</span><br><span class="line">    // remove item from &quot;list&quot;</span><br><span class="line">    // set the new list in state with &quot;setList&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;list.map(item =&gt; (</span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt;</span><br><span class="line">          &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; onRemoveItem(item.id)&#125;&gt;</span><br><span class="line">            Remove</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Finally, use the identifier to filter the list with a built-in array method. It returns a new list which is used to set the new state of the list.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [list, setList] = useState(INITIAL_LIST);</span><br><span class="line"></span><br><span class="line">  function onRemoveItem(id) &#123;</span><br><span class="line">    const newList = list.filter(item =&gt; item.id !== id);</span><br><span class="line">    setList(newList);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;list.map(item =&gt; (</span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt;</span><br><span class="line">          &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; onRemoveItem(item.id)&#125;&gt;</span><br><span class="line">            Remove</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>That should do the job. You are able to remove an item from the list based on the identifier you pass to the handler. The handler then filters the list and sets the new state of the list with the <code>setList</code> function.</p><p>The useState hook gives you everything you need to manage state in a function component: initial state, the latest state, and a state update function. Everything else is JavaScript again. Furthermore, you don’t need to bother about the state object with its shallow merge as before in a class component. Instead, you encapsulate one domain (e.g. list) with useState, but if you would need another state (e.g. counter), then just encapsulate this domain with another useState. You can read more about <a href="https://reactjs.org/docs/hooks-state.html" target="_blank" rel="noopener">the useState hook in React’s documentation</a>.</p><p>Let’s head over to the next hook called useEffect. As mentioned before, function components should be able to manage state and side-effects with hooks. Managing state was showcased with the useState hook. Now comes the useEffect hook into play for side-effects which are usually used for interactions with the Browser/DOM API or external API like data fetching. Let’s see how the useEffect hook can be used for interaction with the Browser API by implementing a simple stopwatch. You can see how it is done in a React class component in this <a href="https://github.com/the-road-to-learn-react/react-interval-setstate-unmounted-component-performance" target="_blank" rel="noopener">GitHub repository</a>.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;!isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt;</span><br><span class="line">          Start</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line"></span><br><span class="line">      &#123;isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt;</span><br><span class="line">          Stop</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>There is no stopwatch yet. But at least there are is a <a href="https://www.robinwieruch.de/conditional-rendering-react/" target="_blank" rel="noopener">conditional rendering</a> to show either a “Start” or “Stop” button. The state for the boolean flag is managed by the useState hook.</p><p>Let’s introduce our side-effect with useEffect that registers an interval. The function used for the interval emits a console logging every second to your developer tools of your browser.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    setInterval(() =&gt; console.log(&apos;tick&apos;), 1000);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;!isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt;</span><br><span class="line">          Start</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line"></span><br><span class="line">      &#123;isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt;</span><br><span class="line">          Stop</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>In order to remove the interval when the component unmounts (but also after every other render update), you can return a function in useEffect for anything to be called for the clean up. For instance, there shouldn’t be any memory leak left behind when the component isn’t there anymore.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000);</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>Now, you want to setup the side-effect when mounting the component and the clean up the side-effect when unmounting the component. If you would log how many times the function within the effect is called, you would see that it sets a new interval every time the state of the component changes (e.g. click on “Start”/“Stop” button).</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;effect runs&apos;);</span><br><span class="line">    const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000);</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>In order to only run the effect on mount and unmount of the component, you can pass it an empty array as second argument.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000);</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>However, since the interval is cleaned up after every render too, we need to set the interval in our update cycle too. But we can tell the effect to run only when the <code>isOn</code> variable changes. Only when one of the variables in the array changes, the effect will run during the update cycle. If you keep the array empty, the effect will only run on mount and unmount, because there is no variable to be checked for running the side-effect again.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000);</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;, [isOn]);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>The interval is running whether the <code>isOn</code> boolean is true or false. It would be great to only run it when the stopwatch is activated.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    let interval;</span><br><span class="line"></span><br><span class="line">    if (isOn) &#123;</span><br><span class="line">      interval = setInterval(() =&gt; console.log(&apos;tick&apos;), 1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;, [isOn]);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>Now introduce another state in your function component to keep track of the timer of the stopwatch. It is used to update the timer, but only when the stopwatch is activated.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line">  const [timer, setTimer] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    let interval;</span><br><span class="line"></span><br><span class="line">    if (isOn) &#123;</span><br><span class="line">      interval = setInterval(</span><br><span class="line">        () =&gt; setTimer(timer + 1),</span><br><span class="line">        1000,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;, [isOn]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;timer&#125;</span><br><span class="line"></span><br><span class="line">      &#123;!isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt;</span><br><span class="line">          Start</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line"></span><br><span class="line">      &#123;isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt;</span><br><span class="line">          Stop</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>There is still one mistake in the code. When the interval is running, it updates the timer every second by increasing it by one. However, it always relies on a stale state for the timer. Only when the <code>inOn</code> boolean flag changes the state is fine. In order to receive always the latest state for the timer when the interval is running, you can use a function instead for the state update function which always has the latest state.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line">  const [timer, setTimer] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    let interval;</span><br><span class="line"></span><br><span class="line">    if (isOn) &#123;</span><br><span class="line">      interval = setInterval(</span><br><span class="line">        () =&gt; setTimer(timer =&gt; timer + 1),</span><br><span class="line">        1000,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;, [isOn]);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>An alternative would have been to run the effect also when the timer changes. Then the effect would receive the latest timer state.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line">  const [timer, setTimer] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    let interval;</span><br><span class="line"></span><br><span class="line">    if (isOn) &#123;</span><br><span class="line">      interval = setInterval(</span><br><span class="line">        () =&gt; setTimer(timer + 1),</span><br><span class="line">        1000,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;, [isOn, timer]);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>That’s the implementation for the stopwatch that uses the Browser API If you want to continue, you can extend the example by providing a “Reset” button too.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOn, setIsOn] = useState(false);</span><br><span class="line">  const [timer, setTimer] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    let interval;</span><br><span class="line"></span><br><span class="line">    if (isOn) &#123;</span><br><span class="line">      interval = setInterval(</span><br><span class="line">        () =&gt; setTimer(timer =&gt; timer + 1),</span><br><span class="line">        1000,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearInterval(interval);</span><br><span class="line">  &#125;, [isOn]);</span><br><span class="line"></span><br><span class="line">  const onReset = () =&gt; &#123;</span><br><span class="line">    setIsOn(false);</span><br><span class="line">    setTimer(0);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;timer&#125;</span><br><span class="line"></span><br><span class="line">      &#123;!isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(true)&#125;&gt;</span><br><span class="line">          Start</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line"></span><br><span class="line">      &#123;isOn &amp;&amp; (</span><br><span class="line">        &lt;button type=&quot;button&quot; onClick=&#123;() =&gt; setIsOn(false)&#125;&gt;</span><br><span class="line">          Stop</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line"></span><br><span class="line">      &lt;button type=&quot;button&quot; disabled=&#123;timer === 0&#125; onClick=&#123;onReset&#125;&gt;</span><br><span class="line">        Reset</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>That’s it. The useEffect hook is used for side-effects in React function components that are used for interacting with the Browser/DOM API or other third-party APIs (e.g. data fetching). You can read more about <a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener">the useEffect hook in React’s documentation</a>.</p><p>Last but not least, after you have learned about the two most popular hooks that introduce state and side-effects in function components, there is one last thing I want to show you: custom hooks. That’s right, you can implement your own custom React Hooks that can be reused in your application or by others. Let’s see how they work with an example application which is able to detect whether your device is online or offline.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOffline, setIsOffline] = useState(false);</span><br><span class="line"></span><br><span class="line">  if (isOffline) &#123;</span><br><span class="line">    return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;You are online!&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>Again, introduce the useEffect hook for the side-effect. In this case, the effect adds and removes listeners that check if the device is online or offline. Both listeners are setup only once on mount and cleaned up once on unmount (empty array as second argument). Whenever one of the listeners is called, it sets the state for the <code>isOffline</code> boolean.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [isOffline, setIsOffline] = useState(false);</span><br><span class="line"></span><br><span class="line">  function onOffline() &#123;</span><br><span class="line">    setIsOffline(true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function onOnline() &#123;</span><br><span class="line">    setIsOffline(false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    window.addEventListener(&apos;offline&apos;, onOffline);</span><br><span class="line">    window.addEventListener(&apos;online&apos;, onOnline);</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      window.removeEventListener(&apos;offline&apos;, onOffline);</span><br><span class="line">      window.removeEventListener(&apos;online&apos;, onOnline);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  if (isOffline) &#123;</span><br><span class="line">    return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;You are online!&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>Everything is nicely encapsulated in one effect now. It’s a great functionality which should be reuse somewhere else too. That’s why we can extract the functionality as its a custom hook which follows the same naming convention as the other hooks.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function useOffline() &#123;</span><br><span class="line">  const [isOffline, setIsOffline] = useState(false);</span><br><span class="line"></span><br><span class="line">  function onOffline() &#123;</span><br><span class="line">    setIsOffline(true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function onOnline() &#123;</span><br><span class="line">    setIsOffline(false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    window.addEventListener(&apos;offline&apos;, onOffline);</span><br><span class="line">    window.addEventListener(&apos;online&apos;, onOnline);</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      window.removeEventListener(&apos;offline&apos;, onOffline);</span><br><span class="line">      window.removeEventListener(&apos;online&apos;, onOnline);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return isOffline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const isOffline = useOffline();</span><br><span class="line"></span><br><span class="line">  if (isOffline) &#123;</span><br><span class="line">    return &lt;div&gt;Sorry, you are offline ...&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;You are online!&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>Extracting the custom hook as function was not the only thing. You also have to return the <code>isOffline</code> state from the custom hook in order to use it in your application to show a message to users who are offline. Otherwise, it should render the normal application. That’s it for the custom hook that detects whether you are online or offline. You can read more about <a href="https://reactjs.org/docs/hooks-custom.html" target="_blank" rel="noopener">custom hooks in React’s documentation</a>.</p><p>React Hooks being reusable is the best thing about them, because there is the potential to grow an ecosystem of custom React Hooks that can be installed from npm for any React application. And not only for React applications. Evan You, creator of Vue, <a href="https://twitter.com/youyuxi/status/1056042395891105793" target="_blank" rel="noopener">is hooked (!) by them as well</a>. Maybe we will see a bridge between both ecosystems where it is possible to share hooks between Vue and React.</p><hr><p>If you want to dive deeper into the state and effect hooks, you can check out the following React hook tutorials:</p><ul><li><a href="https://www.robinwieruch.de/react-usereducer-hook/" target="_blank" rel="noopener">How to useReducer Hook?</a></li><li><a href="https://www.robinwieruch.de/react-hooks-migration" target="_blank" rel="noopener">Migration from Class Components to Hooks</a></li><li><a href="https://www.robinwieruch.de/react-usereducer-vs-usestate/" target="_blank" rel="noopener">Comparison useState vs useReducer</a></li><li><a href="https://www.robinwieruch.de/react-state-usereducer-usestate-usecontext" target="_blank" rel="noopener">Modern State Management with Hooks</a></li><li><a href="https://www.robinwieruch.de/react-hooks-fetch-data" target="_blank" rel="noopener">How to fetch data with React Hooks</a></li></ul><p>Checkout the official <a href="https://reactjs.org/docs/hooks-faq.html" target="_blank" rel="noopener">FAQ</a> and <a href="https://reactjs.org/docs/hooks-rules.html" target="_blank" rel="noopener">Rules</a> for hooks in React’s documentation to learn more about their fine-grained behaviour. In addition, you can checkout <a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener">all officially available React Hooks</a> too.</p><p>For everyone who is still concerned about React Hooks: Give them a shot yourself. Implement a couple of React function components with state and side-effects. I had to do it myself to understand how they work and to feel comfortable with them. And I must say it feels pretty great to use them.</p><h2 id="The-Road-to-learn-React"><a href="#The-Road-to-learn-React" class="headerlink" title="The Road to learn React"></a>The Road to learn React</h2><p><img src="https://www.robinwieruch.de/img/page/cover.png" alt></p><p>Build a Hacker News App along the way. No setup configuration. No tooling. No Redux. Plain React in 200+ pages of learning material. Learn React like <strong>50.000+ readers</strong>.</p><p><a href="https://roadtoreact.com/" target="_blank" rel="noopener">Get the Book for free</a></p><h3 id="Never-miss-an-article-about-web-development-JavaScript-and-self-growth"><a href="#Never-miss-an-article-about-web-development-JavaScript-and-self-growth" class="headerlink" title="Never miss an article about web development, JavaScript and self-growth"></a>Never miss an article about web development, JavaScript and self-growth</h3><h2 id="Take-Part"><a href="#Take-Part" class="headerlink" title="Take Part"></a>Take Part</h2><h3 id="Join-30-000-Developers"><a href="#Join-30-000-Developers" class="headerlink" title="Join 30.000+ Developers"></a>Join 30.000+ Developers</h3><h3 id="Learn-Web-Development-with-JavaScript"><a href="#Learn-Web-Development-with-JavaScript" class="headerlink" title="Learn Web Development with JavaScript"></a>Learn Web Development with JavaScript</h3><h3 id="Tips-and-Tricks"><a href="#Tips-and-Tricks" class="headerlink" title="Tips and Tricks"></a>Tips and Tricks</h3><h3 id="Access-Tutorials-eBooks-and-Courses"><a href="#Access-Tutorials-eBooks-and-Courses" class="headerlink" title="Access Tutorials, eBooks and Courses"></a>Access Tutorials, eBooks and Courses</h3><h3 id="Personal-Development-as-a-Software-Engineer"><a href="#Personal-Development-as-a-Software-Engineer" class="headerlink" title="Personal Development as a Software Engineer"></a>Personal Development as a Software Engineer</h3>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
        <category>React Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>【React深入】从Mixin到HOC再到Hook</title>
    <url>/archives/90ac.html</url>
    <content><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.im/post/5cad39b3f265da03502b1c0a#heading-35" target="_blank" rel="noopener">https://juejin.im/post/5cad39b3f265da03502b1c0a#heading-35</a></p></blockquote><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>前端发展速度非常之快，页面和组件变得越来越复杂，如何更好的实现<code>状态逻辑复用</code>一直都是应用程序中重要的一部分，这直接关系着应用程序的质量以及维护的难易程度。</p><p>本文介绍了<code>React</code>采用的三种实现<code>状态逻辑复用</code>的技术，并分析了他们的实现原理、使用方法、实际应用以及如何选择使用他们。</p><p>本文略长，下面是本文的思维导图，您可以从头开始阅读，也可以选择感兴趣的部分阅读：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a93f73ff19e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><h2 id="Mixin-设计模式"><a href="#Mixin-设计模式" class="headerlink" title="Mixin 设计模式"></a>Mixin 设计模式</h2><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a93f7719481?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p><code>Mixin</code>（混入）是一种通过扩展收集功能的方式，它本质上是将一个对象的属性拷贝到另一个对象上面去，不过你可以拷贝<code>任意多</code>个对象的<code>任意个</code>方法到一个新对象上去，这是<code>继承</code>所不能实现的。它的出现主要就是为了解决代码复用问题。</p><p>很多开源库提供了<code>Mixin</code>的实现，如<code>Underscore</code>的<code>_.extend</code>方法、<code>JQuery</code>的<code>extend</code>方法。</p><p>使用<code>_.extend</code>方法实现代码复用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var LogMixin = &#123;</span><br><span class="line">  actionLog: function() &#123;</span><br><span class="line">    console.log(&apos;action...&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">  requestLog: function() &#123;</span><br><span class="line">    console.log(&apos;request...&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">function User() &#123;  /*..*/  &#125;</span><br><span class="line">function Goods() &#123;  /*..*/ &#125;</span><br><span class="line">_.extend(User.prototype, LogMixin);</span><br><span class="line">_.extend(Goods.prototype, LogMixin);</span><br><span class="line">var user = new User();</span><br><span class="line">var good = new Goods();</span><br><span class="line">user.actionLog();</span><br><span class="line">good.requestLog();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们可以尝试手动写一个简单的<code>Mixin</code>方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setMixin(target, mixin) &#123;</span><br><span class="line">  if (arguments[2]) &#123;</span><br><span class="line">    for (var i = 2, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">      target.prototype[arguments[i]] = mixin.prototype[arguments[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    for (var methodName in mixin.prototype) &#123;</span><br><span class="line">      if (!Object.hasOwnProperty(target.prototype, methodName)) &#123;</span><br><span class="line">        target.prototype[methodName] = mixin.prototype[methodName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setMixin(User,LogMixin,&apos;actionLog&apos;);</span><br><span class="line">setMixin(Goods,LogMixin,&apos;requestLog&apos;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>您可以使用<code>setMixin</code>方法将任意对象的任意方法扩展到目标对象上。</p><h2 id="React-中应用-Mixin"><a href="#React-中应用-Mixin" class="headerlink" title="React 中应用 Mixin"></a>React 中应用 Mixin</h2><p><code>React</code>也提供了<code>Mixin</code>的实现，如果完全不同的组件有相似的功能，我们可以引入来实现代码复用，当然只有在使用<code>createClass</code>来创建<code>React</code>组件时才可以使用，因为在<code>React</code>组件的<code>es6</code>写法中它已经被废弃掉了。</p><p>例如下面的例子，很多组件或页面都需要记录用户行为，性能指标等。如果我们在每个组件都引入写日志的逻辑，会产生大量重复代码，通过<code>Mixin</code>我们可以解决这一问题：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var LogMixin = &#123;</span><br><span class="line">  log: function() &#123;</span><br><span class="line">    console.log(&apos;log&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">  componentDidMount: function() &#123;</span><br><span class="line">    console.log(&apos;in&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">  componentWillUnmount: function() &#123;</span><br><span class="line">    console.log(&apos;out&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var User = React.createClass(&#123;</span><br><span class="line">  mixins: [LogMixin],</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return (&lt;div&gt;...&lt;/div&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var Goods = React.createClass(&#123;</span><br><span class="line">  mixins: [LogMixin],</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return (&lt;div&gt;...&lt;/div&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="Mixin-带来的危害"><a href="#Mixin-带来的危害" class="headerlink" title="Mixin 带来的危害"></a>Mixin 带来的危害</h2><p><code>React</code>官方文档在 <a href="https://link.juejin.im?target=https%3A%2F%2Freact.docschina.org%2Fblog%2F2016%2F07%2F13%2Fmixins-considered-harmful.html" target="_blank" rel="noopener">Mixins Considered Harmful</a> 一文中提到了<code>Mixin</code>带来了危害：</p><ul><li><code>Mixin</code> 可能会相互依赖，相互耦合，不利于代码维护</li><li>不同的<code>Mixin</code>中的方法可能会相互冲突</li><li><code>Mixin</code>非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性</li></ul><p><code>React</code>现在已经不再推荐使用<code>Mixin</code>来解决代码复用问题，因为<code>Mixin</code>带来的危害比他产生的价值还要巨大，并且<code>React</code>全面推荐使用高阶组件来替代它。另外，高阶组件还能实现更多其他更强大的功能，在学习高阶组件之前，我们先来看一个设计模式。</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a93f7d6879a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>装饰者 (<code>decorator</code>) 模式能够在不改变对象自身的基础上，在程序运行期间给对像动态的添加职责。与继承相比，装饰者是一种更轻便灵活的做法。</p><h2 id="高阶组件（HOC）"><a href="#高阶组件（HOC）" class="headerlink" title="高阶组件（HOC）"></a>高阶组件（HOC）</h2><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a93f959e716?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>高阶组件可以看作<code>React</code>对装饰模式的一种实现，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。</p><blockquote><p>高阶组件（<code>HOC</code>）是<code>React</code>中的高级技术，用来重用组件逻辑。但高阶组件本身并不是<code>React API</code>。它只是一种模式，这种模式是由<code>React</code>自身的组合性质必然产生的。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function visible(WrappedComponent) &#123;</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      const &#123; visible, ...props &#125; = this.props;</span><br><span class="line">      if (visible === false) return null;</span><br><span class="line">      return &lt;WrappedComponent &#123;...props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面的代码就是一个<code>HOC</code>的简单应用，函数接收一个组件作为参数，并返回一个新组件，新组建可以接收一个<code>visible props</code>，根据<code>visible</code>的值来判断是否渲染 Visible。</p><p>下面我们从以下几方面来具体探索<code>HOC</code>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a93f9a729dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><h2 id="HOC-的实现方式"><a href="#HOC-的实现方式" class="headerlink" title="HOC 的实现方式"></a>HOC 的实现方式</h2><h3 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h3><p>函数返回一个我们自己定义的组件，然后在<code>render</code>中返回要包裹的组件，这样我们就可以代理所有传入的<code>props</code>，并且决定如何渲染，实际上 ，这种方式生成的高阶组件就是原组件的父组件，上面的函数<code>visible</code>就是一个<code>HOC</code>属性代理的实现方式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function proxyHOC(WrappedComponent) &#123;</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>对比原生组件增强的项：</p><ul><li>可操作所有传入的<code>props</code></li><li>可操作组件的生命周期</li><li>可操作组件的<code>static</code>方法</li><li>获取<code>refs</code></li></ul><h3 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h3><p>返回一个组件，继承原组件，在<code>render</code>中调用原组件的<code>render</code>。由于继承了原组件，能通过 this 访问到原组件的<code>生命周期、props、state、render</code>等，相比属性代理它能操作更多的属性。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function inheritHOC(WrappedComponent) &#123;</span><br><span class="line">  return class extends WrappedComponent &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return super.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>对比原生组件增强的项：</p><ul><li>可操作所有传入的<code>props</code></li><li>可操作组件的生命周期</li><li>可操作组件的<code>static</code>方法</li><li>获取<code>refs</code></li><li>可操作<code>state</code></li><li>可以渲染劫持</li></ul><h2 id="HOC-可以实现什么功能"><a href="#HOC-可以实现什么功能" class="headerlink" title="HOC 可以实现什么功能"></a>HOC 可以实现什么功能</h2><h3 id="组合渲染"><a href="#组合渲染" class="headerlink" title="组合渲染"></a>组合渲染</h3><p>可使用任何其他组件和原组件进行组合渲染，达到样式、布局复用等效果。</p><blockquote><p>通过属性代理实现</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function stylHOC(WrappedComponent) &#123;</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return (&lt;div&gt;</span><br><span class="line">        &lt;div class&gt;&#123;this.props.title&#125;&lt;/div&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>通过反向继承实现</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function styleHOC(WrappedComponent) &#123;</span><br><span class="line">  return class extends WrappedComponent &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;div&gt;</span><br><span class="line">        &lt;div class&gt;&#123;this.props.title&#125;&lt;/div&gt;</span><br><span class="line">        &#123;super.render()&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>根据特定的属性决定原组件是否渲染</p><blockquote><p>通过属性代理实现</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function visibleHOC(WrappedComponent) &#123;</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      if (this.props.visible === false) return null;</span><br><span class="line">      return &lt;WrappedComponent &#123;...props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>通过反向继承实现</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function visibleHOC(WrappedComponent) &#123;</span><br><span class="line">  return class extends WrappedComponent &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      if (this.props.visible === false) &#123;</span><br><span class="line">        return null</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return super.render()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="操作-props"><a href="#操作-props" class="headerlink" title="操作 props"></a>操作 props</h3><p>可以对传入组件的<code>props</code>进行增加、修改、删除或者根据特定的<code>props</code>进行特殊的操作。</p><blockquote><p>通过属性代理实现</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function proxyHOC(WrappedComponent) &#123;</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      const newProps = &#123;</span><br><span class="line">        ...this.props,</span><br><span class="line">        user: &apos;ConardLi&apos;</span><br><span class="line">      &#125;</span><br><span class="line">      return &lt;WrappedComponent &#123;...newProps&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="获取-refs"><a href="#获取-refs" class="headerlink" title="获取 refs"></a>获取 refs</h3><p>高阶组件中可获取原组件的<code>ref</code>，通过<code>ref</code>获取组件实力，如下面的代码，当程序初始化完成后调用原组件的 log 方法。(不知道 refs 怎么用，请👇<a href="https://link.juejin.im?target=https%3A%2F%2Freact.docschina.org%2Fdocs%2Frefs-and-the-dom.html" target="_blank" rel="noopener">Refs &amp; DOM</a>)</p><blockquote><p>通过属性代理实现</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function refHOC(WrappedComponent) &#123;</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      this.wapperRef.log()</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.props&#125; ref=&#123;ref =&gt; &#123; this.wapperRef = ref &#125;&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里注意：调用高阶组件的时候并不能获取到原组件的真实<code>ref</code>，需要手动进行传递，具体请看<a href="#%E4%BC%A0%E9%80%92refs">传递 refs</a></p><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>将原组件的状态提取到<code>HOC</code>中进行管理，如下面的代码，我们将<code>Input</code>的<code>value</code>提取到<code>HOC</code>中进行管理，使它变成受控组件，同时不影响它使用<code>onChange</code>方法进行一些其他操作。基于这种方式，我们可以实现一个简单的<code>双向绑定</code>，具体请看<a href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A">双向绑定</a>。</p><blockquote><p>通过属性代理实现</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function proxyHoc(WrappedComponent) &#123;</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.state = &#123; value: &apos;&apos; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onChange = (event) =&gt; &#123;</span><br><span class="line">      const &#123; onChange &#125; = this.props;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        value: event.target.value,</span><br><span class="line">      &#125;, () =&gt; &#123;</span><br><span class="line">        if(typeof onChange ===&apos;function&apos;)&#123;</span><br><span class="line">          onChange(event);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      const newProps = &#123;</span><br><span class="line">        value: this.state.value,</span><br><span class="line">        onChange: this.onChange,</span><br><span class="line">      &#125;</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HOC extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;input &#123;...this.props&#125;&gt;&lt;/input&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default proxyHoc(HOC);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="操作-state"><a href="#操作-state" class="headerlink" title="操作 state"></a>操作 state</h3><p>上面的例子通过属性代理利用 HOC 的 state 对原组件进行了一定的增强，但并不能直接控制原组件的<code>state</code>，而通过反向继承，我们可以直接操作原组件的<code>state</code>。但是并不推荐直接修改或添加原组件的<code>state</code>，因为这样有可能和组件内部的操作构成冲突。</p><blockquote><p>通过反向继承实现</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debugHOC(WrappedComponent) &#123;</span><br><span class="line">  return class extends WrappedComponent &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      console.log(&apos;props&apos;, this.props);</span><br><span class="line">      console.log(&apos;state&apos;, this.state);</span><br><span class="line">      return (</span><br><span class="line">        &lt;div class&gt;</span><br><span class="line">          &#123;super.render()&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面的<code>HOC</code>在<code>render</code>中将<code>props</code>和<code>state</code>打印出来，可以用作调试阶段，当然你可以在里面写更多的调试代码。想象一下，只需要在我们想要调试的组件上加上<code>@debug</code>就可以对该组件进行调试，而不需要在每次调试的时候写很多冗余代码。(如果你还不知道怎么使用 HOC，请👇<a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8HOC">如何使用 HOC</a>)</p><h3 id="渲染劫持"><a href="#渲染劫持" class="headerlink" title="渲染劫持"></a>渲染劫持</h3><p>高阶组件可以在 render 函数中做非常多的操作，从而控制原组件的渲染输出。只要改变了原组件的渲染，我们都将它称之为一种<code>渲染劫持</code>。</p><p>实际上，上面的<a href="#%E7%BB%84%E5%90%88%E6%B8%B2%E6%9F%93">组合渲染</a>和<a href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93">条件渲染</a>都是<code>渲染劫持</code>的一种，通过反向继承，不仅可以实现以上两点，还可直接<code>增强</code>由原组件<code>render</code>函数产生的<code>React元素</code>。</p><blockquote><p>通过反向继承实现</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hijackHOC(WrappedComponent) &#123;</span><br><span class="line">  return class extends WrappedComponent &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      const tree = super.render();</span><br><span class="line">      let newProps = &#123;&#125;;</span><br><span class="line">      if (tree &amp;&amp; tree.type === &apos;input&apos;) &#123;</span><br><span class="line">        newProps = &#123; value: &apos;渲染被劫持了&apos; &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      const props = Object.assign(&#123;&#125;, tree.props, newProps);</span><br><span class="line">      const newTree = React.cloneElement(tree, props, tree.props.children);</span><br><span class="line">      return newTree;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意上面的说明我用的是<code>增强</code>而不是<code>更改</code>。<code>render</code>函数内实际上是调用<code>React.creatElement</code>产生的<code>React元素</code>：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a93fa0c3651?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>虽然我们能拿到它，但是我们不能直接修改它里面的属性，我们通过</p><p><code>getOwnPropertyDescriptors</code></p><p>函数来打印下它的配置项：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a947a775967?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>可以发现，所有的<code>writable</code>属性均被配置为了<code>false</code>，即所有属性是不可变的。（对这些配置项有疑问，请👇<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FdefineProperty" target="_blank" rel="noopener">defineProperty</a>）</p><p>不能直接修改，我们可以借助<code>cloneElement</code>方法来在原组件的基础上增强一个新组件：</p><blockquote><p><code>React.cloneElement()</code>克隆并返回一个新的<code>React元素</code>，使用<code>element</code>作为起点。生成的元素将会拥有原始元素 props 与新 props 的浅合并。新的子级会替换现有的子级。来自原始元素的 key 和 ref 将会保留。</p></blockquote><p><code>React.cloneElement()</code>几乎相当于：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;element.type &#123;...element.props&#125; &#123;...props&#125;&gt;&#123;children&#125;&lt;/element.type&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="如何使用-HOC"><a href="#如何使用-HOC" class="headerlink" title="如何使用 HOC"></a>如何使用 HOC</h2><p>上面的示例代码都写的是如何声明一个<code>HOC</code>，<code>HOC</code>实际上是一个函数，所以我们将要增强的组件作为参数调用<code>HOC</code>函数，得到增强后的组件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class myComponent extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (&lt;span&gt;原组件&lt;/span&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default inheritHOC(myComponent);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>在实际应用中，一个组件可能被多个<code>HOC</code>增强，我们使用的是被所有的<code>HOC</code>增强后的组件，借用一张<code>装饰模式</code>的图来说明，可能更容易理解：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a949cfeb119?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>假设现在我们有<code>logger</code>，<code>visible</code>，<code>style</code>等多个<code>HOC</code>，现在要同时增强一个<code>Input</code>组件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger(visible(style(Input)))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这种代码非常的难以阅读，我们可以手动封装一个简单的函数组合工具，将写法改写如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; g(f(...args)));</span><br><span class="line">compose(logger,visible,style)(Input);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>compose</code>函数返回一个所有函数组合后的函数，<code>compose(f, g, h)</code> 和 <code>(...args) =&gt; f(g(h(...args)))</code>是一样的。</p><p>很多第三方库都提供了类似<code>compose</code>的函数，例如<code>lodash.flowRight</code>，<code>Redux</code>提供的<code>combineReducers</code>函数等。</p><h3 id="Decorators"><a href="#Decorators" class="headerlink" title="Decorators"></a>Decorators</h3><p>我们还可以借助<code>ES7</code>为我们提供的<code>Decorators</code>来让我们的写法变的更加优雅：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@logger</span><br><span class="line">@visible</span><br><span class="line">@style</span><br><span class="line">class Input extends Component &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>Decorators</code>是<code>ES7</code>的一个提案，还没有被标准化，但目前<code>Babel</code>转码器已经支持，我们需要提前配置<code>babel-plugin-transform-decorators-legacy</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>还可以结合上面的<code>compose</code>函数使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const hoc = compose(logger, visible, style);</span><br><span class="line">@hoc</span><br><span class="line">class Input extends Component &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="HOC-的实际应用"><a href="#HOC-的实际应用" class="headerlink" title="HOC 的实际应用"></a>HOC 的实际应用</h2><p>下面是一些我在生产环境中实际对<code>HOC</code>的实际应用场景，由于文章篇幅原因，代码经过很多简化，如有问题欢迎在评论区指出：</p><h3 id="日志打点"><a href="#日志打点" class="headerlink" title="日志打点"></a>日志打点</h3><p>实际上这属于一类最常见的应用，多个组件拥有类似的逻辑，我们要对重复的逻辑进行复用， 官方文档中<code>CommentList</code>的示例也是解决了代码复用问题，写的很详细，有兴趣可以👇<a href="https://link.juejin.im?target=https%3A%2F%2Freact.docschina.org%2Fdocs%2Fhigher-order-components.html%23%25E4%25BD%25BF%25E7%2594%25A8%25E9%25AB%2598%25E9%2598%25B6%25E7%25BB%2584%25E4%25BB%25B6%25EF%25BC%2588hoc%25EF%25BC%2589%25E8%25A7%25A3%25E5%2586%25B3%25E6%25A8%25AA%25E5%2588%2587%25E5%2585%25B3%25E6%25B3%25A8%25E7%2582%25B9" target="_blank" rel="noopener">使用高阶组件（HOC）解决横切关注点</a>。</p><p>某些页面需要记录用户行为，性能指标等等，通过高阶组件做这些事情可以省去很多重复代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function logHoc(WrappedComponent) &#123;</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    componentWillMount() &#123;</span><br><span class="line">      this.start = Date.now();</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      this.end = Date.now();</span><br><span class="line">      console.log(`$&#123;WrappedComponent.dispalyName&#125; 渲染时间：$&#123;this.end - this.start&#125; ms`);</span><br><span class="line">      console.log(`$&#123;user&#125;进入$&#123;WrappedComponent.dispalyName&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      console.log(`$&#123;user&#125;退出$&#123;WrappedComponent.dispalyName&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="可用、权限控制"><a href="#可用、权限控制" class="headerlink" title="可用、权限控制"></a>可用、权限控制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function auth(WrappedComponent) &#123;</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      const &#123; visible, auth, display = null, ...props &#125; = this.props;</span><br><span class="line">      if (visible === false || (auth &amp;&amp; authList.indexOf(auth) === -1)) &#123;</span><br><span class="line">        return display</span><br><span class="line">      &#125;</span><br><span class="line">      return &lt;WrappedComponent &#123;...props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>authList</code>是我们在进入程序时向后端请求的所有权限列表，当组件所需要的权限不列表中，或者设置的 <code>visible</code>是<code>false</code>，我们将其显示为传入的组件样式，或者<code>null</code>。我们可以将任何需要进行权限校验的组件应用<code>HOC</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  @auth</span><br><span class="line">  class Input extends Component &#123;  ...  &#125;</span><br><span class="line">  @auth</span><br><span class="line">  class Button extends Component &#123;  ...  &#125;</span><br><span class="line"></span><br><span class="line">  &lt;Button auth=&quot;user/addUser&quot;&gt;添加用户&lt;/Button&gt;</span><br><span class="line">  &lt;Input auth=&quot;user/search&quot; visible=&#123;false&#125; &gt;添加用户&lt;/Input&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>在<code>vue</code>中，绑定一个变量后可实现双向数据绑定，即表单中的值改变后绑定的变量也会自动改变。而<code>React</code>中没有做这样的处理，在默认情况下，表单元素都是<code>非受控组件</code>。给表单元素绑定一个状态后，往往需要手动书写<code>onChange</code>方法来将其改写为<code>受控组件</code>，在表单元素非常多的情况下这些重复操作是非常痛苦的。</p><p>我们可以借助高阶组件来实现一个简单的双向绑定，代码略长，可以结合下面的思维导图进行理解。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a94a5328c3b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>首先我们自定义一个<code>Form</code>组件，该组件用于包裹所有需要包裹的表单组件，通过<code>contex</code>向子组件暴露两个属性：</p><ul><li><code>model</code>：当前<code>Form</code>管控的所有数据，由表单<code>name</code>和<code>value</code>组成，如<code>{name:&#39;ConardLi&#39;,pwd:&#39;123&#39;}</code>。<code>model</code>可由外部传入，也可自行管控。</li><li><code>changeModel</code>：改变<code>model</code>中某个<code>name</code>的值。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Form extends Component &#123;</span><br><span class="line">  static childContextTypes = &#123;</span><br><span class="line">    model: PropTypes.object,</span><br><span class="line">    changeModel: PropTypes.func</span><br><span class="line">  &#125;</span><br><span class="line">  constructor(props, context) &#123;</span><br><span class="line">    super(props, context);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      model: props.model || &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    if (nextProps.model) &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        model: nextProps.model</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  changeModel = (name, value) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      model: &#123; ...this.state.model, [name]: value &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      changeModel: this.changeModel,</span><br><span class="line">      model: this.props.model || this.state.model</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  onSubmit = () =&gt; &#123;</span><br><span class="line">    console.log(this.state.model);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &#123;this.props.children&#125;</span><br><span class="line">      &lt;button onClick=&#123;this.onSubmit&#125;&gt;提交&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>下面定义用于双向绑定的<code>HOC</code>，其代理了表单的<code>onChange</code>属性和<code>value</code>属性：</p><ul><li>发生<code>onChange</code>事件时调用上层<code>Form</code>的<code>changeModel</code>方法来改变<code>context</code>中的<code>model</code>。</li><li>在渲染时将<code>value</code>改为从<code>context</code>中取出的值。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function proxyHoc(WrappedComponent) &#123;</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    static contextTypes = &#123;</span><br><span class="line">      model: PropTypes.object,</span><br><span class="line">      changeModel: PropTypes.func</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onChange = (event) =&gt; &#123;</span><br><span class="line">      const &#123; changeModel &#125; = this.context;</span><br><span class="line">      const &#123; onChange &#125; = this.props;</span><br><span class="line">      const &#123; v_model &#125; = this.props;</span><br><span class="line">      changeModel(v_model, event.target.value);</span><br><span class="line">      if(typeof onChange === &apos;function&apos;)&#123;onChange(event);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      const &#123; model &#125; = this.context;</span><br><span class="line">      const &#123; v_model &#125; = this.props;</span><br><span class="line">      return &lt;WrappedComponent</span><br><span class="line">        &#123;...this.props&#125;</span><br><span class="line">        value=&#123;model[v_model]&#125;</span><br><span class="line">        onChange=&#123;this.onChange&#125;</span><br><span class="line">      /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@proxyHoc</span><br><span class="line">class Input extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;input &#123;...this.props&#125;&gt;&lt;/input&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面的代码只是简略的一部分，除了<code>input</code>，我们还可以将<code>HOC</code>应用在<code>select</code>等其他表单组件，甚至还可以将上面的<code>HOC</code>兼容到<code>span、table</code>等展示组件，这样做可以大大简化代码，让我们省去了很多状态管理的工作，使用如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Form &gt;</span><br><span class="line">        &lt;Input v_model=&quot;name&quot;&gt;&lt;/Input&gt;</span><br><span class="line">        &lt;Input v_model=&quot;pwd&quot;&gt;&lt;/Input&gt;</span><br><span class="line">      &lt;/Form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h3><p>基于上面的双向绑定的例子，我们再来一个表单验证器，表单验证器可以包含验证函数以及提示信息，当验证不通过时，展示错误信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function validateHoc(WrappedComponent) &#123;</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.state = &#123; error: &apos;&apos; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onChange = (event) =&gt; &#123;</span><br><span class="line">      const &#123; validator &#125; = this.props;</span><br><span class="line">      if (validator &amp;&amp; typeof validator.func === &apos;function&apos;) &#123;</span><br><span class="line">        if (!validator.func(event.target.value)) &#123;</span><br><span class="line">          this.setState(&#123; error: validator.msg &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.setState(&#123; error: &apos;&apos; &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;div&gt;</span><br><span class="line">        &lt;WrappedComponent onChange=&#123;this.onChange&#125;  &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;div&gt;&#123;this.state.error || &apos;&apos;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const validatorName = &#123;</span><br><span class="line">  func: (val) =&gt; val &amp;&amp; !isNaN(val),</span><br><span class="line">  msg: &apos;请输入数字&apos;</span><br><span class="line">&#125;</span><br><span class="line">const validatorPwd = &#123;</span><br><span class="line">  func: (val) =&gt; val &amp;&amp; val.length &gt; 6,</span><br><span class="line">  msg: &apos;密码必须大于6位&apos;</span><br><span class="line">&#125;</span><br><span class="line">&lt;HOCInput validator=&#123;validatorName&#125; v_model=&quot;name&quot;&gt;&lt;/HOCInput&gt;</span><br><span class="line">&lt;HOCInput validator=&#123;validatorPwd&#125; v_model=&quot;pwd&quot;&gt;&lt;/HOCInput&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当然，还可以在<code>Form</code>提交的时候判断所有验证器是否通过，验证器也可以设置为数组等等，由于文章篇幅原因，代码被简化了很多，有兴趣的同学可以自己实现。</p><h2 id="Redux-的-connect"><a href="#Redux-的-connect" class="headerlink" title="Redux 的 connect"></a>Redux 的 connect</h2><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a94af19db54?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>redux 中的<code>connect</code>，其实就是一个<code>HOC</code>，下面就是一个简化版的<code>connect</code>实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const connect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; &#123;</span><br><span class="line">  class Connect extends Component &#123;</span><br><span class="line">    static contextTypes = &#123;</span><br><span class="line">      store: PropTypes.object</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor () &#123;</span><br><span class="line">      super()</span><br><span class="line">      this.state = &#123;</span><br><span class="line">        allProps: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillMount () &#123;</span><br><span class="line">      const &#123; store &#125; = this.context</span><br><span class="line">      this._updateProps()</span><br><span class="line">      store.subscribe(() =&gt; this._updateProps())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _updateProps () &#123;</span><br><span class="line">      const &#123; store &#125; = this.context</span><br><span class="line">      let stateProps = mapStateToProps ? mapStateToProps(store.getState(), this.props): &#123;&#125; </span><br><span class="line">      let dispatchProps = mapDispatchToProps? mapDispatchToProps(store.dispatch, this.props) : &#123;&#125; </span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        allProps: &#123;</span><br><span class="line">          ...stateProps,</span><br><span class="line">          ...dispatchProps,</span><br><span class="line">          ...this.props</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render () &#123;</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.state.allProps&#125; /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Connect</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>代码非常清晰，<code>connect</code>函数其实就做了一件事，将<code>mapStateToProps</code>和<code>mapDispatchToProps</code>分别解构后传给原组件，这样我们在原组件内就可以直接用<code>props</code>获取<code>state</code>以及<code>dispatch</code>函数了。</p><h2 id="使用-HOC-的注意事项"><a href="#使用-HOC-的注意事项" class="headerlink" title="使用 HOC 的注意事项"></a>使用 HOC 的注意事项</h2><h3 id="告诫—静态属性拷贝"><a href="#告诫—静态属性拷贝" class="headerlink" title="告诫—静态属性拷贝"></a>告诫—静态属性拷贝</h3><p>当我们应用<code>HOC</code>去增强另一个组件时，我们实际使用的组件已经不是原组件了，所以我们拿不到原组件的任何静态属性，我们可以在<code>HOC</code>的结尾手动拷贝他们：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function proxyHOC(WrappedComponent) &#123;</span><br><span class="line">  class HOCComponent extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  HOCComponent.staticMethod = WrappedComponent.staticMethod;</span><br><span class="line">  // ... </span><br><span class="line">  return HOCComponent;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果原组件有非常多的静态属性，这个过程是非常痛苦的，而且你需要去了解需要增强的所有组件的静态属性是什么，我们可以使用 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fmridgway%2Fhoist-non-react-statics" target="_blank" rel="noopener"><code>hoist-non-react-statics</code></a>来帮助我们解决这个问题，它可以自动帮我们拷贝所有非<code>React</code>的静态方法，使用方式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import hoistNonReactStatic from &apos;hoist-non-react-statics&apos;;</span><br><span class="line">function proxyHOC(WrappedComponent) &#123;</span><br><span class="line">  class HOCComponent extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hoistNonReactStatic(HOCComponent,WrappedComponent);</span><br><span class="line">  return HOCComponent;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="告诫—传递-refs"><a href="#告诫—传递-refs" class="headerlink" title="告诫—传递 refs"></a>告诫—传递 refs</h3><p>使用高阶组件后，获取到的<code>ref</code>实际上是最外层的容器组件，而非原组件，但是很多情况下我们需要用到原组件的<code>ref</code>。</p><p>高阶组件并不能像透传<code>props</code>那样将<code>refs</code>透传，我们可以用一个回调函数来完成<code>ref</code>的传递：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hoc(WrappedComponent) &#123;</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    getWrappedRef = () =&gt; this.wrappedRef;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;WrappedComponent ref=&#123;ref =&gt; &#123; this.wrappedRef = ref &#125;&#125; &#123;...this.props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@hoc</span><br><span class="line">class Input extends Component &#123;</span><br><span class="line">  render() &#123; return &lt;input&gt;&lt;/input&gt; &#125;</span><br><span class="line">&#125;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Input ref=&#123;ref =&gt; &#123; this.inpitRef = ref.getWrappedRef() &#125;&#125; &gt;&lt;/Input&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>React 16.3</code>版本提供了一个<code>forwardRef API</code>来帮助我们进行<code>refs</code>传递，这样我们在高阶组件上获取的<code>ref</code>就是原组件的<code>ref</code>了，而不需要再手动传递，如果你的<code>React</code>版本大于<code>16.3</code>，可以使用下面的方式:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hoc(WrappedComponent) &#123;</span><br><span class="line">  class HOC extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      const &#123; forwardedRef, ...props &#125; = this.props;</span><br><span class="line">      return &lt;WrappedComponent ref=&#123;forwardedRef&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return React.forwardRef((props, ref) =&gt; &#123;</span><br><span class="line">    return &lt;HOC forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="告诫—不要在-render-方法内创建高阶组件"><a href="#告诫—不要在-render-方法内创建高阶组件" class="headerlink" title="告诫—不要在 render 方法内创建高阶组件"></a>告诫—不要在 render 方法内创建高阶组件</h3><p><code>React</code> <code>Diff</code>算法的原则是：</p><ul><li>使用组件标识确定是卸载还是更新组件</li><li>如果组件的和前一次渲染时标识是相同的，递归更新子组件</li><li>如果标识不同卸载组件重新挂载新组件</li></ul><p>每次调用高阶组件生成的都是是一个全新的组件，组件的唯一标识响应的也会改变，如果在<code>render</code>方法调用了高阶组件，这会导致组件每次都会被卸载后重新挂载。</p><h3 id="约定-不要改变原始组件"><a href="#约定-不要改变原始组件" class="headerlink" title="约定 - 不要改变原始组件"></a>约定 - 不要改变原始组件</h3><p>官方文档对高阶组件的说明：</p><blockquote><p>高阶组件就是一个没有副作用的纯函数。</p></blockquote><p>我们再来看看纯函数的定义：</p><blockquote><p>如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。 该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变。</p></blockquote><p>如果我们在高阶组件对原组件进行了修改，例如下面的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputComponent.prototype.componentWillReceiveProps = function(nextProps) &#123; ... &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样就破坏了我们对高阶组件的约定，同时也改变了使用高阶组件的初衷：我们使用高阶组件是为了<code>增强</code>而非<code>改变</code>原组件。</p><h3 id="约定-透传不相关的-props"><a href="#约定-透传不相关的-props" class="headerlink" title="约定 - 透传不相关的 props"></a>约定 - 透传不相关的 props</h3><p>使用高阶组件，我们可以代理所有的<code>props</code>，但往往特定的<code>HOC</code>只会用到其中的一个或几个<code>props</code>。我们需要把其他不相关的<code>props</code>透传给原组件，如下面的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function visible(WrappedComponent) &#123;</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      const &#123; visible, ...props &#125; = this.props;</span><br><span class="line">      if (visible === false) return null;</span><br><span class="line">      return &lt;WrappedComponent &#123;...props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们只使用<code>visible</code>属性来控制组件的显示可隐藏，把其他<code>props</code>透传下去。</p><h3 id="约定-displayName"><a href="#约定-displayName" class="headerlink" title="约定 - displayName"></a>约定 - displayName</h3><p>在使用<code>React Developer Tools</code>进行调试时，如果我们使用了<code>HOC</code>，调试界面可能变得非常难以阅读，如下面的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@visible</span><br><span class="line">class Show extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;我是一个标签&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@visible</span><br><span class="line">class Title extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;我是一个标题&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a94c5d5a8dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>为了方便调试，我们可以手动为<code>HOC</code>指定一个<code>displayName</code>，官方推荐使用<code>HOCName(WrappedComponentName)</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static displayName = `Visible($&#123;WrappedComponent.displayName&#125;)`</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a94cdafad9e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>这个约定帮助确保高阶组件最大程度的灵活性和可重用性。</p><h2 id="使用-HOC-的动机"><a href="#使用-HOC-的动机" class="headerlink" title="使用 HOC 的动机"></a>使用 HOC 的动机</h2><p>回顾下上文提到的 <code>Mixin</code> 带来的风险：</p><ul><li><code>Mixin</code> 可能会相互依赖，相互耦合，不利于代码维护</li><li>不同的<code>Mixin</code>中的方法可能会相互冲突</li><li><code>Mixin</code>非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a94cd939f75?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>而<code>HOC</code>的出现可以解决这些问题：</p><ul><li>高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合</li><li>高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为</li><li>高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担</li></ul><h2 id="HOC-的缺陷"><a href="#HOC-的缺陷" class="headerlink" title="HOC 的缺陷"></a>HOC 的缺陷</h2><ul><li><code>HOC</code>需要在原组件上进行包裹或者嵌套，如果大量使用<code>HOC</code>，将会产生非常多的嵌套，这让调试变得非常困难。</li><li><code>HOC</code>可以劫持<code>props</code>，在不遵守约定的情况下也可能造成冲突。</li></ul><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a94d2268081?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p><code>Hooks</code>是<code>React v16.7.0-alpha</code>中加入的新特性。它可以让你在<code>class</code>以外使用<code>state</code>和其他<code>React</code>特性。</p><p>使用<code>Hooks</code>，你可以在将含有<code>state</code>的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试。同时，<code>Hooks</code>可以帮助你在不重写组件结构的情况下复用这些逻辑。所以，它也可以作为一种实现<code>状态逻辑复用</code>的方案。</p><p>阅读下面的章节<a href="#%E4%BD%BF%E7%94%A8Hook%E7%9A%84%E5%8A%A8%E6%9C%BA">使用 Hook 的动机</a>你可以发现，它可以同时解决<code>Mixin</code>和<code>HOC</code>带来的问题。</p><h2 id="官方提供的-Hooks"><a href="#官方提供的-Hooks" class="headerlink" title="官方提供的 Hooks"></a>官方提供的 Hooks</h2><h3 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h3><p>我们要使用<code>class</code>组件实现一个<code>计数器</code>功能，我们可能会这样写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class Count extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; count: 0 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125;&#125;&gt;</span><br><span class="line">          Click me</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过<code>useState</code>，我们使用函数式组件也能实现这样的功能：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function HookTest() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setNumber(number + 1); &#125;&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>useState</code>是一个钩子，他可以为函数式组件增加一些状态，并且提供改变这些状态的函数，同时它接收一个参数，这个参数作为状态的默认值。</p><h3 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h3><blockquote><p>Effect Hook 可以让你在函数组件中执行一些具有 side effect（副作用）的操作</p></blockquote><p><strong>参数</strong></p><p><code>useEffect</code>方法接收传入两个参数：</p><ul><li><ol><li>回调函数：在第组件一次<code>render</code>和之后的每次<code>update</code>后运行，<code>React</code>保证在<code>DOM</code>已经更新完成之后才会运行回调。</li></ol></li><li><ol start="2"><li>状态依赖 (数组)：当配置了状态依赖项后，只有检测到配置的状态变化时，才会调用回调函数。</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // 只要组件render后就会执行</span><br><span class="line">  &#125;);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // 只有count改变时才会执行</span><br><span class="line">  &#125;,[count]);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>回调返回值</strong></p><p><code>useEffect</code>的第一个参数可以返回一个函数，当页面渲染了下一次更新的结果后，执行下一次<code>useEffect</code>之前，会调用这个函数。这个函数常常用来对上一次调用<code>useEffect</code>进行清理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function HookTest() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;执行...&apos;, count);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      console.log(&apos;清理...&apos;, count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setNumber(number + 1); &#125;&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>执行上面的代码，并点击几次按钮，会得到下面的结果：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a04a94e8279309?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>注意，如果加上浏览器渲染的情况，结果应该是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 页面渲染...1</span><br><span class="line"> 执行... 1</span><br><span class="line"> 页面渲染...2</span><br><span class="line"> 清理... 1</span><br><span class="line"> 执行... 2</span><br><span class="line"> 页面渲染...3</span><br><span class="line"> 清理... 2</span><br><span class="line"> 执行... 3</span><br><span class="line"> 页面渲染...4</span><br><span class="line"> 清理... 3</span><br><span class="line"> 执行... 4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>那么为什么在浏览器渲染完后，再执行清理的方法还能找到上次的<code>state</code>呢？原因很简单，我们在<code>useEffect</code>中返回的是一个函数，这形成了一个闭包，这能保证我们上一次执行函数存储的变量不被销毁和污染。</p><p>你可以尝试下面的代码可能更好理解</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    var flag = 1;</span><br><span class="line">    var clean;</span><br><span class="line">    function effect(flag) &#123;</span><br><span class="line">      return function () &#123;</span><br><span class="line">        console.log(flag);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clean = effect(flag);</span><br><span class="line">    flag = 2;</span><br><span class="line">    clean();</span><br><span class="line">    clean = effect(flag);</span><br><span class="line">    flag = 3;</span><br><span class="line">    clean();</span><br><span class="line">    clean = effect(flag);</span><br><span class="line"></span><br><span class="line">    // 执行结果</span><br><span class="line"></span><br><span class="line">    effect... 1</span><br><span class="line">    clean... 1</span><br><span class="line">    effect... 2</span><br><span class="line">    clean... 2</span><br><span class="line">    effect... 3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>模拟 componentDidMount</strong></p><p><code>componentDidMount</code>等价于<code>useEffect</code>的回调仅在页面初始化完成后执行一次，当<code>useEffect</code>的第二个参数传入一个空数组时可以实现这个效果。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function useDidMount(callback) &#123;</span><br><span class="line">  useEffect(callback, []);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>官方不推荐上面这种写法，因为这有可能导致一些错误。</p></blockquote><p><strong>模拟 componentWillUnmount</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function useUnMount(callback) &#123;</span><br><span class="line">  useEffect(() =&gt; callback, []);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>不像 componentDidMount 或者 componentDidUpdate，useEffect 中使用的 effect 并不会阻滞浏览器渲染页面。这让你的 app 看起来更加流畅。</p></blockquote><h3 id="ref-Hook"><a href="#ref-Hook" class="headerlink" title="ref Hook"></a>ref Hook</h3><p>使用<code>useRef Hook</code>，你可以轻松的获取到<code>dom</code>的<code>ref</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function Input() &#123;</span><br><span class="line">  const inputEl = useRef(null);</span><br><span class="line">  const onButtonClick = () =&gt; &#123;</span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意<code>useRef()</code>并不仅仅可以用来当作获取<code>ref</code>使用，使用<code>useRef</code>产生的<code>ref</code>的<code>current</code>属性是可变的，这意味着你可以用它来保存一个任意值。</p><p><strong>模拟 componentDidUpdate</strong></p><p><code>componentDidUpdate</code>就相当于除去第一次调用的<code>useEffect</code>，我们可以借助<code>useRef</code>生成一个标识，来记录是否为第一次执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function useDidUpdate(callback, prop) &#123;</span><br><span class="line">  const init = useRef(true);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    if (init.current) &#123;</span><br><span class="line">      init.current = false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, prop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="使用-Hook-的注意事项"><a href="#使用-Hook-的注意事项" class="headerlink" title="使用 Hook 的注意事项"></a>使用 Hook 的注意事项</h2><h3 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h3><ul><li>只能在<code>React</code>函数式组件或自定义<code>Hook</code>中使用<code>Hook</code>。</li></ul><p><code>Hook</code>的提出主要就是为了解决<code>class</code>组件的一系列问题，所以我们能在<code>class</code>组件中使用它。</p><h3 id="声明约束"><a href="#声明约束" class="headerlink" title="声明约束"></a>声明约束</h3><ul><li>不要在循环，条件或嵌套函数中调用 Hook。</li></ul><p><code>Hook</code>通过数组实现的，每次<code>useState</code> 都会改变下标，<code>React</code>需要利用调用顺序来正确更新相应的状态，如果<code>useState</code> 被包裹循环或条件语句中，那每就可能会引起调用顺序的错乱，从而造成意想不到的错误。</p><p>我们可以安装一个<code>eslint</code>插件来帮助我们避免这些问题。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 安装</span><br><span class="line">npm install eslint-plugin-react-hooks --save-dev</span><br><span class="line">// 配置</span><br><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    // ...</span><br><span class="line">    &quot;react-hooks&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">    // ...</span><br><span class="line">    &quot;react-hooks/rules-of-hooks&quot;: &quot;error&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h2><p>像上面介绍的<code>HOC</code>和<code>mixin</code>一样，我们同样可以通过自定义的<code>Hook</code>将组件中类似的状态逻辑抽取出来。</p><p>自定义<code>Hook</code>非常简单，我们只需要定义一个函数，并且把相应需要的状态和<code>effect</code>封装进去，同时，<code>Hook</code>之间也是可以相互引用的。使用<code>use</code>开头命名自定义<code>Hook</code>，这样可以方便<code>eslint</code>进行检查。</p><p>下面我们看几个具体的<code>Hook</code>封装：</p><h3 id="日志打点-1"><a href="#日志打点-1" class="headerlink" title="日志打点"></a>日志打点</h3><p>我们可以使用上面封装的生命周期<code>Hook</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const useLogger = (componentName, ...params) =&gt; &#123;</span><br><span class="line">  useDidMount(() =&gt; &#123;</span><br><span class="line">    console.log(`$&#123;componentName&#125;初始化`, ...params);</span><br><span class="line">  &#125;);</span><br><span class="line">  useUnMount(() =&gt; &#123;</span><br><span class="line">    console.log(`$&#123;componentName&#125;卸载`, ...params);</span><br><span class="line">  &#125;)</span><br><span class="line">  useDidUpdate(() =&gt; &#123;</span><br><span class="line">    console.log(`$&#123;componentName&#125;更新`, ...params);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Page1(props)&#123;</span><br><span class="line">  useLogger(&apos;Page1&apos;,props);</span><br><span class="line">  return (&lt;div&gt;...&lt;/div&gt;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="修改-title"><a href="#修改-title" class="headerlink" title="修改 title"></a>修改 title</h3><p>根据不同的页面名称修改页面<code>title</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function useTitle(title) &#123;</span><br><span class="line">  useEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      document.title = title;</span><br><span class="line">      return () =&gt; (document.title = &quot;主页&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">    [title]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">function Page1(props)&#123;</span><br><span class="line">  useTitle(&apos;Page1&apos;);</span><br><span class="line">  return (&lt;div&gt;...&lt;/div&gt;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="双向绑定-1"><a href="#双向绑定-1" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>我们将表单<code>onChange</code>的逻辑抽取出来封装成一个<code>Hook</code>，这样所有需要进行双向绑定的表单组件都可以进行复用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function useBind(init) &#123;</span><br><span class="line">  let [value, setValue] = useState(init);</span><br><span class="line">  let onChange = useCallback(function(event) &#123;</span><br><span class="line">    setValue(event.currentTarget.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  return &#123;</span><br><span class="line">    value,</span><br><span class="line">    onChange</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function Page1(props)&#123;</span><br><span class="line">  let value = useBind(&apos;&apos;);</span><br><span class="line">  return &lt;input &#123;...value&#125; /&gt;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当然，你可以向上面的<code>HOC</code>那样，结合<code>context</code>和<code>form</code>来封装一个更通用的双向绑定，有兴趣可以手动实现一下。</p><h2 id="使用-Hook-的动机"><a href="#使用-Hook-的动机" class="headerlink" title="使用 Hook 的动机"></a>使用 Hook 的动机</h2><h3 id="减少状态逻辑复用的风险"><a href="#减少状态逻辑复用的风险" class="headerlink" title="减少状态逻辑复用的风险"></a>减少状态逻辑复用的风险</h3><p><code>Hook</code>和<code>Mixin</code>在用法上有一定的相似之处，但是<code>Mixin</code>引入的逻辑和状态是可以相互覆盖的，而多个<code>Hook</code>之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。</p><p>在不遵守约定的情况下使用<code>HOC</code>也有可能带来一定冲突，比如<code>props</code>覆盖等等，使用<code>Hook</code>则可以避免这些问题。</p><h3 id="避免地狱式嵌套"><a href="#避免地狱式嵌套" class="headerlink" title="避免地狱式嵌套"></a>避免地狱式嵌套</h3><p>大量使用<code>HOC</code>的情况下让我们的代码变得嵌套层级非常深，使用<code>Hook</code>，我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。</p><h3 id="让组件更容易理解"><a href="#让组件更容易理解" class="headerlink" title="让组件更容易理解"></a>让组件更容易理解</h3><p>在使用<code>class</code>组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个生命周期中会调用越来越多的逻辑，越来越难以维护。使用<code>Hook</code>，可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割。</p><h3 id="使用函数代替-class"><a href="#使用函数代替-class" class="headerlink" title="使用函数代替 class"></a>使用函数代替 class</h3><p>相比函数，编写一个<code>class</code>可能需要掌握更多的知识，需要注意的点也越多，比如<code>this</code>指向、绑定事件等等。另外，计算机理解一个函数比理解一个<code>class</code>更快。<code>Hooks</code>让你可以在<code>classes</code>之外使用更多<code>React</code>的新特性。</p><h2 id="理性的选择"><a href="#理性的选择" class="headerlink" title="理性的选择"></a>理性的选择</h2><p>实际上，<code>Hook</code>在<code>react 16.8.0</code>才正式发布<code>Hook</code>稳定版本，笔者也还未在生产环境下使用，目前笔者在生产环境下使用的最多的是<code>HOC</code>。</p><p><code>React</code>官方完全没有把<code>classes</code>从<code>React</code>中移除的打算，<code>class</code>组件和<code>Hook</code>完全可以同时存在，官方也建议避免任何 “大范围重构”，毕竟这是一个非常新的版本，如果你喜欢它，可以在新的非关键性的代码中使用<code>Hook</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>mixin</code>已被抛弃，<code>HOC</code>正当壮年，<code>Hook</code>初露锋芒，前端圈就是这样，技术迭代速度非常之快，但我们在学习这些知识之时一定要明白为什么要学，学了有没有用，要不要用。不忘初心，方得始终。</p><p>文中如有错误，欢迎在评论区指正，谢谢阅读。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://juejin.im/post/5c71050ef265da2db27938b5" target="_blank" rel="noopener">【React 深入】setState 的执行机制</a></li><li><a href="https://juejin.im/post/5c7df2e7f265da2d8a55d49d" target="_blank" rel="noopener">【React 深入】React 事件机制</a></li></ul>]]></content>
  </entry>
  <entry>
    <title>前端相关文章收藏</title>
    <url>/archives/f37d.html</url>
    <content><![CDATA[<h6 id="前端架构"><a href="#前端架构" class="headerlink" title="前端架构"></a>前端架构</h6><blockquote><p><a href="https://github.com/sorrycc/blog/issues/6" target="_blank" rel="noopener">支付宝前端应用架构的发展和选择</a></p></blockquote>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>文章收藏</tag>
      </tags>
  </entry>
  <entry>
    <title>十个案例学会 React Hooks</title>
    <url>/archives/cca6.html</url>
    <content><![CDATA[<p><a href="https://github.com/happylindz/blog/issues/19" target="_blank" rel="noopener">原文地址</a></p><h1 id="十个案例学会-React-Hooks"><a href="#十个案例学会-React-Hooks" class="headerlink" title="十个案例学会 React Hooks"></a>十个案例学会 React Hooks</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 React 的世界中，有容器组件和 UI 组件之分，在 React Hooks 出现之前，UI 组件我们可以使用函数，无状态组件来展示 UI，而对于容器组件，函数组件就显得无能为力，我们依赖于类组件来获取数据，处理数据，并向下传递参数给 UI 组件进行渲染。在我看来，使用 React Hooks 相比于从前的类组件有以下几点好处：</p><ol><li>代码可读性更强，原本同一块功能的代码逻辑被拆分在了不同的生命周期函数中，容易使开发者不利于维护和迭代，通过 React Hooks 可以将功能代码聚合，方便阅读维护</li><li>组件树层级变浅，在原本的代码中，我们经常使用 HOC/render props 等方式来复用组件的状态，增强功能等，无疑增加了组件树层数及渲染，而在 React Hooks 中，这些功能都可以通过强大的自定义的 Hooks 来实现</li></ol><p>React 在 v16.8 的版本中推出了 React Hooks 新特性，虽然社区还没有最佳实践如何基于 React Hooks 来打造复杂应用(至少我还没有)，凭借着阅读社区中大量的关于这方面的文章，下面我将通过十个案例来帮助你认识理解并可以熟练运用 React Hooks 大部分特性。</p><h2 id="useState-保存组件状态"><a href="#useState-保存组件状态" class="headerlink" title="useState 保存组件状态"></a>useState 保存组件状态</h2><p>在类组件中，我们使用 <code>this.state</code> 来保存组件状态，并对其修改触发组件重新渲染。比如下面这个简单的计数器组件，很好诠释了类组件如何运行：<a href="https://codesandbox.io/s/ojk1oloq9z" target="_blank" rel="noopener">在线 Demo</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span>,</span><br><span class="line">      name: <span class="string">"alife"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Count: &#123;count&#125;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: count + <span class="number">1</span> &#125;)&#125;&gt;+&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: count - 1 &#125;)&#125;&gt;-&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>一个简单的计数器组件就完成了，而在函数组件中，由于没有 this 这个黑魔法，React 通过 useState 来帮我们保存组件的状态。<a href="https://codesandbox.io/s/mj3j955m6x" target="_blank" rel="noopener">在线 Demo</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [obj, setObject] = useState(&#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">    name: <span class="string">"alife"</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      Count: &#123;obj.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setObject(&#123; ...obj, <span class="attr">count</span>: obj.count + <span class="number">1</span> &#125;)&#125;&gt;+&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setObject(&#123; ...obj, count: obj.count - 1 &#125;)&#125;&gt;-&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>通过传入 useState 参数后返回一个带有默认状态和改变状态函数的数组。通过传入新状态给函数来改变原本的状态值。<strong>值得注意的是 useState 不帮助你处理状态，相较于 setState 非覆盖式更新状态，useState 覆盖式更新状态，需要开发者自己处理逻辑。(代码如上)</strong></p><p>似乎有个 useState 后，函数组件也可以拥有自己的状态了，但仅仅是这样完全不够。</p><h2 id="useEffect-处理副作用"><a href="#useEffect-处理副作用" class="headerlink" title="useEffect 处理副作用"></a>useEffect 处理副作用</h2><p>函数组件能保存状态，但是对于异步请求，副作用的操作还是无能为力，所以 React 提供了 useEffect 来帮助开发者处理函数组件的副作用，在介绍新 API 之前，我们先来看看类组件是怎么做的：<a href="https://codesandbox.io/s/y29rwpk3z1" target="_blank" rel="noopener">在线 Demo</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"componentDidMount"</span> + count;</span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function">(<span class="params">&#123; count &#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">        count: count + <span class="number">1</span></span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"componentDidMount"</span> + count;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"componentWillUnmount"</span>;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Count:&#123;count&#125;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; clearInterval(<span class="keyword">this</span>.timer)&#125;&gt;clear&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在例子中，组件每隔一秒更新组件状态，并且每次触发更新都会触发 document.title 的更新(副作用)，而在组件卸载时修改 document.title（类似于清除）</p><p>从例子中可以看到，一些重复的功能开发者需要在 componentDidMount 和 componentDidUpdate 重复编写，而如果使用 useEffect 则完全不一样。<a href="https://codesandbox.io/s/0x1l4kk6lv" target="_blank" rel="noopener">在线 Demo</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">"componentDidMount"</span> + count;</span><br><span class="line">  &#125;,[count]);</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">"componentWillUnmount"</span>;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; clearInterval(timer)&#125;&gt;clear&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 useEffect 重写了上面的例子，useEffect 第一个参数传递函数，可以用来做一些副作用比如异步请求，修改外部参数等行为，而第二个参数是个数组，如果数组中的值才会触发 useEffect 第一个参数中的函数。返回值(如果有)则在组件销毁或者调用函数前调用。</p><ol><li>比如第一个 useEffect 中，理解起来就是一旦 count 值发生改变，则修改 documen.title 值</li><li>而第二个 useEffect 中数组没有传值，代表不监听任何参数变化，即只有在组件初始化或销毁的时候才会触发，用来代替 componentDidMount 和 componentWillUnmount</li></ol><p>基于这个强大 Hooks，我们可以模拟封装出其他生命周期函数，比如 componentDidUpdate 代码十分简单</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useUpdate</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// useRef 创建一个引用</span></span><br><span class="line">    <span class="keyword">const</span> mounting = useRef(<span class="literal">true</span>);</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mounting.current) &#123;</span><br><span class="line">        mounting.current = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fn();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们有了 useState 管理状态，useEffect 处理副作用，异步逻辑，学会这两招足以应对大部分类组件的使用场景。</p><h2 id="useContext-减少组件层级"><a href="#useContext-减少组件层级" class="headerlink" title="useContext 减少组件层级"></a>useContext 减少组件层级</h2><p>上面介绍了 useState、useEffect 这两个最基本的 API，接下来介绍的 useContext 是 React 帮你封装好的，用来处理多层级传递数据的方式，在以前组件树种，跨层级祖先组件想要给孙子组件传递数据的时候，除了一层层 props 往下透传之外，我们还可以使用 React Context API 来帮我们做这件事，举个简单的例子：<a href="https://codesandbox.io/s/94p24or414" target="_blank" rel="noopener">在线 Demo</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext(<span class="literal">null</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Consumer</span>&gt;</span>&#123;color =&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;color&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">Consumer</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Bar</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider value=&#123;<span class="string">"grey"</span>&#125;&gt;</span><br><span class="line">      &lt;Foo /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>通过 React createContext 的语法，在 APP 组件中可以跨过 Foo 组件给 Bar 传递数据。而在 React Hooks 中，我们可以使用 useContext 进行改造。<a href>在线 Demo</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colorContext = React.createContext(<span class="string">"gray"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> color = useContext(colorContext);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;color&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Bar</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;colorContext.Provider value=&#123;<span class="string">"red"</span>&#125;&gt;</span><br><span class="line">      &lt;Foo /&gt;</span><br><span class="line">    &lt;<span class="regexp">/colorContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>传递给 useContext 的是 context 而不是 consumer，返回值即是想要透传的数据了。用法很简单，使用 useContext 可以解决 Consumer 多状态嵌套的问题。<a href="https://daveceddia.com/usecontext-hook/" target="_blank" rel="noopener">参考例子</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HeaderBar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;CurrentUser.Consumer&gt;</span><br><span class="line">      &#123;user =&gt;</span><br><span class="line">        &lt;Notifications.Consumer&gt;</span><br><span class="line">          &#123;notifications =&gt;</span><br><span class="line">            &lt;header&gt;</span><br><span class="line">              Welcome back, &#123;user.name&#125;!</span><br><span class="line">              You have &#123;notifications.length&#125; notifications.</span><br><span class="line">            &lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>CurrentUser.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而使用 useContext 则变得十分简洁，可读性更强且不会增加组件树深度。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HeaderBar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = useContext(CurrentUser);</span><br><span class="line">  <span class="keyword">const</span> notifications = useContext(Notifications);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      Welcome back, &#123;user.name&#125;!</span><br><span class="line">      You have &#123;notifications.length&#125; notifications.</span><br><span class="line">    &lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>useReducer 这个 Hooks 在使用上几乎跟 Redux/React-Redux 一模一样，唯一缺少的就是无法使用 redux 提供的中间件。我们将上述的计时器组件改写为 useReducer，<a href="https://codesandbox.io/s/727o0kr4yx" target="_blank" rel="noopener">在线 Demo</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"increment"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + action.payload &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"decrement"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - action.payload &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">"increment"</span>, <span class="attr">payload</span>: <span class="number">5</span> &#125;)&#125;&gt;</span><br><span class="line">        +</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: "decrement", payload: 5 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        -</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>用法跟 Redux 基本上是一致的，用法也很简单，算是提供一个 mini 的 Redux 版本。</p><h2 id="useCallback-记忆函数"><a href="#useCallback-记忆函数" class="headerlink" title="useCallback 记忆函数"></a>useCallback 记忆函数</h2><p>在类组件中，我们经常犯下面这样的错误：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontSize:</span> <span class="attr">14</span> &#125;&#125; <span class="attr">doSomething</span>=<span class="string">&#123;</span> () =&gt;</span> &#123; console.log('do something'); &#125;&#125;  /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写有什么坏处呢？一旦 App 组件的 props 或者状态改变了就会触发重渲染，即使跟 SomeComponent 组件不相关，由于每次 render 都会产生新的 style 和 doSomething，所以会导致 SomeComponent 重新渲染，倘若 SomeComponent 是一个大型的组件树，这样的 Virtual Dom 的比较显然是很浪费的，解决的办法也很简单，将参数抽离成变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fontSizeStyle = &#123; <span class="attr">fontSize</span>: <span class="number">14</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    doSomething = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'do something'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">style</span>=<span class="string">&#123;fontSizeStyle&#125;</span> <span class="attr">doSomething</span>=<span class="string">&#123;</span> <span class="attr">this.doSomething</span> &#125;  /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类组件中，我们还可以通过 this 这个对象来存储函数，而在函数组件中没办法进行挂载了。所以函数组件在每次渲染的时候如果有传递函数的话都会重渲染子组件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Click happened'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">SomeComponent</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而有了 useCallback 就不一样了，你可以通过 useCallback 获得一个记忆后的函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedHandleClick = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Click happened'</span>)</span><br><span class="line">  &#125;, []); <span class="comment">// 空数组代表无论什么情况下该函数都不会发生改变</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">onClick</span>=<span class="string">&#123;memoizedHandleClick&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">SomeComponent</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老规矩，第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。</p><p>这样只要子组件继承了 PureComponent 或者使用 React.memo 就可以有效避免不必要的 VDOM 渲染。</p><h2 id="useMemo-记忆组件"><a href="#useMemo-记忆组件" class="headerlink" title="useMemo 记忆组件"></a>useMemo 记忆组件</h2><p>useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useCallback(fn, inputs) is equivalent to useMemo(() =&gt; fn, inputs).</span><br></pre></td></tr></table></figure><p>所以前面使用 useCallback 的例子可以使用 useMemo 进行改写：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedHandleClick = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Click happened'</span>)</span><br><span class="line">  &#125;, []); <span class="comment">// 空数组代表无论什么情况下该函数都不会发生改变</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">onClick</span>=<span class="string">&#123;memoizedHandleClick&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">SomeComponent</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一的区别是：<strong>useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你。</strong>所以在前面的例子中，可以返回 handleClick 来达到存储函数的目的。</p><p>所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Only re-rendered if `a` changes:</span></span><br><span class="line">  <span class="keyword">const</span> child1 = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Child1</span> <span class="attr">a</span>=<span class="string">&#123;a&#125;</span> /&gt;</span></span>, [a]);</span><br><span class="line">  <span class="comment">// Only re-rendered if `b` changes:</span></span><br><span class="line">  <span class="keyword">const</span> child2 = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Child2</span> <span class="attr">b</span>=<span class="string">&#123;b&#125;</span> /&gt;</span></span>, [b]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;child1&#125;</span><br><span class="line">      &#123;child2&#125;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>当 a/b 改变时，child1/child2 才会重新渲染。从例子可以看出来，只有在第二个参数数组的值发生变化时，才会触发子组件的更新。</p><h2 id="useRef-保存引用值"><a href="#useRef-保存引用值" class="headerlink" title="useRef 保存引用值"></a>useRef 保存引用值</h2><p>useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用，看个简单的例子：<a href="https://codesandbox.io/s/v6948pww5y?from-embed" target="_blank" rel="noopener">在线 Demo</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useRef &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [name, setName] = useState(<span class="string">"Nate"</span>);</span><br><span class="line">  <span class="keyword">let</span> nameRef = useRef();</span><br><span class="line">  <span class="keyword">const</span> submitButton = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setName(nameRef.current.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input ref=&#123;nameRef&#125; type="text" /</span>&gt;</span><br><span class="line">        &lt;button type=<span class="string">"button"</span> onClick=&#123;submitButton&#125;&gt;</span><br><span class="line">          Submit</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值访问组件或真实的 DOM 节点，从而可以对 DOM 进行一些操作，比如监听事件等等。</p><p>当然 useRef 远比你想象中的功能更加强大，useRef 的功能有点像类属性，或者说您想要在组件中记录一些值，并且这些值在稍后可以更改。</p><p>利用 useRef 就可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个 Render 间存在隔离。参考例子：<a href="https://juejin.im/post/5c8eec1bf265da67cb619e79" target="_blank" rel="noopener">精读《Function VS Class 组件》</a></p><p>React Hooks 中存在 Capture Value 的特性：<a href="https://codesandbox.io/s/93m5mz9w24" target="_blank" rel="noopener">在线 Demo</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MessageThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [message, setMessage] = useState(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> showMessage = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">"You said: "</span> + message);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleSendClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(showMessage, <span class="number">3000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleMessageChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    setMessage(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input value=&#123;message&#125; onChange=&#123;handleMessageChange&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleSendClick&#125;&gt;Send&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在点击 Send 按钮后，再次修改输入框的值，3 秒后的输出依然是点击前输入框的值。这就是所谓的 capture value 的特性。而在类组件中 3 秒后输出的就是修改后的值，因为这时候 message 是挂载在 this 变量上，它保留的是一个引用值，对 this 属性的访问都会获取到最新的值。讲到这里你应该就明白了，useRef 创建一个引用，就可以有效规避 React Hooks 中 Capture Value 特性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MessageThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> latestMessage = useRef(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> showMessage = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">"You said: "</span> + latestMessage.current);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleSendClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(showMessage, <span class="number">3000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleMessageChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    latestMessage.current = e.target.value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要将赋值与取值的对象变成 useRef，而不是 useState，就可以躲过 capture value 特性，在 3 秒后得到最新的值。</p><h2 id="useImperativeHandle-透传-Ref"><a href="#useImperativeHandle-透传-Ref" class="headerlink" title="useImperativeHandle 透传 Ref"></a>useImperativeHandle 透传 Ref</h2><p>通过 useImperativeHandle 用于让父组件获取子组件内的索引 <a href="https://codesandbox.io/s/m7wxjz5j3j" target="_blank" rel="noopener">在线 Demo</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef, useEffect, useImperativeHandle, forwardRef &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildInputComponent</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef(<span class="literal">null</span>);</span><br><span class="line">  useImperativeHandle(ref, () =&gt; inputRef.current);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"child input"</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ChildInput = forwardRef(ChildInputComponent);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ChildInput ref=&#123;inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>通过这种方式，App 组件可以获得子组件的 input 的 DOM 节点。</p><h2 id="useLayoutEffect-同步执行副作用"><a href="#useLayoutEffect-同步执行副作用" class="headerlink" title="useLayoutEffect 同步执行副作用"></a>useLayoutEffect 同步执行副作用</h2><p>大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。<a href="https://codesandbox.io/s/74myo7w94q" target="_blank" rel="noopener">在线 Demo</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [width, setWidth] = useState(<span class="number">0</span>);</span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> title = <span class="built_in">document</span>.querySelector(<span class="string">"#title"</span>);</span><br><span class="line">    <span class="keyword">const</span> titleWidth = title.getBoundingClientRect().width;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"useLayoutEffect"</span>);</span><br><span class="line">    <span class="keyword">if</span> (width !== titleWidth) &#123;</span><br><span class="line">      setWidth(titleWidth);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"useEffect"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1 id=<span class="string">"title"</span>&gt;hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;&#123;width&#125;&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，useLayoutEffect 会在 render，DOM 更新之后同步触发函数，会优于 useEffect 异步触发函数。</p><h2 id="React-Hooks-不足"><a href="#React-Hooks-不足" class="headerlink" title="React Hooks 不足"></a>React Hooks 不足</h2><p>尽管我们通过上面的例子看到 React Hooks 的强大之处，似乎类组件完全都可以使用 React Hooks 重写。但是当下 v16.8 的版本中，还无法实现 getSnapshotBeforeUpdate 和 componentDidCatch 这两个在类组件中的生命周期函数。官方也计划在不久的将来在 React Hooks 进行实现。</p>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
        <category>React Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>图解7种耦合关系</title>
    <url>/archives/7e29.html</url>
    <content><![CDATA[<p>深入讲讲模块之间的耦合关系这个事情。</p><p>本文将用图文详细讲解七种耦合的不同之处。</p><h2 id="高内聚与低耦合"><a href="#高内聚与低耦合" class="headerlink" title="高内聚与低耦合"></a>高内聚与低耦合</h2><p>高内聚与低耦合是每个软件开发者追求的目标，那么内聚和耦合分别是什么意思呢？</p><p><img src="!--￼0--&gt;416.png" alt></p><blockquote><p>内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</p></blockquote><blockquote><p>耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</p></blockquote><h2 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h2><p>不同模块之间的关系就是耦合，根据耦合程度可以分为7种，耦合度依次变低。</p><ul><li>内容耦合</li><li>公共耦合</li><li>外部耦合</li><li>控制耦合</li><li>标记耦合</li><li>数据耦合</li><li>非直接耦合</li></ul><p>下面我们来说说每种耦合是什么，开始之前先来说下要实现的功能。m1和m2是两个独立的模块，其中m2种会显示m1的输入，m1会显示m2的输入。</p><p><img src="!--￼1--&gt;417.png" alt></p><p>很显然，m1和m2两个模块之间会有一些联系（耦合），你也可以想想如何实现这个功能，下面用7种不同的方式来实现这个功能。</p><p><strong>注：</strong>项目的代码我放到了<a href="https://github.com/yanhaijing/coupling" target="_blank" rel="noopener">github</a>，项目的demo，可以在<a href="http://yanhaijing.com/coupling/" target="_blank" rel="noopener">这里查看</a>。</p><h3 id="内容耦合"><a href="#内容耦合" class="headerlink" title="内容耦合"></a>内容耦合</h3><p>内容耦合是最紧的耦合程度，一个模块直接访问另一模块的内容，则称这两个模块为内容耦合。</p><p><img src="!--￼2--&gt;418.png" alt></p><p>为了实现功能，我们将m1的输入放到m2.m1input上，将m2的输入放到m1.m2input上。</p><pre><code>// m1.js
root.m2.m1input = this.value;
m2.update();

// m2.js
root.m1.m2input = this.value;
m1.update();
</code></pre><p><strong>PS:</strong>不知道谁会这么写代码，除了我为了做演示之外。。。</p><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo1" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo1/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="公共耦合"><a href="#公共耦合" class="headerlink" title="公共耦合"></a>公共耦合</h3><p>一组模块都访问同一个全局数据结构，则称之为公共耦合。</p><p><img src="!--￼3--&gt;419.png" alt></p><p>在这种case中，m1和m2将自己的输入放到全局的data上。</p><pre><code>// m1.js
root.data.m1input = this.value;
m2.update();

// m2.js
root.data.m2input = this.value;
m1.update();
</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo2" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo2/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="外部耦合"><a href="#外部耦合" class="headerlink" title="外部耦合"></a>外部耦合</h3><p>一组模块都访问同一全局简单变量，而且不通过参数表传递该全局变量的信息，则称之为外部耦合。外部耦合和公共耦合很像，区别就是一个是简单变量，一个是复杂数据结构。</p><p><img src="!--￼4--&gt;420.png" alt></p><p>在这种case中，m1和m2都将自己的输入放到全局上。</p><pre><code>// m1.js
root.m1input = this.value;
m2.update();

// m2.js
root.m2input = this.value;
m1.update();
</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo3" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo3/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="控制耦合"><a href="#控制耦合" class="headerlink" title="控制耦合"></a>控制耦合</h3><p>模块之间传递的不是数据信息，而是控制信息例如标志、开关量等，一个模块控制了另一个模块的功能。</p><p>从控制耦合开始，模块的数据就放在自己内部了，不同模块之间通过接口互相调用。</p><p><img src="!--￼5--&gt;421.png" alt></p><p>在这个case中，得增加一个需求，就是当m1的输入为空时，隐藏m2的显示信息。</p><pre><code>// m1.js
root.m1input = this.value;
m2.update();

m2.toggle(!!this.value); // 传递flag
</code></pre><p>上面的代码中m1直接控制了m2的显示和隐藏。</p><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo4" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo4/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="标记耦合"><a href="#标记耦合" class="headerlink" title="标记耦合"></a>标记耦合</h3><p>调用模块和被调用模块之间传递数据结构而不是简单数据，同时也称作特征耦合。</p><p><img src="!--￼6--&gt;422.png" alt></p><p>在这个case中，m1传给m2的是一个对象。</p><pre><code>// m1.js
me.m1input = this.value;
m2.update(me); // 传递引用

// m2.js
me.m2input = this.value;
m1.update(me);
</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo5" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo5/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="数据耦合"><a href="#数据耦合" class="headerlink" title="数据耦合"></a>数据耦合</h3><p>调用模块和被调用模块之间只传递简单的数据项参数。相当于高级语言中的值传递。</p><p><img src="!--￼7--&gt;423.png" alt></p><p>在这个case中，m1传给m2的是一个简单数据结构。</p><pre><code>// m1.js
me.m1input = this.value;
m2.update(me.m1input); // 传递值

// m2.js
me.m2input = this.value;
m1.update(me.m2input);
</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo6" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo6/demo.html" target="_blank" rel="noopener">demo</a>。</p><h3 id="非直接耦合"><a href="#非直接耦合" class="headerlink" title="非直接耦合"></a>非直接耦合</h3><p>两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。耦合度最弱，模块独立性最强。</p><p>子模块无需知道对方的存在，子模块之间的联系，全部变成子模块和主模块之间的联系。</p><p><img src="!--￼8--&gt;424.png" alt></p><p>在这个case种，增加一个index.js作为主模块。</p><pre><code>// index.js
var m1 = root.m1;
var m2 = root.m2;

m1.init(function (str) {
    m2.update(str);
});

m2.init(function (str) {
    m1.update(str);
});

// m1.js
me.m1input = this.value;
inputcb(me.m1input); // inputcb是回调函数

// m2.js
me.m2input = this.value;
inputcb(me.m2input);
</code></pre><p>查看<a href="https://github.com/yanhaijing/coupling/tree/gh-pages/demo7" target="_blank" rel="noopener">完整代码</a>和<a href="http://yanhaijing.com/coupling/demo7/demo.html" target="_blank" rel="noopener">demo</a>。</p><h2 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h2><p>其实关于内聚也分为很多种，如下所示，如果你感兴趣可以自己研究研究，我们下次再来分享内聚的问题。</p><ul><li>偶然内聚</li><li>逻辑内聚</li><li>时间内聚</li><li>通信内聚</li><li>顺序内聚</li><li>功能内聚</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望你看完上面的文章，搞懂了耦合的种类，也希望你以后能使用非直接耦合这种方式来写代码，祝好。</p>]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>在浏览器输入 URL 回车之后发生了什么（超详细版）</title>
    <url>/archives/ab98.html</url>
    <content><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://4ark.me/post/b6c7c0a2.html#3-%E6%B8%B2%E6%9F%93%E6%A0%91" target="_blank" rel="noopener">https://4ark.me/post/b6c7c0a2.html#3-%E6%B8%B2%E6%9F%93%E6%A0%91</a></p></blockquote><p>这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a href="#前言" title="前言"></a>前言</h2><p>这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。</p><p>这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅，</p><p><strong>注意：</strong>本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。</p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a><a href="#大致流程" title="大致流程"></a>大致流程</h2><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><h2 id="一、URL-解析"><a href="#一、URL-解析" class="headerlink" title="一、URL 解析"></a><a href="#一、URL-解析" title="一、URL 解析"></a>一、URL 解析</h2><p><strong>地址解析：</strong></p><p>首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p><p><strong>HSTS</strong></p><p>由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：<a href="https://www.barretlee.com/blog/2015/10/22/hsts-intro/" target="_blank" rel="noopener">你所不知道的 HSTS</a>。</p><p><strong>其他操作</strong></p><p>浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p><p><strong>检查缓存</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822181538.png" alt></p><h2 id="二、DNS-查询"><a href="#二、DNS-查询" class="headerlink" title="二、DNS 查询"></a><a href="#二、DNS-查询" title="二、DNS 查询"></a>二、DNS 查询</h2><p><strong>基本步骤</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822181732.png" alt></p><p><strong>1. 浏览器缓存</strong></p><p>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p><p><strong>2. 操作系统缓存</strong></p><p>操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p><p><strong>3. 路由器缓存</strong></p><p>路由器也有自己的缓存。</p><p><strong>4. ISP DNS 缓存</strong></p><p>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p><p><strong>根域名服务器查询</strong></p><p>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/1604181361-5a1397cca5644_articlex.png" alt></p><blockquote><p>根域名服务器：<a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8" target="_blank" rel="noopener">维基百科</a></p></blockquote><p><strong>需要注意的点</strong></p><ol><li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地 DNS 服务器的过程）</li><li>迭代方式，就是本地 DNS 服务器到根域名服务器查询的方式。</li><li>什么是 DNS 劫持</li><li>前端 dns-prefetch 优化</li></ol><h2 id="三、TCP-连接"><a href="#三、TCP-连接" class="headerlink" title="三、TCP 连接"></a><a href="#三、TCP-连接" title="三、TCP 连接"></a>三、TCP 连接</h2><p>TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822182400.png" alt></p><h3 id="1-应用层：发送-HTTP-请求"><a href="#1-应用层：发送-HTTP-请求" class="headerlink" title="1. 应用层：发送 HTTP 请求"></a><a href="#1-应用层：发送-HTTP-请求" title="1. 应用层：发送 HTTP 请求"></a><strong>1. 应用层：发送 HTTP 请求</strong></h3><p>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p><ul><li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li><li>请求主体（其他参数）</li></ul><p>其中需要注意的点：</p><ul><li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li></ul><h3 id="2-传输层：TCP-传输报文"><a href="#2-传输层：TCP-传输报文" class="headerlink" title="2. 传输层：TCP 传输报文"></a><a href="#2-传输层：TCP-传输报文" title="2. 传输层：TCP 传输报文"></a><strong>2. 传输层：TCP 传输报文</strong></h3><p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。</p><p>在建立连接前，会先进行 TCP 三次握手。</p><blockquote><p>关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。</p><p>相关知识点：</p><ol><li>SYN 泛洪攻击</li></ol></blockquote><h3 id="3-网络层：IP-协议查询-Mac-地址"><a href="#3-网络层：IP-协议查询-Mac-地址" class="headerlink" title="3. 网络层：IP 协议查询 Mac 地址"></a><a href="#3-网络层：IP协议查询Mac地址" title="3. 网络层：IP协议查询Mac地址"></a><strong>3. 网络层：IP 协议查询 Mac 地址</strong></h3><p>将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线。</p><p>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p><blockquote><p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p></blockquote><h3 id="4-链路层：以太网协议"><a href="#4-链路层：以太网协议" class="headerlink" title="4. 链路层：以太网协议"></a><a href="#4-链路层：以太网协议" title="4. 链路层：以太网协议"></a><strong>4. 链路层：以太网协议</strong></h3><p><strong>以太网协议</strong></p><p>根据以太网协议将数据分为以 “帧” 为单位的数据包，每一帧分为两个部分：</p><ul><li>标头：数据包的发送者、接受者、数据类型</li><li>数据：数据包具体内容</li></ul><p><strong>Mac 地址</strong></p><p>以太网规定了连入网络的所有设备都必须具备 “网卡” 接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p><p><strong>广播</strong></p><p>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p><p><strong>注意</strong>：接收方回应是单播。</p><blockquote><p>相关知识点：</p><ol><li>ARP 攻击</li></ol></blockquote><h4 id="服务器接受请求"><a href="#服务器接受请求" class="headerlink" title="服务器接受请求"></a><a href="#服务器接受请求" title="服务器接受请求"></a><strong>服务器接受请求</strong></h4><p>接受过程就是把以上步骤逆转过来，参见上图。</p><h2 id="四、服务器处理请求"><a href="#四、服务器处理请求" class="headerlink" title="四、服务器处理请求"></a><a href="#四、服务器处理请求" title="四、服务器处理请求"></a>四、服务器处理请求</h2><p><strong>大致流程</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822183251.png" alt></p><p><strong>HTTPD</strong></p><p>最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。</p><p>它会监听得到的请求，然后开启一个子进程去处理这个请求。</p><p><strong>处理请求</strong></p><p>接受 TCP 报文后，会对连接进行处理，对 HTTP 协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p><ul><li>验证是否配置虚拟主机</li><li>验证虚拟主机是否接受此方法</li><li>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</li></ul><p><strong>重定向</strong></p><p>假如服务器配置了 HTTP 重定向，就会返回一个 <code>301</code>永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p><blockquote><p>关于更多：<a href="https://www.cnblogs.com/workest/p/3891321.html" target="_blank" rel="noopener">详见这篇文章</a></p></blockquote><p><strong>URL 重写</strong></p><p>然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js 文件等，则会直接把这个文件返回。</p><p>否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。</p><p>然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。</p><p>以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p><h2 id="五、浏览器接受响应"><a href="#五、浏览器接受响应" class="headerlink" title="五、浏览器接受响应"></a><a href="#五、浏览器接受响应" title="五、浏览器接受响应"></a>五、浏览器接受响应</h2><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。</p><p>首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。</p><p>如果响应资源进行了压缩（比如 gzip），还需要进行解压。</p><p>然后，对响应资源做缓存。</p><p>接下来，根据响应资源里的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener">MIME</a> 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。</p><h2 id="六、渲染页面"><a href="#六、渲染页面" class="headerlink" title="六、渲染页面"></a><a href="#六、渲染页面" title="六、渲染页面"></a>六、渲染页面</h2><p><strong>浏览器内核</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/961f7b5d-9e06-4006-ab99-974e8e9e2ba5.png" alt></p><p>不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p><p><strong>基本流程</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822183712.png" alt></p><h3 id="1-HTML-解析"><a href="#1-HTML-解析" class="headerlink" title="1.HTML 解析"></a><a href="#1-HTML-解析" title="1.HTML 解析"></a><strong>1.HTML 解析</strong></h3><p>首先要知道浏览器解析是从上往下一行一行地解析的。</p><p>解析的过程可以分为四个步骤：</p><p><strong>1. 解码（encoding）</strong></p><p>传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如 UTF-8）转换成字符串，也就是 HTML 代码。</p><p><strong>2. 预解析（pre-parsing）</strong></p><p>预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如<code>img</code>标签的<code>src</code>属性，并将这个请求加到请求队列中。</p><p><strong>3. 符号化（Tokenization）</strong></p><p>符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。</p><p>它通过一个状态机去识别符号的状态，比如遇到<code>&lt;</code>，<code>&gt;</code>状态都会产生变化。</p><p><strong>4. 构建树（tree construction）</strong></p><blockquote><p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p></blockquote><p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建<code>DOM</code>对象并把这些符号插入到<code>DOM</code>对象中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Web page parsing&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Web page parsing&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;This is an example Web page.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/1355879024-573db51949951_articlex.png" alt></p><p><strong>浏览器容错进制</strong></p><p>你从来没有在浏览器看过类似” 语法无效” 的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p><p><strong>事件</strong></p><p>当整个解析的过程完成以后，浏览器会通过<code>DOMContentLoaded</code>事件来通知<code>DOM</code>解析完成。</p><h3 id="2-CSS-解析"><a href="#2-CSS-解析" class="headerlink" title="2. CSS 解析"></a><a href="#2-CSS-解析" title="2. CSS 解析"></a>2. CSS 解析</h3><p>一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据<a href="https://drafts.csswg.org/css-syntax-3/" target="_blank" rel="noopener">语法规范</a>解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p><p><strong>CSS 匹配规则</strong></p><p>在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：<code>div p { font-size :14px }</code>会先寻找所有的<code>p</code>标签然后判断它的父元素是否为<code>div</code>。</p><p>所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。</p><h3 id="3-渲染树"><a href="#3-渲染树" class="headerlink" title="3. 渲染树"></a><a href="#3-渲染树" title="3. 渲染树"></a>3. 渲染树</h3><p>其实这就是一个 DOM 树和 CSS 规则树合并的过程。</p><blockquote><p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了<code>display:none</code>的节点。</p></blockquote><p><strong>计算</strong></p><p>通过计算让任何尺寸值都减少到三个可能之一：<code>auto</code>、百分比、px，比如把<code>rem</code>转化为<code>px</code>。</p><p><strong>级联</strong></p><p>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做<code>specificity</code>的公式，这个公式会通过：</p><ol><li>标签名、class、id</li><li>是否内联样式</li><li><code>!important</code></li></ol><p>然后得出一个权重值，取最高的那个。</p><p><strong>渲染阻塞</strong></p><p>当遇到一个<code>script</code>标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。</p><p>但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。</p><p>所有我们知道：</p><ul><li>CSS 会阻塞 JS 执行</li><li>JS 会阻塞后面的 DOM 解析</li></ul><p>为了避免这种情况，应该以下原则：</p><ul><li>CSS 资源排在 JavaScript 资源前面</li><li>JS 放在 HTML 最底部，也就是 <code>&lt;/body&gt;</code>前</li></ul><p>另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：<a href="https://github.com/xiaoyu2er/blog/issues/8" target="_blank" rel="noopener">这篇文章</a></p><h4 id="4-布局与绘制"><a href="#4-布局与绘制" class="headerlink" title="4. 布局与绘制"></a><a href="#4-布局与绘制" title="4. 布局与绘制"></a>4. 布局与绘制</h4><p>确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。</p><p>然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p><h4 id="5-合并渲染层"><a href="#5-合并渲染层" class="headerlink" title="5. 合并渲染层"></a><a href="#5-合并渲染层" title="5. 合并渲染层"></a><strong>5. 合并渲染层</strong></h4><p>把以上绘制的所有图片合并，最终输出一张图片。</p><h4 id="6-回流与重绘"><a href="#6-回流与重绘" class="headerlink" title="6. 回流与重绘"></a><a href="#6-回流与重绘" title="6. 回流与重绘"></a><strong>6. 回流与重绘</strong></h4><p><strong>回流 (reflow)</strong></p><p>当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从<code>html</code>标签开始递归往下，重新计算位置和大小。</p><p>reflow 基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p><p><strong>重绘 (repaint)</strong></p><p>改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。</p><p>每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。</p><p>回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。</p><p>比如：</p><ul><li><code>display:none</code> 会触发回流，而 <code>visibility:hidden</code> 只会触发重绘。</li></ul><h4 id="7-JavaScript-编译执行"><a href="#7-JavaScript-编译执行" class="headerlink" title="7. JavaScript 编译执行"></a><a href="#7-JavaScript-编译执行" title="7. JavaScript 编译执行"></a>7. JavaScript 编译执行</h4><p><strong>大致流程</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822184523.png" alt></p><p>可以分为三个阶段：</p><h4 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a><a href="#1-词法分析" title="1. 词法分析"></a><strong>1. 词法分析</strong></h4><p>JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出 “语法错误”，停止执行。</p><p>几个步骤：</p><ul><li>分词，例如将<code>var a = 2</code>，，分成<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>这样的词法单元。</li><li>解析，将词法单元转换成抽象语法树（AST）。</li><li>代码生成，将抽象语法树转换成机器指令。</li></ul><h4 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a><a href="#2-预编译" title="2. 预编译"></a><strong>2. 预编译</strong></h4><p>JS 有三种运行环境：</p><ul><li>全局环境</li><li>函数环境</li><li>eval</li></ul><p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p><p><strong>创建执行上下文</strong></p><p>创建执行上下文的过程中，主要做了以下三件事：</p><ul><li>创建变量对象<ul><li>参数、函数、变量</li></ul></li><li>建立作用域链<ul><li>确认当前执行环境是否能访问变量</li></ul></li><li>确定 This 指向</li></ul><h4 id="3-执行"><a href="#3-执行" class="headerlink" title="3. 执行"></a><a href="#3-执行" title="3. 执行"></a><strong>3. 执行</strong></h4><p><strong>JS 线程</strong></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822184731.png" alt></p><p>虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p><blockquote><p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p></blockquote><ul><li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li><li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li><li>定时器触发线程：主要控制<code>setInterval</code>和<code>setTimeout</code>，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li><li>HTTP 异步请求线程：通过 XMLHttpRequest 连接后，通过浏览器新开的一个线程，监控 readyState 状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待 JS 引擎线程执行。</li></ul><p><strong>注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。</strong></p><p><strong>宏任务</strong></p><p>分为：</p><ul><li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li><li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待 JS 引擎主线程上的任务执行完毕时才开始执行，例如异步 Ajax、DOM 事件，setTimeout 等。</li></ul><p><strong>微任务</strong></p><p>微任务是 ES6 和 Node 环境下的，主要 API 有：<code>Promise</code>，<code>process.nextTick</code>。</p><p>微任务的执行在宏任务的同步任务之后，在异步任务之前。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822185002.png" alt></p><p><strong>代码例子</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&apos;1&apos;); // 宏任务 同步</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;2&apos;); // 宏任务 异步</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&apos;3&apos;); // 宏任务 同步</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&apos;4&apos;) // 微任务</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;5&apos;) // 宏任务 同步</span><br></pre></td></tr></table></figure><p>以上代码输出顺序为：1,3,5,4,2</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><a href="#参考文档" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="noopener">what-happens-when-zh_CN</a></li><li><a href="https://alistapart.com/article/tags-to-dom/" target="_blank" rel="noopener">Tags to DOM</a></li><li><a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">彻底理解浏览器的缓存机制</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_rendering_engine" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li><li><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/" target="_blank" rel="noopener">深入浅出浏览器渲染原理</a></li><li><a href="https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/#%E9%A2%84%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5" target="_blank" rel="noopener">js 引擎的执行过程（一）</a></li><li>还有一些找不到了。。。。。</li></ul>]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 React 性能优化的方向</title>
    <url>/archives/6df4.html</url>
    <content><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.im/post/5d045350f265da1b695d5bf2" target="_blank" rel="noopener">https://juejin.im/post/5d045350f265da1b695d5bf2</a></p></blockquote><p>本文来源于公司内部的一次闪电分享，稍作润色分享出来。主要讨论 React 性能优化的主要方向和一些小技巧。<strong>如果你觉得可以，请多点赞，鼓励我写出更精彩的文章</strong>🙏。</p><p>React 渲染性能优化的三个方向，其实也适用于其他软件开发领域，这三个方向分别是:</p><ul><li><strong>减少计算的量</strong>。 -&gt; 对应到 React 中就是<strong>减少渲染的节点 或者 降低组件渲染的复杂度</strong></li><li><strong>利用缓存</strong>。-&gt; 对应到 React 中就是<strong>如何避免重新渲染，利用函数式编程的 memo 方式来避免组件重新渲染</strong></li><li><strong>精确重新计算的范围</strong>。 对应到 React 中就是<strong>绑定组件和状态关系, 精确判断更新的’时机’和’范围’. 只重新渲染’脏’的组件，或者说降低渲染范围</strong></li></ul><p><strong>目录</strong></p><ul><li><a href="#%E5%87%8F%E5%B0%91%E6%B8%B2%E6%9F%93%E7%9A%84%E8%8A%82%E7%82%B9%E9%99%8D%E4%BD%8E%E6%B8%B2%E6%9F%93%E8%AE%A1%E7%AE%97%E9%87%8F%E5%A4%8D%E6%9D%82%E5%BA%A6">减少渲染的节点 / 降低渲染计算量 (复杂度)</a><ul><li><a href="#0%EF%B8%8F%E2%83%A3-%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0%E9%83%BD%E8%BF%9B%E8%A1%8C%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E8%AE%A1%E7%AE%97">0️⃣ 不要在渲染函数都进行不必要的计算</a></li><li><a href="#1%EF%B8%8F%E2%83%A3-%E5%87%8F%E5%B0%91%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%B5%8C%E5%A5%97">1️⃣ 减少不必要的嵌套</a></li><li><a href="#2%EF%B8%8F%E2%83%A3-%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8">2️⃣ 虚拟列表</a></li><li><a href="#3%EF%B8%8F%E2%83%A3-%E6%83%B0%E6%80%A7%E6%B8%B2%E6%9F%93">3️⃣ 惰性渲染</a></li><li><a href="#4%EF%B8%8F%E2%83%A3-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%A0%B7%E5%BC%8F%E6%96%B9%E6%A1%88">4️⃣ 选择合适的样式方案</a></li></ul></li><li><a href="#%E9%81%BF%E5%85%8D%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93">避免重新渲染</a><ul><li><a href="#0%EF%B8%8F%E2%83%A3-%E7%AE%80%E5%8C%96-props">0️⃣ 简化 props</a></li><li><a href="#1%EF%B8%8F%E2%83%A3-%E4%B8%8D%E5%8F%98%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8">1️⃣ 不变的事件处理器</a></li><li><a href="#2%EF%B8%8F%E2%83%A3-%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE">2️⃣ 不可变数据</a></li><li><a href="#3%EF%B8%8F%E2%83%A3-%E7%AE%80%E5%8C%96-state">3️⃣ 简化 state</a></li><li><a href="#4%EF%B8%8F%E2%83%A3-%E4%BD%BF%E7%94%A8-recompose-%E7%B2%BE%E7%BB%86%E5%8C%96%E6%AF%94%E5%AF%B9">4️⃣ 使用 recompose 精细化比对</a></li></ul></li><li><a href="#%E7%B2%BE%E7%BB%86%E5%8C%96%E6%B8%B2%E6%9F%93">精细化渲染</a><ul><li><a href="#0%EF%B8%8F%E2%83%A3-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B2%BE%E7%BB%86%E5%8C%96%E6%B8%B2%E6%9F%93">0️⃣ 响应式数据的精细化渲染</a></li><li><a href="#1%EF%B8%8F%E2%83%A3-%E4%B8%8D%E8%A6%81%E6%BB%A5%E7%94%A8-context">1️⃣ 不要滥用 Context</a></li></ul></li><li><a href="#%E6%89%A9%E5%B1%95">扩展</a></li></ul><h2 id="减少渲染的节点-降低渲染计算量-复杂度"><a href="#减少渲染的节点-降低渲染计算量-复杂度" class="headerlink" title="减少渲染的节点 / 降低渲染计算量 (复杂度)"></a>减少渲染的节点 / 降低渲染计算量 (复杂度)</h2><p>首先从计算的量上下功夫，减少节点渲染的数量或者降低渲染的计算量可以显著的提高组件渲染性能。</p><h3 id="0️⃣-不要在渲染函数都进行不必要的计算"><a href="#0️⃣-不要在渲染函数都进行不必要的计算" class="headerlink" title="0️⃣ 不要在渲染函数都进行不必要的计算"></a>0️⃣ 不要在渲染函数都进行不必要的计算</h3><p>比如不要在渲染函数 (render) 中进行数组排序、数据转换、订阅事件、创建事件处理器等等. <strong>渲染函数中不应该放置太多副作用</strong></p><h3 id="1️⃣-减少不必要的嵌套"><a href="#1️⃣-减少不必要的嵌套" class="headerlink" title="1️⃣ 减少不必要的嵌套"></a>1️⃣ 减少不必要的嵌套</h3><p><img src="https://user-gold-cdn.xitu.io/2019/6/15/16b58e532d863b10?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>我们团队是重度的 <code>styled-components</code> 用户，<strong>其实大部分情况下我们都不需要这个玩意</strong>，比如纯静态的样式规则，以及需要重度性能优化的场景。除了性能问题，另外一个困扰我们的是它带来的节点嵌套地狱 (如上图)。</p><p>所以我们需要理性地选择一些工具，比如使用原生的 CSS，减少 React 运行时的负担.</p><p><strong>一般不必要的节点嵌套都是滥用高阶组件 / RenderProps 导致的。所以还是那句话‘只有在必要时才使用 xxx’</strong>。 有很多种方式来代替高阶组件 / RenderProps，例如优先使用 props、React Hooks</p><h3 id="2️⃣-虚拟列表"><a href="#2️⃣-虚拟列表" class="headerlink" title="2️⃣ 虚拟列表"></a>2️⃣ 虚拟列表</h3><p>虚拟列表是常见的‘长列表’和’复杂组件树’优化方式，它优化的本质就是减少渲染的节点。</p><p>虚拟列表只渲染当前视口可见元素:</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/15/16b58e532e72f064?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>虚拟列表渲染性能对比:</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/15/16b58e532ca493d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>虚拟列表常用于以下组件场景:</p><ul><li>无限滚动列表，grid, 表格，下拉列表，spreadsheets</li><li>无限切换的日历或轮播图</li><li>大数据量或无限嵌套的树</li><li>聊天窗，数据流 (feed), 时间轴</li><li>等等</li></ul><p>相关组件方案:</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fbvaughn%2Freact-virtualized" target="_blank" rel="noopener">react-virtualized</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fbvaughn%2Freact-window" target="_blank" rel="noopener">react-window</a> 更轻量的 react-virtualized, 同出一个作者</li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fbvaughn%2Freact-virtualized%23friends" target="_blank" rel="noopener">更多</a></li></ul><p>扩展：</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fbvaughn.github.io%2Fforward-js-2017%2F%23%2F0%2F0" target="_blank" rel="noopener">Creating more efficient React views with windowing</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Faddyosmani.com%2Fblog%2Freact-window%2F" target="_blank" rel="noopener">Rendering large lists with react-window</a></li></ul><h3 id="3️⃣-惰性渲染"><a href="#3️⃣-惰性渲染" class="headerlink" title="3️⃣ 惰性渲染"></a>3️⃣ 惰性渲染</h3><p><strong>惰性渲染的初衷本质上和虚表一样，也就是说我们只在必要时才去渲染对应的节点</strong>。</p><p>举个典型的例子，我们常用 Tab 组件，我们没有必要一开始就将所有 Tab 的 panel 都渲染出来，而是等到该 Tab 被激活时才去惰性渲染。</p><p>还有很多场景会用到惰性渲染，例如树形选择器，模态弹窗，下拉列表，折叠组件等等。</p><p>这里就不举具体的代码例子了，留给读者去思考.</p><h3 id="4️⃣-选择合适的样式方案"><a href="#4️⃣-选择合适的样式方案" class="headerlink" title="4️⃣ 选择合适的样式方案"></a>4️⃣ 选择合适的样式方案</h3><p><img src="https://user-gold-cdn.xitu.io/2019/6/16/16b5dd10a46eceb2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>如图 (图片来源于 <a href="https://link.juejin.im?target=https%3A%2F%2Fblog.primehammer.com%2Fthe-performance-of-styled-react-components%2F" target="_blank" rel="noopener">THE PERFORMANCE OF STYLED REACT COMPONENTS</a>), 这个图片是 17 年的了，但是大抵的趋势还是这样。</p><p>所以在样式运行时性能方面大概可以总结为：<code>CSS &gt; 大部分CSS-in-js &gt; inline style</code></p><h2 id="避免重新渲染"><a href="#避免重新渲染" class="headerlink" title="避免重新渲染"></a>避免重新渲染</h2><p>减少不必要的重新渲染也是 React 组件性能优化的重要方向. 为了避免不必要的组件重新渲染需要在做到两点:</p><ol><li>保证组件纯粹性。即控制组件的副作用，如果组件有副作用则无法安全地缓存渲染结果</li><li>通过<code>shouldComponentUpdate</code>生命周期函数来比对 state 和 props, 确定是否要重新渲染。对于函数组件可以使用<code>React.memo</code>包装</li></ol><p>另外这些措施也可以帮助你更容易地优化组件重新渲染:</p><h3 id="0️⃣-简化-props"><a href="#0️⃣-简化-props" class="headerlink" title="0️⃣ 简化 props"></a>0️⃣ 简化 props</h3><p><strong>① 如果一个组件的 props 太复杂一般意味着这个组件已经违背了‘单一职责’，首先应该尝试对组件进行拆解</strong>. <strong>② 另外复杂的 props 也会变得难以维护, 比如会影响<code>shallowCompare</code>效率, 还会让组件的变动变得难以预测和调试</strong>.</p><p>下面是一个典型的例子, 为了判断列表项是否处于激活状态，这里传入了一个当前激活的 id:</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/15/16b58e53250b584f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>这是一个非常糟糕的设计，一旦激活 id 变动，所有列表项都会重新刷新. 更好的解决办法是使用类似<code>actived</code>这样的布尔值 prop. actived 现在只有两种变动情况，也就是说激活 id 的变动，最多只有两个组件需要重新渲染.</p><p><strong>简化的 props 更容易理解, 且可以提高组件缓存的命中率</strong></p><h3 id="1️⃣-不变的事件处理器"><a href="#1️⃣-不变的事件处理器" class="headerlink" title="1️⃣ 不变的事件处理器"></a>1️⃣ 不变的事件处理器</h3><p>①<strong>避免使用箭头函数形式的事件处理器</strong>, 例如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ComplexComponent onClick=&#123;evt =&gt; onClick(evt.id)&#125; otherProps=&#123;values&#125; /&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>假设 ComplexComponent 是一个复杂的 PureComponent, 这里使用箭头函数，其实每次渲染时都会创建一个新的事件处理器，这会导致 ComplexComponent 始终会被重新渲染.</p><p>更好的方式是使用实例方法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyComponent extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &lt;ComplexComponent onClick=&#123;this.handleClick&#125; otherProps=&#123;values&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    /*...*/</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>② 即使现在使用<code>hooks</code>，我依然会<strong>使用<code>useCallback</code>来包装事件处理器</strong>，尽量给下级组件暴露一个静态的函数:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const handleClick = useCallback(() =&gt; &#123;</span><br><span class="line">  /*...*/</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line">return &lt;ComplexComponent onClick=&#123;handleClick&#125; otherProps=&#123;values&#125; /&gt;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但是如果<code>useCallback</code>依赖于很多状态，你的<code>useCallback</code>可能会变成这样:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const handleClick = useCallback(() =&gt; &#123;</span><br><span class="line">  /*...*/</span><br><span class="line">  // 🤭</span><br><span class="line">&#125;, [foo, bar, baz, bazz, bazzzz]);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这种写法实在让人难以接受，这时候谁还管什么函数式非函数式的。我是这样处理的:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function useRefProps&lt;T&gt;(props: T) &#123;</span><br><span class="line">  const ref = useRef &lt; T &gt; props;</span><br><span class="line">  // 每次渲染更新props</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    ref.current = props;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function MyComp(props) &#123;</span><br><span class="line">  const propsRef = useRefProps(props);</span><br><span class="line"></span><br><span class="line">  // 现在handleClick是始终不变的</span><br><span class="line">  const handleClick = useCallback(() =&gt; &#123;</span><br><span class="line">    const &#123; foo, bar, baz, bazz, bazzzz &#125; = propsRef.current;</span><br><span class="line">    // do something</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>③<strong>设计更方便处理的 Event Props</strong>. 有时候我们会被逼的不得不使用箭头函数来作为事件处理器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;List&gt;</span><br><span class="line">  &#123;list.map(i =&gt; (</span><br><span class="line">    &lt;Item key=&#123;i.id&#125; onClick=&#123;() =&gt; handleDelete(i.id)&#125; value=&#123;i.value&#125; /&gt;</span><br><span class="line">  ))&#125;</span><br><span class="line">&lt;/List&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面的 onClick 是一个糟糕的实现，它没有携带任何信息来标识事件来源，所以这里只能使用闭包形式，更好的设计可能是这样的:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// onClick传递事件来源信息</span><br><span class="line">const handleDelete = useCallback((id: string) =&gt; &#123;</span><br><span class="line">  /*删除操作*/</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line">  &lt;List&gt;</span><br><span class="line">    &#123;list.map(i =&gt; (</span><br><span class="line">      &lt;Item key=&#123;i.id&#125; id=&#123;i.id&#125; onClick=&#123;handleDelete&#125; value=&#123;i.value&#125; /&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;/List&gt;</span><br><span class="line">);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果是第三方组件或者 DOM 组件呢? 实在不行，看能不能传递<code>data-*</code>属性:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const handleDelete = useCallback(event =&gt; &#123;</span><br><span class="line">  const id = event.dataset.id;</span><br><span class="line">  /*删除操作*/</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;list.map(i =&gt; (</span><br><span class="line">      &lt;li key=&#123;i.id&#125; data-id=&#123;i.id&#125; onClick=&#123;handleDelete&#125; value=&#123;i.value&#125; /&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="2️⃣-不可变数据"><a href="#2️⃣-不可变数据" class="headerlink" title="2️⃣ 不可变数据"></a>2️⃣ 不可变数据</h3><p>不可变数据可以让状态变得可预测，也让 shouldComponentUpdate ‘浅比较’变得更可靠和高效. 笔者在 <a href="https://juejin.im/post/5cdc2f54e51d453b0c35930d#heading-8" target="_blank" rel="noopener">React 组件设计实践总结 04 - 组件的思维</a>介绍过不可变数据，有兴趣读者可以看看.</p><p>相关的工具有 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fimmutable-js" target="_blank" rel="noopener">Immutable.js</a>、<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fmweststrate%2Fimmer" target="_blank" rel="noopener">Immer</a>、immutability-helper 以及 seamless-immutable。</p><h3 id="3️⃣-简化-state"><a href="#3️⃣-简化-state" class="headerlink" title="3️⃣ 简化 state"></a>3️⃣ 简化 state</h3><p><strong>不是所有状态都应该放在组件的 state 中</strong>. 例如缓存数据。按照我的原则是：<strong>如果需要组件响应它的变动, 或者需要渲染到视图中的数据才应该放到 state 中。这样可以避免不必要的数据变动导致组件重新渲染.</strong></p><h3 id="4️⃣-使用-recompose-精细化比对"><a href="#4️⃣-使用-recompose-精细化比对" class="headerlink" title="4️⃣ 使用 recompose 精细化比对"></a>4️⃣ 使用 recompose 精细化比对</h3><p>尽管 hooks 出来后，recompose 宣称不再更新了，但还是不影响我们使用 recompose 来控制<code>shouldComponentUpdate</code>方法, 比如它提供了以下方法来精细控制应该比较哪些 props:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> /* 相当于React.memo */</span><br><span class="line"> pure()</span><br><span class="line"> /* 自定义比较 */</span><br><span class="line"> shouldUpdate(test: (props: Object, nextProps: Object) =&gt; boolean): HigherOrderComponent</span><br><span class="line"> /* 只比较指定key */</span><br><span class="line"> onlyUpdateForKeys( propKeys: Array&lt;string&gt;): HigherOrderComponent</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其实还可以再扩展一下，比如<code>omitUpdateForKeys</code>忽略比对某些 key.</p><h2 id="精细化渲染"><a href="#精细化渲染" class="headerlink" title="精细化渲染"></a>精细化渲染</h2><p>所谓精细化渲染指的是<strong>只有一个数据来源导致组件重新渲染</strong>, 比如说 A 只依赖于 a 数据，那么只有在 a 数据变动时才渲染 A, 其他状态变化不应该影响组件 A。</p><p>Vue 和 Mobx 宣称自己性能好的一部分原因是它们的’响应式系统’, <strong>它允许我们定义一些‘响应式数据’，当这些响应数据变动时，依赖这些响应式数据视图就会重新渲染</strong>. 来看看 Vue 官方是如何描述的:</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/15/16b58e532d4abd3c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><h3 id="0️⃣-响应式数据的精细化渲染"><a href="#0️⃣-响应式数据的精细化渲染" class="headerlink" title="0️⃣ 响应式数据的精细化渲染"></a>0️⃣ 响应式数据的精细化渲染</h3><p><strong>大部分情况下，响应式数据可以实现视图精细化的渲染, 但它还是不能避免开发者写出低效的程序</strong>. <strong>本质上还是因为组件违背‘单一职责’</strong>.</p><p>举个例子，现在有一个 MyComponent 组件，依赖于 A、B、C 三个数据源，来构建一个 vdom 树。现在的问题是什么呢？现在只要 A、B、C 任意一个变动，那么 MyComponent 整个就会重新渲染:</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/15/16b58e532546f6d6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>更好的做法是让组件的职责更单一，精细化地依赖响应式数据，或者说对响应式数据进行‘隔离’. 如下图, A、B、C 都抽取各自的组件中了，现在 A 变动只会渲染 A 组件本身，而不会影响父组件和 B、C 组件:</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/15/16b58e53ae748821?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>举一个典型的例子，列表渲染:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; observable &#125; from &apos;mobx&apos;;</span><br><span class="line">import &#123; observer &#125; from &apos;mobx-react-lite&apos;;</span><br><span class="line"></span><br><span class="line">const initialList = [];</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  initialList.push(&#123; id: i, name: `name-$&#123;i&#125;`, value: 0 &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = observable(&#123;</span><br><span class="line">  list: initialList,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export const List = observer(() =&gt; &#123;</span><br><span class="line">  const list = store.list;</span><br><span class="line">  console.log(&apos;List渲染&apos;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div class&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;list.map((i, idx) =&gt; (</span><br><span class="line">          &lt;div class key=&#123;i.id&#125;&gt;</span><br><span class="line">            &#123;/* 假设这是一个复杂的组件 */&#125;</span><br><span class="line">            &#123;console.log(&apos;render&apos;, i.id)&#125;</span><br><span class="line">            &lt;span class&gt;&#123;i.name&#125; &lt;/span&gt;</span><br><span class="line">            &lt;span class&gt;&#123;i.value&#125; &lt;/span&gt;</span><br><span class="line">            &lt;button</span><br><span class="line">              class</span><br><span class="line">              onClick=&#123;() =&gt; &#123;</span><br><span class="line">                i.value++;</span><br><span class="line">                console.log(&apos;递增&apos;);</span><br><span class="line">              &#125;&#125;</span><br><span class="line">            &gt;</span><br><span class="line">              递增</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">            &lt;button</span><br><span class="line">              class</span><br><span class="line">              onClick=&#123;() =&gt; &#123;</span><br><span class="line">                if (idx &lt; list.length - 1) &#123;</span><br><span class="line">                  console.log(&apos;移位&apos;);</span><br><span class="line">                  let t = list[idx];</span><br><span class="line">                  list[idx] = list[idx + 1];</span><br><span class="line">                  list[idx + 1] = t;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;&#125;</span><br><span class="line">            &gt;</span><br><span class="line">              下移</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上述的例子是存在性能问题的，单个 list-item 的递增和移位都会导致整个列表的重新渲染:</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/15/16b58e53c9978c97?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>原因大概能猜出来吧? 对于 Vue 或者 Mobx 来说，<strong>一个组件的渲染函数就是一个依赖收集的上下文</strong>。上面 List 组件渲染函数内’访问’了所有的列表项数据，那么 Vue 或 Mobx 就会认为你这个组件依赖于所有的列表项，这样就导致，只要任意一个列表项的属性值变动就会重新渲染整个 List 组件。</p><p>解决办法也很简单，就是将数据隔离抽取到单一职责的组件中。<strong>对于 Vue 或 Mobx 来说，越细粒度的组件，可以收获更高的性能优化效果</strong>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const ListItem = observer(props =&gt; &#123;</span><br><span class="line">  const &#123; item, onShiftDown &#125; = props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div class&gt;</span><br><span class="line">      &#123;console.log(&apos;render&apos;, item.id)&#125;</span><br><span class="line">      &#123;/* 假设这是一个复杂的组件 */&#125;</span><br><span class="line">      &lt;span class&gt;&#123;item.name&#125; &lt;/span&gt;</span><br><span class="line">      &lt;span class&gt;&#123;item.value&#125; &lt;/span&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        class</span><br><span class="line">        onClick=&#123;() =&gt; &#123;</span><br><span class="line">          item.value++;</span><br><span class="line">          console.log(&apos;递增&apos;);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        递增</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button class onClick=&#123;() =&gt; onShiftDown(item)&#125;&gt;</span><br><span class="line">        下移</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export const List = observer(() =&gt; &#123;</span><br><span class="line">  const list = store.list;</span><br><span class="line">  const handleShiftDown = useCallback(item =&gt; &#123;</span><br><span class="line">    const idx = list.findIndex(i =&gt; i.id === item.id);</span><br><span class="line">    if (idx !== -1 &amp;&amp; idx &lt; list.length - 1) &#123;</span><br><span class="line">      console.log(&apos;移位&apos;);</span><br><span class="line">      let t = list[idx];</span><br><span class="line">      list[idx] = list[idx + 1];</span><br><span class="line">      list[idx + 1] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    // eslint-disable-next-line react-hooks/exhaustive-deps</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  console.log(&apos;List 渲染&apos;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div class&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;list.map((i, idx) =&gt; (</span><br><span class="line">          &lt;ListItem key=&#123;i.id&#125; item=&#123;i&#125; onShiftDown=&#123;handleShiftDown&#125; /&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果很明显, list-item 递增只会重新渲染本身; 而移位只会重新渲染 List， 因为列表项没有变动, 所以下级 list-item 也不需要重新渲染:</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/15/16b58e53aea289bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><h3 id="1️⃣-不要滥用-Context"><a href="#1️⃣-不要滥用-Context" class="headerlink" title="1️⃣ 不要滥用 Context"></a>1️⃣ 不要滥用 Context</h3><p><strong>其实 Context 的用法和响应式数据正好相反</strong>。笔者也看过不少滥用 Context API 的例子, 说到底还是没有处理好‘状态的作用域问题’.</p><p>首先要理解 Context API 的更新特点，<strong>它是可以穿透<code>React.memo</code>或者<code>shouldComponentUpdate</code>的比对的，也就是说，一旦 Context 的 Value 变动，所有依赖该 Context 的组件会全部 forceUpdate</strong>.</p><p><strong>这个和 Mobx 和 Vue 的响应式系统不同，Context API 并不能细粒度地检测哪些组件依赖哪些状态，所以说上节提到的‘精细化渲染’组件模式，在 Context 这里就成为了‘反模式’</strong>.</p><p>总结一下使用 Context API 要遵循一下原则:</p><ul><li><p><strong>明确状态作用域, Context 只放置必要的，关键的，被大多数组件所共享的状态</strong>。比较典型的是鉴权状态</p><p>举一个简单的例子:</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/15/16b58e53c17cd5e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p><img src="https://user-gold-cdn.xitu.io/2019/6/15/16b58e53c9bdc0b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>扩展：Context 其实有个实验性或者说非公开的选项<code>observedBits</code>, 可以用于控制 ContextConsumer 是否需要更新. 详细可以看这篇文章 &lt;<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F51073183" target="_blank" rel="noopener">ObservedBits: React Context 的秘密功能</a> &gt;. 不过不推荐在实际项目中使用，而且这个 API 也比较难用，不如直接上 mobx。</p></li><li><p><strong>粗粒度地订阅 Context</strong></p><p>如下图. 细粒度的 Context 订阅会导致不必要的重新渲染, 所以这里推荐粗粒度的订阅. 比如在父级订阅 Context，然后再通过 props 传递给下级。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/15/16b58e53c08a377e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p></li></ul><p>另外程墨 Morgan 在<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F50336226" target="_blank" rel="noopener">避免 React Context 导致的重复渲染</a>一文中也提到 ContextAPI 的一个陷阱:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Context.Provider</span><br><span class="line">  value=&#123;&#123; theme: this.state.theme, switchTheme: this.switchTheme &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;div class&gt;</span><br><span class="line">    &lt;Header /&gt;</span><br><span class="line">    &lt;Content /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/Context.Provider&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面的组件会在 state 变化时重新渲染整个组件树，至于为什么留给读者去思考。</p><p>所以我们一般都不会裸露地使用 Context.Provider, 而是封装为独立的 Provider 组件:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function ThemeProvider(props) &#123;</span><br><span class="line">  const [theme, switchTheme] = useState(redTheme);</span><br><span class="line">  return (</span><br><span class="line">    &lt;Context.Provider value=&#123;&#123; theme, switchTheme &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/Context.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 顺便暴露useTheme, 让外部必须直接使用Context</span><br><span class="line">export function useTheme() &#123;</span><br><span class="line">  return useContext(Context);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>现在 theme 变动就不会重新渲染整个组件树，因为 props.children 由外部传递进来，并没有发生变动。</p><p><strong>其实上面的代码还有另外一个比较难发现的陷阱 (官方文档也有<a href="https://link.juejin.im?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Fcontext.html%23caveats" target="_blank" rel="noopener">提到</a>)</strong>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function ThemeProvider(props) &#123;</span><br><span class="line">  const [theme, switchTheme] = useState(redTheme);</span><br><span class="line">  return (</span><br><span class="line">    &#123;/* 👇 💣这里每一次渲染ThemeProvider, 都会创建一个新的value(即使theme和switchTheme没有变动),</span><br><span class="line">        从而导致强制渲染所有依赖该Context的组件 */&#125;</span><br><span class="line">    &lt;Context.Provider value=&#123;&#123; theme, switchTheme &#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/Context.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>所以<strong>传递给 Context 的 value 最好做一下缓存</strong>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function ThemeProvider(props) &#123;</span><br><span class="line">  const [theme, switchTheme] = useState(redTheme);</span><br><span class="line">  const value = useMemo(() =&gt; (&#123; theme, switchTheme &#125;), [theme]);</span><br><span class="line">  return &lt;Context.Provider value=&#123;value&#125;&gt;&#123;props.children&#125;&lt;/Context.Provider&gt;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Freact.docschina.org%2Fdocs%2Foptimizing-performance.html" target="_blank" rel="noopener">Optimizing Performance</a> React 官方文档，最好的教程, 利用好 React 的性能分析工具。</li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2F%40paularmstrong%2Ftwitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3" target="_blank" rel="noopener">Twitter Lite and High Performance React Progressive Web Apps at Scale</a> 看看 Twitter 如何优化的</li></ul>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-链表-总结篇</title>
    <url>/archives/8be5.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/andyyxw/images/img/algorithm_linked-list.png" alt="算法-链表-总结篇"></p><a id="more"></a><p>详见 <a href="https://programmercarl.com/链表总结篇.html" target="_blank" rel="noopener">代码随想录-链表总结篇</a></p>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>代码随想录</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-数组 总结篇</title>
    <url>/archives/31e1.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/andyyxw/images/img/algorithm_array.png" alt="代码随想录-数组总结篇"></p><a id="more"></a><p>详见 <a href="https://programmercarl.com/数组总结篇.html" target="_blank" rel="noopener">代码随想录-数组总结篇</a></p>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>代码随想录</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>精读《Function VS Class 组件》</title>
    <url>/archives/ecb7.html</url>
    <content><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://zhuanlan.zhihu.com/p/59558396" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59558396</a></p></blockquote><ol><li>引言</li></ol><hr><p>为什么要了解 Function 写法的组件呢？因为它正在变得越来越重要。</p><p>那么 React 中 <strong>Function Component 与 Class Component 有何不同？</strong></p><p><a href="https://overreacted.io/how-are-function-components-different-from-classes/" target="_blank" rel="noopener">how-are-function-components-different-from-classes</a> 这篇文章带来了一个独特的视角。</p><blockquote><p>顺带一提，以后会用 Function Component 代替 Stateless Component 的说法，原因是：自从 Hooks 出现，函数式组件功能在不断丰富，函数式组件不再需要强调其无状态特性，因此叫 Function Component 更为恰当。</p></blockquote><ol start="2"><li>概述</li></ol><hr><p>原文事先申明：并没有对 Function 与 Classes 进行优劣对比，而仅仅进行特性对比，所以不接受任何吐槽。</p><blockquote><p>这两种写法没有好坏之分，性能差距也几乎可以忽略，而且 React 会长期支持这两种写法。</p></blockquote><h2 id="Capture-props"><a href="#Capture-props" class="headerlink" title="Capture props"></a>Capture props</h2><p>对比下面两段代码。</p><p><strong>Class Component:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ProfilePage extends React.Component &#123;</span><br><span class="line">  showMessage = () =&gt; &#123;</span><br><span class="line">    alert(&quot;Followed &quot; + this.props.user);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    setTimeout(this.showMessage, 3000);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Function Component:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ProfilePage(props) &#123;</span><br><span class="line">  const showMessage = () =&gt; &#123;</span><br><span class="line">    alert(&quot;Followed &quot; + props.user);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const handleClick = () =&gt; &#123;</span><br><span class="line">    setTimeout(showMessage, 3000);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<a href="https://codesandbox.io/s/pjqnl16lm7" target="_blank" rel="noopener">在线 Demo</a>）</p><p>这两个组件都描述了同一个逻辑：点击按钮 3 秒后 <code>alert</code> 父级传入的用户名。</p><p>如下父级组件的调用方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ProfilePageFunction user=&#123;this.state.user&#125; /&gt;</span><br><span class="line">&lt;ProfilePageClass user=&#123;this.state.user&#125; /&gt;</span><br></pre></td></tr></table></figure><p>那么当点击按钮后的 3 秒内，父级修改了 <code>this.state.user</code>，弹出的用户名是修改前的还是修改后的呢？</p><p><strong>Class Component 展示的是修改后的值：</strong></p><p>&lt;img src=”<a href="https://pic4.zhimg.com/v2-9d9d77bb138395301509792d9ae9acbf_b.gif" target="_blank" rel="noopener">https://pic4.zhimg.com/v2-9d9d77bb138395301509792d9ae9acbf_b.gif</a>“ data-caption=””data-size=”normal”data-rawwidth=”950”data-rawheight=”351”data-thumbnail=”<a href="https://pic4.zhimg.com/v2-9d9d77bb138395301509792d9ae9acbf_b.jpg" target="_blank" rel="noopener">https://pic4.zhimg.com/v2-9d9d77bb138395301509792d9ae9acbf_b.jpg</a>“width=”950”data-original=”<a href="https://pic4.zhimg.com/v2-9d9d77bb138395301509792d9ae9acbf_r.jpg" target="_blank" rel="noopener">https://pic4.zhimg.com/v2-9d9d77bb138395301509792d9ae9acbf_r.jpg</a>“/&gt;<img src="https://pic4.zhimg.com/v2-9d9d77bb138395301509792d9ae9acbf_b.jpg" alt></p><p><strong>Function Component 展示的是修改前的值：</strong></p><p>&lt;img src=”<a href="https://pic3.zhimg.com/v2-84396c4b3982827bead96912a947904e_b.gif" target="_blank" rel="noopener">https://pic3.zhimg.com/v2-84396c4b3982827bead96912a947904e_b.gif</a>“ data-caption=””data-size=”normal”data-rawwidth=”901”data-rawheight=”293”data-thumbnail=”<a href="https://pic3.zhimg.com/v2-84396c4b3982827bead96912a947904e_b.jpg" target="_blank" rel="noopener">https://pic3.zhimg.com/v2-84396c4b3982827bead96912a947904e_b.jpg</a>“width=”901”data-original=”<a href="https://pic3.zhimg.com/v2-84396c4b3982827bead96912a947904e_r.jpg" target="_blank" rel="noopener">https://pic3.zhimg.com/v2-84396c4b3982827bead96912a947904e_r.jpg</a>“/&gt;<img src="https://pic3.zhimg.com/v2-84396c4b3982827bead96912a947904e_b.jpg" alt></p><p>那么 React 文档中描述的 <code>props</code> 不是不可变（Immutable） 数据吗？为啥在运行时还会发生变化呢？</p><p>原因在于，虽然 <code>props</code> 不可变，是 <code>this</code> 在 Class Component 中是可变的，因此 <code>this.props</code> 的调用会导致每次都访问最新的 <code>props</code>。</p><p>而 Function Component 不存在 <code>this.props</code> 的语法，因此 <code>props</code> 总是不可变的。</p><p>为了便于理解，笔者补充一些代码注解：</p><p><strong>Function Component:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ProfilePage(props) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    // 就算父组件 reRender，这里拿到的 props 也是初始的</span><br><span class="line">    console.log(props);</span><br><span class="line">  &#125;, 3000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Class Component:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ProfilePage extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 如果父组件 reRender，this.props 拿到的永远是最新的。</span><br><span class="line">      // 并不是 props 变了，而是 this.props 指向了新的 props，旧的 props 找不到了</span><br><span class="line">      console.log(this.props);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望在 Class Component 捕获瞬时 Props，可以： <code>const props = this.props;</code>，但这样的代码很蹩脚，所以如果希望拿到稳定的 <code>props</code>，使用 Function Component 是更好的选择。</p><h2 id="Hooks-也具有-capture-value-特性"><a href="#Hooks-也具有-capture-value-特性" class="headerlink" title="Hooks 也具有 capture value 特性"></a>Hooks 也具有 capture value 特性</h2><p>看下面的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MessageThread() &#123;</span><br><span class="line">  const [message, setMessage] = useState(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  const showMessage = () =&gt; &#123;</span><br><span class="line">    alert(&quot;You said: &quot; + message);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const handleSendClick = () =&gt; &#123;</span><br><span class="line">    setTimeout(showMessage, 3000);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const handleMessageChange = e =&gt; &#123;</span><br><span class="line">    setMessage(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input value=&#123;message&#125; onChange=&#123;handleMessageChange&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleSendClick&#125;&gt;Send&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<a href="https://codesandbox.io/s/93m5mz9w24" target="_blank" rel="noopener">在线 Demo</a>）</p><p>在点击 <code>Send</code> 按钮后，再次修改输入框的值，3 秒后的输出依然是 <strong>点击前输入框的值</strong>。这说明 Hooks 同样具有 capture value 的特性。</p><p>利用 <code>useRef</code> 可以规避 capture value 特性：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MessageThread() &#123;</span><br><span class="line">  const latestMessage = useRef(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  const showMessage = () =&gt; &#123;</span><br><span class="line">    alert(&quot;You said: &quot; + latestMessage.current);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const handleSendClick = () =&gt; &#123;</span><br><span class="line">    setTimeout(showMessage, 3000);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const handleMessageChange = e =&gt; &#123;</span><br><span class="line">    latestMessage.current = e.target.value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要将赋值与取值的对象变成 <code>useRef</code>，而不是 <code>useState</code>，就可以躲过 capture value 特性，在 3 秒后得到最新的值。</p><p>这说明了利用 Function Component + Hooks 可以实现 Class Component 做不到的 capture props、capture value，而且 React 官方也推荐 <a href="https://reactjs.org/docs/hooks-faq.html#do-i-need-to-rewrite-all-my-class-components" target="_blank" rel="noopener">新的代码使用 Hooks 编写</a>。</p><ol start="3"><li>精读</li></ol><hr><p>原文 <a href="https://overreacted.io/how-are-function-components-different-from-classes/" target="_blank" rel="noopener">how-are-function-components-different-from-classes</a> 从一个侧面讲述了 Function Component 与 Class Component 的不同点，之所以将 Function Component 与 Class Component 相提并论，几乎都要归功于 Hooks API 的出现，有了 Hooks，Function Component 的能力才得以向 Class Component 看齐。</p><p>关于 React Hooks，之前的两篇精读分别有过介绍：</p><ul><li><a href="https://github.com/dt-fe/weekly/blob/master/79.%E7%B2%BE%E8%AF%BB%E3%80%8AReact%20Hooks%E3%80%8B.md" target="_blank" rel="noopener">精读《React Hooks》</a></li><li><a href="https://github.com/dt-fe/weekly/blob/master/80.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%80%8E%E4%B9%88%E7%94%A8%20React%20Hooks%20%E9%80%A0%E8%BD%AE%E5%AD%90%E3%80%8B.md" target="_blank" rel="noopener">精读《怎么用 React Hooks 造轮子》</a></li></ul><p>但是，虽然 Hook 已经发布了稳定版本，但周边生态跟进还需要时间（比如 <code>useRouter</code>）、最佳实践整理还需要时间，因此不建议重构老代码。</p><p>为了更好的使用 Function Component，建议时常与 Class Component 的功能做对比，方便理解和记忆。</p><p>下面整理一些常见的 Function Component 问题：</p><blockquote><p>非常建议完整阅读 <a href="https://reactjs.org/docs/hooks-faq.html#do-i-need-to-rewrite-all-my-class-components" target="_blank" rel="noopener">React Hooks FAQ</a>。</p></blockquote><h2 id="怎么替代-shouldComponentUpdate"><a href="#怎么替代-shouldComponentUpdate" class="headerlink" title="怎么替代 shouldComponentUpdate"></a>怎么替代 shouldComponentUpdate</h2><p>说实话，Function Component 替代 <code>shouldComponentUpdate</code> 的方案并没有 Class Component 优雅，代码是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Button = React.memo(props =&gt; &#123;</span><br><span class="line">  // your component</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或者在父级就直接生成一个自带 <code>memo</code> 的子元素：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Parent(&#123; a, b &#125;) &#123;</span><br><span class="line">  // Only re-rendered if `a` changes:</span><br><span class="line">  const child1 = useMemo(() =&gt; &lt;Child1 a=&#123;a&#125; /&gt;, [a]);</span><br><span class="line">  // Only re-rendered if `b` changes:</span><br><span class="line">  const child2 = useMemo(() =&gt; &lt;Child2 b=&#123;b&#125; /&gt;, [b]);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;child1&#125;</span><br><span class="line">      &#123;child2&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之下，Class Component 的写法通常是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Button extends React.PureComponent &#123;&#125;</span><br></pre></td></tr></table></figure><p>这样就自带了 <code>shallowEqual</code> 的 <code>shouldComponentUpdate</code>。</p><h2 id="怎么替代-componentDidUpdate"><a href="#怎么替代-componentDidUpdate" class="headerlink" title="怎么替代 componentDidUpdate"></a>怎么替代 componentDidUpdate</h2><p>由于 <code>useEffect</code> 每次 Render 都会执行，因此需要模拟一个 <code>useUpdate</code> 函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mounting = useRef(true);</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  if (mounting.current) &#123;</span><br><span class="line">    mounting.current = false;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    fn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更多可以查看 <a href="https://github.com/dt-fe/weekly/blob/master/80.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%80%8E%E4%B9%88%E7%94%A8%20React%20Hooks%20%E9%80%A0%E8%BD%AE%E5%AD%90%E3%80%8B.md#componentdidupdate" target="_blank" rel="noopener">精读《怎么用 React Hooks 造轮子》</a></p><h2 id="怎么替代-forceUpdate"><a href="#怎么替代-forceUpdate" class="headerlink" title="怎么替代 forceUpdate"></a>怎么替代 forceUpdate</h2><p>React 官方文档提供了一种方案：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [ignored, forceUpdate] = useReducer(x =&gt; x + 1, 0);</span><br><span class="line"></span><br><span class="line">function handleClick() &#123;</span><br><span class="line">  forceUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次执行 <code>dispatch</code> 时，只要 <code>state</code> 变化就会触发组件更新。当然 <code>useState</code> 也同样可以模拟：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const useUpdate = () =&gt; useState(0)[1];</span><br></pre></td></tr></table></figure><p>我们知道 <code>useState</code> 下标为 1 的项是用来更新数据的，而且就算数据没有变化，调用了也会刷新组件，所以我们可以把返回一个没有修改数值的 <code>setValue</code>，这样它的功能就仅剩下刷新组件了。</p><p>更多可以查看 <a href="https://github.com/dt-fe/weekly/blob/master/80.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%80%8E%E4%B9%88%E7%94%A8%20React%20Hooks%20%E9%80%A0%E8%BD%AE%E5%AD%90%E3%80%8B.md#force-update" target="_blank" rel="noopener">精读《怎么用 React Hooks 造轮子》</a></p><h2 id="state-拆分过多"><a href="#state-拆分过多" class="headerlink" title="state 拆分过多"></a>state 拆分过多</h2><p><code>useState</code> 目前的一种实践，是将变量名打平，而非像 Class Component 一样写在一个 State 对象里：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ClassComponent extends React.PureComponent &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    left: 0,</span><br><span class="line">    top: 0,</span><br><span class="line">    width: 100,</span><br><span class="line">    height: 100</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// VS</span><br><span class="line"></span><br><span class="line">function FunctionComponent &#123;</span><br><span class="line">  const [left,setLeft] = useState(0)</span><br><span class="line">  const [top,setTop] = useState(0)</span><br><span class="line">  const [width,setWidth] = useState(100)</span><br><span class="line">  const [height,setHeight] = useState(100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上在 Function Component 中也可以聚合管理 State：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function FunctionComponent() &#123;</span><br><span class="line">  const [state, setState] = useState(&#123;</span><br><span class="line">    left: 0,</span><br><span class="line">    top: 0,</span><br><span class="line">    width: 100,</span><br><span class="line">    height: 100</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是更新的时候，不再会自动 merge，而需要使用 <code>...state</code> 语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setState(state =&gt; (&#123; ...state, left: e.pageX, top: e.pageY &#125;));</span><br></pre></td></tr></table></figure><p>可以看到，更少的黑魔法，更可预期的结果。</p><h2 id="获取上一个-props"><a href="#获取上一个-props" class="headerlink" title="获取上一个 props"></a>获取上一个 props</h2><p>虽然不怎么常用，但是毕竟 Class Component 可以通过 <code>componentWillReceiveProps</code> 拿到 <code>previousProps</code> 与 <code>nextProps</code>，对于 Function Component，最好通过自定义 Hooks 方式拿到上一个状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const prevCount = usePrevious(count);</span><br><span class="line">  return (</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">      Now: &#123;count&#125;, before: &#123;prevCount&#125;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function usePrevious(value) &#123;</span><br><span class="line">  const ref = useRef();</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    ref.current = value;</span><br><span class="line">  &#125;);</span><br><span class="line">  return ref.current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>useEffect</code> 在组件渲染完毕后再执行的特性，再利用 <code>useRef</code> 的可变特性，让 <code>usePrevious</code> 的返回值是 “上一次” Render 时的。</p><p>可见，合理运用 <code>useEffect</code> <code>useRef</code>，可以做许多事情，而且封装成 CustomHook 后使用起来仍然很方便。</p><blockquote><p>未来 <code>usePrevious</code> 可能成为官方 Hooks 之一。</p></blockquote><h2 id="性能注意事项"><a href="#性能注意事项" class="headerlink" title="性能注意事项"></a>性能注意事项</h2><p><code>useState</code> 函数的参数虽然是初始值，但由于整个函数都是 Render，因此每次初始化都会被调用，如果初始值计算非常消耗时间，建议使用函数传入，这样只会执行一次：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function FunctionComponent(props) &#123;</span><br><span class="line">  const [rows, setRows] = useState(() =&gt; createRows(props.count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>useRef</code> 不支持这种特性，需要<a href="https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily" target="_blank" rel="noopener">写一些冗余的函判定是否进行过初始化</a>。</p></blockquote><p>掌握了这些，Function Component 使用起来与 Class Component 就几乎没有差别了！</p><ol start="4"><li>总结</li></ol><hr><p>Function Component 功能已经可以与 Class Component 媲美了，但目前最佳实践比较零散，官方文档推荐的一些解决思路甚至不比社区第三方库的更好，可以预料到，Class Component 的功能会被五花八门的实现出来，那些没有被收纳进官方的 Hooks 乍看上去可能会眼花缭乱。</p><p>总之选择了 Function Component 就同时选择了函数式的好与坏。<strong>好处是功能强大，几乎可以模拟出任何想要的功能</strong>，<strong>坏处是由于可以灵活组合，如果自定义 Hooks 命名和实现不够标准，函数与函数之间对接的沟通成本会更大。</strong></p><blockquote><p>讨论地址是：<a href="https://github.com/dt-fe/weekly/issues/137" target="_blank" rel="noopener">精读《Stateless VS Class 组件》 · Issue #137 · dt-fe/weekly</a></p></blockquote><p><strong>如果你想参与讨论，请</strong> <strong><a href="https://github.com/dt-fe/weekly" target="_blank" rel="noopener">点击这里</a>，每周都有新的主题，周末或周一发布。前端精读 - 帮你筛选靠谱的内容。</strong></p><blockquote><p>关注 <strong>前端精读微信公众号</strong></p></blockquote><p>&lt;img src=”<a href="https://pic3.zhimg.com/v2-d817340c54185469ec4df17c0938742e_b.jpg" target="_blank" rel="noopener">https://pic3.zhimg.com/v2-d817340c54185469ec4df17c0938742e_b.jpg</a>“ data-caption=””data-size=”normal”data-rawwidth=”258”data-rawheight=”258”width=”258”/&gt;<img src="https://pic3.zhimg.com/80/v2-d817340c54185469ec4df17c0938742e_hd.jpg" alt></p><p><strong>special Sponsors</strong></p><ul><li><a href="https://e.coding.net/?utm_source=weekly" target="_blank" rel="noopener">DevOps 全流程平台</a></li></ul><blockquote><p>版权声明：自由转载 - 非商用 - 非衍生 - 保持署名（<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享 3.0 许可证</a>）</p></blockquote><p>写下你的评论…</p><p>在线 Demo 挂了~</p><p>修复了</p><p>class 的这个 bug Dan 好像提过 用 const {XXX} = this.props 可以解决</p><p>你在文中好像提了 我没仔细看 不好意思</p><p><img src="https://pic1.zhimg.com/v2-12562ad40366818a1ea39bcecb2599a0_r.gif" alt></p><p>那么问题来了，为什么要用 hooks…</p><p>生命在于不息</p><p>我觉得那段 props immutable 解释的是不是有点歧义。。比如，instance 的 this 是可变的，this 在完整的组件声明周期里并不会修改啊，只是 this 上的 props 可能会修改指向。然后。下文用 setTimeout 这段表达的其实是闭包针对变量的捕获吧，这个和是不是 immutable 关系并不大吧 （我觉得这里完全就是闭包的问题）？</p>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React Hooks</tag>
        <tag>React组件</tag>
      </tags>
  </entry>
  <entry>
    <title>解密传统组件间通信与React组件间通信</title>
    <url>/archives/ac71.html</url>
    <content><![CDATA[<p>在 React 中最小的逻辑单元是组件，组件之间如果有耦合关系就会进行通信，本文将会介绍 React 中的组件通信的不同方式</p><p>通过归纳范，可以将任意组件间的通信归类为四种类型的组件间通信，分别是父子组件，爷孙组件，兄弟组件和任意组件，<br>需要注意的是前三个也可以算作任意组件的范畴，所以最后一个是万能方法</p><h3 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h3><p>父子组件间的通信分为父组件向子组件通信和子组件向父组件通信两种情况，下面先来介绍父组件向子组件通信，<br>传统做法分为两种情况，分别是初始化时的参数传递和实例阶段的方法调用，例子如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="comment">// 获取dom引用</span></span><br><span class="line">    <span class="keyword">this</span>.$div = <span class="built_in">document</span>.querySelector(<span class="string">"#wp"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时传入name</span></span><br><span class="line">    <span class="keyword">this</span>.updateName(name);</span><br><span class="line">  &#125;</span><br><span class="line">  updateName(name) &#123;</span><br><span class="line">    <span class="comment">// 对外提供更新的api</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新dom</span></span><br><span class="line">    <span class="keyword">this</span>.$div.innerHTML = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化阶段</span></span><br><span class="line">    <span class="keyword">this</span>.child = <span class="keyword">new</span> Child(<span class="string">"yan"</span>);</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 实例化阶段</span></span><br><span class="line">      <span class="keyword">this</span>.child.updateName(<span class="string">"hou"</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 React 中将两个情况统一处理，全部通过属性来完成，之所以能够这样是因为 React 在属性更新时会自动重新渲染子组件，<br>下面的例子中，2 秒后子组件会自动重新渲染，并获取新的属性值</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化阶段</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">name</span>: <span class="string">"yan"</span> &#125;;</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 实例化阶段</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">name</span>: <span class="string">"hou"</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&#123;this.state.name&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看一下子组件如何向父组件通信，传统做法有两种，一种是回调函数，另一种是为子组件部署消息接口</p><p>先来看回调函数的例子，回调函数的优点是非常简单，缺点就是必须在初始化的时候传入，并且不可撤回，并且只能传入一个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(cb) &#123;</span><br><span class="line">    <span class="comment">// 调用父组件传入的回调函数，发送消息</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      cb();</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化阶段，传入回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.child = <span class="keyword">new</span> Child(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"child update"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看看消息接口方法，首先需要一个可以发布和订阅消息的基类，比如下面实现了一个简单的<code>EventEimtter</code>，实际生产中可以直接使用别人写好的类库，比如<a href="https://github.com/jsmini/event" target="_blank" rel="noopener">@jsmini/event</a>，子组件继承消息基类，就有了发布消息的能力，然后父组件订阅子组件的消息，即可实现子组件向父组件通信的功能</p><p>消息接口的优点就是可以随处订阅，并且可以多次订阅，还可以取消订阅，缺点是略显麻烦，需要引入消息基类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息接口，订阅发布模式，类似绑定事件，触发事件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEimtter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.eventMap = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  sub(name, cb) &#123;</span><br><span class="line">    <span class="keyword">const</span> eventList = (<span class="keyword">this</span>.eventMap[name] = <span class="keyword">this</span>.eventMap[name] || &#123;&#125;);</span><br><span class="line">    eventList.push(cb);</span><br><span class="line">  &#125;</span><br><span class="line">  pub(name, ...data) &#123;</span><br><span class="line">    (<span class="keyword">this</span>.eventMap[name] || []).forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(...data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">EventEimtter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// 通过消息接口发布消息</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.pub(<span class="string">"update"</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化阶段，传入回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.child = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅子组件的消息</span></span><br><span class="line">    <span class="keyword">this</span>.child.sub(<span class="string">"update"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"child update"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Backbone.js 就同时支持回调函数和消息接口方式，但 React 中选择了比较简单的回调函数模式，下面来看一下 React 的例子</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.cb();</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Child</span><br><span class="line">        cb=&#123;() =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"update"</span>);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="爷孙组件"><a href="#爷孙组件" class="headerlink" title="爷孙组件"></a>爷孙组件</h3><p>父子组件其实可以算是爷孙组件的一种特例，这里的爷孙组件不光指爷爷和孙子，而是泛指祖先与后代组件通信，可能隔着很多层级，我们已经解决了父子组件通信的问题，根据化归法，很容易得出爷孙组件的答案，那就是层层传递属性么，把爷孙组件通信分解为多个父子组件通信的问题</p><p>层层传递的优点是非常简单，用已有知识就能解决，问题是会浪费很多代码，非常繁琐，中间作为桥梁的组件会引入很多不属于自己的属性</p><p>在 React 中，通过 context 可以让祖先组件直接把属性传递到后代组件，有点类似星际旅行中的虫洞一样，通过 context 这个特殊的桥梁，可以跨越任意层次向后代组件传递消息</p><p>怎么在需要通信的组件之间开启这个虫洞呢？需要双向声明，也就是在祖先组件声明属性，并在后代组件上再次声明属性，然后在祖先组件上放上属性就可以了，就可以在后代组件读取属性了，下面看一个例子</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 后代组件声明需要读取context上的数据</span></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    text: PropTypes.string,</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 通过this.context 读取context上的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.context.text&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ancestor</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 祖先组件声明需要放入context上的数据</span></span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    text: PropTypes.string,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 祖先组件往context放入数据</span></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">text</span>: <span class="string">"yanhaijing"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>context 的优点是可以省去层层传递的麻烦，并且通过双向声明控制了数据的可见性，对于层数很多时，不失为一种方案；但缺点也很明显，就像全局变量一样，如果不加节制很容易造成混乱，而且也容易出现重名覆盖的问题</p><p>个人的建议是对一些所有组件共享的只读信息可以采用 context 来传递，比如登录的用户信息等</p><p><em>小贴士：React Router 路由就是通过 context 来传递路由属性的</em></p><h3 id="兄弟组件"><a href="#兄弟组件" class="headerlink" title="兄弟组件"></a>兄弟组件</h3><p>如果两个组件是兄弟关系，可以通过父组件作为桥梁，来让两个组件之间通信，这其实就是主模块模式</p><p>下面的例子中，两个子组件通过父组件来实现显示数字同步的功能</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.onChange = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;num&#125;)</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Child1 num=&#123;<span class="keyword">this</span>.state.num&#125; onChange=&#123;<span class="keyword">this</span>.onChange&#125;&gt;</span><br><span class="line">                &lt;Child2 num=&#123;<span class="keyword">this</span>.state.num&#125; onChange=&#123;<span class="keyword">this</span>.onChange&#125;&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>主模块模式的优点就是解耦，把两个子组件之间的耦合关系，解耦成子组件和父组件之间的耦合，把分散的东西收集在一起好处非常明显，能带来更好的可维护性和可扩展性</p><h3 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h3><p>任意组件包括上面的三种关系组件，上面三种关系应该优先使用上面介绍的方法，对于任意的两个组件间通信，总共有三种办法，分别是共同祖先法，消息中间件和状态管理</p><p>基于我们上面介绍的爷孙组件和兄弟组件，只要找到两个组件的共同祖先，就可以将任意组件之间的通信，转化为任意组件和共同祖先之间的通信，这个方法的好处就是非常简单，已知知识就能搞定，缺点就是上面两种模式缺点的叠加，除了临时方案，不建议使用这种方法</p><p>另一种比较常用的方法是消息中间件，就是引入一个全局消息工具，两个组件通过这个全局工具进行通信，这样两个组件间的通信，就通过全局消息媒介完成了</p><p>还记得上面介绍的消息基类吗？下面的例子中，组件 1 和组件 2 通过全局 event 进行通信</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEimtter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.eventMap = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  sub(name, cb) &#123;</span><br><span class="line">    <span class="keyword">const</span> eventList = (<span class="keyword">this</span>.eventMap[name] = <span class="keyword">this</span>.eventMap[name] || &#123;&#125;);</span><br><span class="line">    eventList.push(cb);</span><br><span class="line">  &#125;</span><br><span class="line">  pub(name, ...data) &#123;</span><br><span class="line">    (<span class="keyword">this</span>.eventMap[name] || []).forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(...data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局消息工具</span></span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> EventEimtter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element1</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 订阅消息</span></span><br><span class="line">    event.sub(<span class="string">"element2update"</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"element2 update"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个组件。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element2</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 发布消息</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      event.pub(<span class="string">"element2update"</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息中间件的模式非常简单，利用了观察者模式，将两个组件之间的耦合解耦成了组件和消息中心+消息名称的耦合，但为了解耦却引入全局消息中心和消息名称，消息中心对组件的侵入性很强，和第三方组件通信不能使用这种方式</p><p>小型项目比较适合使用这种方式，但随着项目规模的扩大，达到中等项目以后，消息名字爆炸式增长，消息名字的维护成了棘手的问题，重名概率极大，没有人敢随便删除消息信息，消息的发布者找不到消息订阅者的信息等</p><p>其实上面的问题也不是没有解决办法，重名的问题可以通过制定规范，消息命名空间等方式来极大降低冲突，其他问题可以通过把消息名字统一维护到一个文件，通过对消息的中心化管理，可以让很多问题都很容易解决</p><p>如果你的项目非常大，上面两种方案都不合适，那你可能需要一个状态管理工具，通过状态管理工具把组件之间的关系，和关系的处理逻辑从组建中抽象出来，并集中化到统一的地方来处理，Redux 就是一个非常不错的状态管理工具</p><p>除了 Redux，还有 Mobx，Rematch，reselect 等工具，本文不展开介绍，有机会后面单独成文，这些都是用来解决不同问题的，只要根据自己的场景选择合适的工具就好了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>组件间的关系千变万化，都可以用上面介绍的方法解决，对于不同规模的项目，应该选择适合自己的技术方案，上面介绍的不同方式解耦的程度是不一样的，关于不同耦合关系的好坏，可以看我之前的文章《<a href="/archives/7e29.html">图解 7 种耦合关系</a>》</p>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>鸡汤</title>
    <url>/archives/201.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">这是篇有密码的博客</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="5b9dad6ad430e2a1475798d82df782c0c80f5b27927841870d9db518c99cd4ec">6163e80b1e469ae844d76f162f056d3514172c491a032e3209434d9bc4e90214da5fae298d84348e61e29e72e7f9a8f9eb565dc6f5f9b76968faa650b79de07fc121b927bed37a0c6f27555c9844a414cf2d5f72d2885aa3682201e46ddd10cf8bfaceab3affc3ff4b6814ba00b7ab9e7edc9c50d6722f612eba622bfc59b911d449bd3de023731e9782fc4e33965a19816ced21aef4cdf21e06ee65fea78df1d0a88dbd50a1a0abf0e0fe5d4d0f88ba5aec753382442b45c9af94115e650142f94af335405719c916981de5a2e2f63352d3f52b2dea8ac7a6b460f2e566100af908ab5fb21553d0d7dc43027dd7809ebd046f92537c11a16ec90c23a4013fd6391b7ca906b9119bcb72ed11302c596bcb4e4fabf430b03b6b0e9469d8e66aed3a99aa52c057648e72de462d233a788c70e0ea655a497517f64b08d7256cd1782564ce87a589618cc9f7b13a0e51964ae0c57c04d385f7b21d964a322149cfdafb18e7ae6475141c27a0942b590bc400d79d005ce85fa187162fe824e16a9cdd845173ae7a2aec0d7ac363bc93415a0e9fbbfec6b91e457ddcad4522792539fafeb6968ec2f24c32f059fd97ba092078584c84bbd799049c3cf48aa36a27ea218d269a6b69649e5d261cd6ae385e6f62498a3b61411af6ac3ac8961dd7662222f9855ef3d2b8a8e55f96a48e574e62f1d119293bbbc0ae1ece9872576a2bdccef78d1edf793f6d57636dfb82221d423525561f23675fc1f129c3829b2654e850b2d9dbf744171f900ec4bebac9819239bdfad1e46c15d1c1ec2a1bd71ae7ec4948588e9efe68183ab8feb8bb854ce25f558427f870d6588631b9711b629469f75512511b34a3ec1a2dc741fd059c0cdd8b2ef086bccc906d845eda80159de4cd3bea44aab6a097b1b6763050a77df252b4a147d42d69e88cc1894006b207327b5c188dcef8a4fb912cc2d1edf3ef4ba172700de734d72d535945363c4e970ef78b88c4f6706421caacafb57cd1fb0672a088f7441b933c3056f7f038c7319c4c0a99594f844fd4a0a9add83d4a65983f47be0325ed01a603cb8c45cbd62b58103dbf3e7cc67f6e168ca1472821fabb4b33704c37e41d6b73b44494694dd32a9cd156a32833dff335d87a1816acaf193f7583552fddb6493f5bcfaf889dcf13b648e432cec1801b97b7690267d42ff18107b83aea88b017b92369a29bb2c926116ba21cd4ecf6eb6c44b9aaaf94f6cbf569610c1c80968320164d68e20a8d742599dc33b0b231d75c2ea173159611f0487340e8940793db581c3e1f4b689a0911ea36565ceaa7e2b9568f8f6397316901e2e4e6fe43f512be44522ed817ddcf8d9b696376dcdcebdecdc58001011fbf1a698b0933512c0a5da0205c4b3a9aa77495c9a469002c0bec0c26c13c9195a514d3097271eb09f466d4888973af96adc4631f6321d834918941f98897ed1a99a3c9692113a0da96becd0ce71bb7e5937863da74a12ac0e4780587a8904b7199a5f22afe43bfe40ca61753a6e39d6848679436d8e2e897a71bfbeed788eee43c774b89becd9aaac7a127072a9c1c8c66ed003aeb0b8dc85c5823de8b436915d5bd633c3ccef3eacd995b5a32000d8b95095d17b11f731518b4fff472951f244e6fdf4758aff0a6166f47dabdac6af46608c64e1dc8f3213c0579bb3b3950b53b391c6f8c1d65ea5ff250e42af1e8ba7771635560b562ff3df6c8e4ab865911db1e25b3794cef75efcf5bd6765988ad2c289d64b88689ff498b0d0e1dbf9a388d471d73bfbdd8f6294593791aa9714d65eaeb30c0a1673a38d018cb96d84088b69f1ea1afb1d8ae8aba07d3ff5118d7270c060a3404b2651d18e6b1b818396ca08a7dbb82e86fdc0af6b0954229c346c77a769b059a9b1455ca185f0731e12f1788181ed6ce2c1e7e8f2a5c7b89f2d7eb43762c0639b66c35ebfb5a716cb4b52829dfe1bed6579f0eeeb0ece1d35918b5e8427869ac9b2dd347a9ba070696920f7a1730b7c4c1ad0f17f42e213ebd121b9ac47fcad3fd8c66462f2046a4f4b2083aaa3a5425cd5a6fafcb65f8c9e372ca9b7c5e1b9edf82893f13203ffd5ce4b43fa005638f70e88494af502a386884e3d4f4cdcc81b7d7da4a57e0176b711ecc87f4cb933f84ca46c047093e600092fe477b394f1f3d31f36dffcb57b6d3eb65433c0360ceec317ed8bb737099a8aa875ab0f9e8df1873bd6f1ca563cfacfb06983158903bfb6dc5924d9c1234915f4bd17ca1cef7ae5d751f392cdd08ef50b7f63723365fe73daa8d53abd9423c82f265fa3826d460e515a3eb02d215936321e2efe2af2476dc8dc9c05fe8f1b331a7ae7f2f179c5889c092c817f4bc9d311bccb539588133f08bd9e2f02cb01e1b1cf1aa4971e5b626ca40d733c4b1752da7940ce08bd638265cb862ff4f1bf3e3eaefdedd31932566412219513480f019b670b2f4f78458b353bcc7ddd7ec5c6619070d27c9719831d9066b9cdeea359c07b8bea474a73dbcaa42b3d9ffa2b1674f3d2041da65409800e377df26af5d8bcdc5b191e277967ef703cd85a9cd4b79c06fd0999bbb96eddd9bf88c915cf6f5ecec06c5e6ff4743a4b18743737f0695b2841adb2194cda6c249f6db5d34f0ef5abfdb5f89eea0984a8b4c70ae48a6ecf746ffd86c23502c3147edcdd244c577567e866bb7cb53e87d2ad9613ac3d97a0ce912571a555a2171a055dd68881396780a1635cc6ed3ca84f7be134a39224b239c326e8cb37082d1691854070945d3d475e9366076780862b2ade2b7e77467179e7107b039fab8b6ebe58f4ce61ea611d600068a466897a012c37e8bcf23f32c1a0af4c40268470c02d87c37274c79c70f9e47fcaca0688fc4f3846d67f4fc111ef6a65ccf1b80625b6c02c8b2ea244c7caf0a067ed6fe2fb5732730a976b2066aae5c1164a985dc5fd1674184ee1a3031aa2315a2ffea7fa445f4bdf9a3c7e0f16119c50a6c53a07aa3f07a9b5e11ffb62b88bce882c28a2a8e59862aec953af2499dcd7848e7534c3e8ca2cbebce61c2da51f5a8727e5894b63211149596f4c701740b42f89763a27304c9532fc661b27dcc91283061366be8ddc6a4d93115dcc3b09e178f3d9ddc805c1d71613296e4bb9fc13a31fee920e699f47aa3f69374ffd6817fbfe8bd11fb58be6eb2707b53127c84404ac26cf2993aa73c49cebb84167543ddd4836de7890f3461419271351fe2ee68163a8258335f9e3ab3504275137c3e96b0622d8a9df5b91239e8bd9fa23ac47aca0539b6a82ac07cae78bb3b</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>A Complete Guide to useEffect（中文版）</title>
    <url>/archives/4233.html</url>
    <content><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/</a></p></blockquote><p>你用 <a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">Hooks</a> 写了一些组件，甚或写了一个小型应用。你可能很满意，使用它的 API 很舒服并且在这个过程中获得了一些小技巧。你甚至可能写了一些 <a href="https://reactjs.org/docs/hooks-custom.html" target="_blank" rel="noopener">custom Hooks</a> 去抽离重复的逻辑（精简掉了 300 行代码），并且得意地展示给你的同事看，“干得漂亮”，他们如是说。</p><p>但有时候当你使用<code>useEffect</code>你总觉得哪儿有点不对劲。你会嘀咕你可能遗漏了什么。它看起来像 class 的生命周期… 但真的是这样吗？你发觉自己在问类似下面的这些问题：</p><ul><li>🤔 如何用<code>useEffect</code>模拟<code>componentDidMount</code>生命周期？</li><li>🤔 如何正确地在<code>useEffect</code>里请求数据？<code>[]</code>又是什么？</li><li>🤔 我应该把函数当做 effect 的依赖吗？</li><li>🤔 为什么有时候会出现无限重复请求的问题？</li><li>🤔 为什么有时候在 effect 里拿到的是旧的 state 或 prop？</li></ul><p>当我刚开始使用 Hooks 的时候，我也同样被上面这些问题所困扰。甚至当我写最初的文档时，我也并没有扎实地掌握某些细节。我经历了一些 “啊哈” 的开窍时刻，我想把这些分享给你。<strong>这篇文章会深入讲解帮你明白上面问题的答案。</strong></p><p>在看答案之前，我们需要先往后退一步。这篇文章的目的不是给你一个要点清单，而是想帮你真正地领会<code>useEffect</code>。其实我们并没有太多需要学习的，事实上，我们会花很多时间试图忘记某些已经习得的概念（unlearning）。</p><p><strong>当我不再透过熟悉的 class 生命周期方法去窥视<code>useEffect</code> 这个 Hook 的时候，我才得以融会贯通。</strong></p><blockquote><p>“忘记你已经学到的。” — Yoda</p></blockquote><p><a href="https://overreacted.io/static/6203a1f1f2c771816a5ba0969baccd12/5ed8a/yoda.jpg" target="_blank" rel="noopener"><img src="https://overreacted.io/static/6203a1f1f2c771816a5ba0969baccd12/5ed8a/yoda.jpg" alt></a></p><p><strong>这篇文章会假设你对 <a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener"><code>useEffect</code></a> API 有一定程度的了解。</strong></p><p><strong>这篇文章真的很长。它更像一本 mini 书，这也是我更喜欢的形式。如果你很匆忙或者并不是太关心本文主题的话，你也可以直接看下面的摘要。</strong></p><p><strong>如果你对于深入研究感觉不是很适应的话，你或许可以等下面这些解释出现在其他文章中再去了解也行。就像 2013 年 React 刚出世的时候，大家需要时间去理解消化一种不同的心智模型。知识也需要时间去普及。</strong></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><a href="#%E6%91%98%E8%A6%81"></a>摘要</h2><p>如果你不想阅读整篇文章，可以快速浏览这份摘要。要是某些部分不容易理解，你可以往下滚动寻找相关的内容去阅读。</p><p>如果你打算阅读整篇文章，你完全可以跳过这部分。我会在文章末尾带上摘要的链接。</p><p><strong>🤔 Question: 如何用<code>useEffect</code>模拟<code>componentDidMount</code>生命周期？</strong></p><p>虽然可以使用<code>useEffect(fn, [])</code>，但它们并不完全相等。和<code>componentDidMount</code>不一样，<code>useEffect</code>会_捕获_ props 和 state。所以即便在回调函数里，你拿到的还是初始的 props 和 state。如果你想得到 “最新” 的值，你可以使用 ref。不过，通常会有更简单的实现方式，所以你并不一定要用 ref。记住，effects 的心智模型和<code>componentDidMount</code>以及其他生命周期是不同的，试图找到它们之间完全一致的表达反而更容易使你混淆。想要更有效，你需要 “think in effects”，它的心智模型更接近于实现状态同步，而不是响应生命周期事件。</p><p><strong>🤔 Question: 如何正确地在<code>useEffect</code>里请求数据？<code>[]</code>又是什么？</strong></p><p><a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="noopener">这篇文章</a> 是很好的入门，介绍了如何在<code>useEffect</code>里做数据请求。请务必读完它！它没有我的这篇这么长。<code>[]</code>表示 effect 没有使用任何 React 数据流里的值，因此该 effect 仅被调用一次是安全的。<code>[]</code>同样也是一类常见问题的来源，也即你以为没使用数据流里的值但其实使用了。你需要学习一些策略（主要是<code>useReducer</code> 和 <code>useCallback</code>）来移除这些 effect 依赖，而不是错误地忽略它们。</p><p><strong>🤔 Question: 我应该把函数当做 effect 的依赖吗？</strong></p><p>一般建议把不依赖 props 和 state 的函数提到你的组件外面，并且把那些仅被 effect 使用的函数放到 effect 里面。如果这样做了以后，你的 effect 还是需要用到组件内的函数（包括通过 props 传进来的函数），可以在定义它们的地方用<code>useCallback</code>包一层。为什么要这样做呢？因为这些函数可以访问到 props 和 state，因此它们会参与到数据流中。我们官网的 FAQ 有<a href="https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" target="_blank" rel="noopener">更详细的答案</a>。</p><p><strong>🤔 Question: 为什么有时候会出现无限重复请求的问题？</strong></p><p>这个通常发生于你在 effect 里做数据请求并且没有设置 effect 依赖参数的情况。没有设置依赖，effect 会在每次渲染后执行一次，然后在 effect 中更新了状态引起渲染并再次触发 effect。无限循环的发生也可能是因为你设置的依赖总是会改变。你可以通过一个一个移除的方式排查出哪个依赖导致了问题。但是，移除你使用的依赖（或者盲目地使用<code>[]</code>）通常是一种错误的解决方式。你应该做的是解决问题的根源。举个例子，函数可能会导致这个问题，你可以把它们放到 effect 里，或者提到组件外面，或者用<code>useCallback</code>包一层。<code>useMemo</code> 可以做类似的事情以避免重复生成对象。</p><p><strong>🤔 为什么有时候在 effect 里拿到的是旧的 state 或 prop 呢？</strong></p><p>Effect 拿到的总是定义它的那次渲染中的 props 和 state。这能够<a href="https://overreacted.io/how-are-function-components-different-from-classes/" target="_blank" rel="noopener">避免一些 bugs</a>，但在一些场景中又会有些讨人嫌。对于这些场景，你可以明确地使用可变的 ref 保存一些值（上面文章的末尾解释了这一点）。如果你觉得在渲染中拿到了一些旧的 props 和 state，且不是你想要的，你很可能遗漏了一些依赖。可以尝试使用这个 <a href="https://github.com/facebook/react/issues/14920" target="_blank" rel="noopener">lint 规则</a>来训练你发现这些依赖。可能没过几天，这种能力会变得像是你的第二天性。同样可以看我们官网 FAQ 中的<a href="https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function" target="_blank" rel="noopener">这个回答。</a></p><p>我希望这个摘要对你有所帮助！要不，我们开始正文。</p><h2 id="每一次渲染都有它自己的-Props-and-State"><a href="#每一次渲染都有它自己的-Props-and-State" class="headerlink" title="每一次渲染都有它自己的 Props and State"></a><a href="#%E6%AF%8F%E4%B8%80%E6%AC%A1%E6%B8%B2%E6%9F%93%E9%83%BD%E6%9C%89%E5%AE%83%E8%87%AA%E5%B7%B1%E7%9A%84-props-and-state"></a>每一次渲染都有它自己的 Props and State</h2><p>在我们讨论 effects 之前，我们需要先讨论一下渲染（rendering）。</p><p>我们来看一个计数器组件 Counter，注意高亮的那一行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高亮的代码究竟是什么意思呢？<code>count</code> 会 “监听” 状态的变化并自动更新吗？这么想可能是学习 React 的时候有用的第一直觉，但它并不是<a href="https://overreacted.io/react-as-a-ui-runtime/" target="_blank" rel="noopener">精确的心智模型</a>。</p><p><strong>上面例子中，<code>count</code>仅是一个数字而已。</strong>它不是神奇的 “data binding”, “watcher”, “proxy”，或者其他任何东西。它就是一个普通的数字像下面这个一样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const count = 42;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>我们的组件第一次渲染的时候，从<code>useState()</code>拿到<code>count</code>的初始值<code>0</code>。当我们调用<code>setCount(1)</code>，React 会再次渲染组件，这一次<code>count</code>是<code>1</code>。如此等等：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const count = 0;   </span><br><span class="line">  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const count = 1;   </span><br><span class="line">  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const count = 2;   </span><br><span class="line">  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当我们更新状态的时候，React 会重新渲染组件。每一次渲染都能拿到独立的<code>count</code> 状态，这个状态值是函数中的一个常量。</strong></p><p>所以下面的这行代码没有做任何特殊的数据绑定：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><strong>它仅仅只是在渲染输出中插入了 count 这个数字。</strong>这个数字由 React 提供。当<code>setCount</code>的时候，React 会带着一个不同的<code>count</code>值再次调用组件。然后，React 会更新 DOM 以保持和渲染输出一致。</p><p>这里关键的点在于任意一次渲染中的<code>count</code>常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的<code>count</code>值独立于其他渲染。</p><p><em>（关于这个过程更深入的探讨可以查看我的另一篇文章 <a href="https://overreacted.io/react-as-a-ui-runtime/" target="_blank" rel="noopener">React as a UI Runtime</a>。）</em></p><h2 id="每一次渲染都有它自己的事件处理函数"><a href="#每一次渲染都有它自己的事件处理函数" class="headerlink" title="每一次渲染都有它自己的事件处理函数"></a><a href="#%E6%AF%8F%E4%B8%80%E6%AC%A1%E6%B8%B2%E6%9F%93%E9%83%BD%E6%9C%89%E5%AE%83%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"></a>每一次渲染都有它自己的事件处理函数</h2><p>到目前为止一切都还好。那么事件处理函数呢？</p><p>看下面的这个例子。它在三秒后会 alert 点击次数<code>count</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  function handleAlertClick() &#123;    setTimeout(() =&gt; &#123;      alert(&apos;You clicked on: &apos; + count);    &#125;, 3000);  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleAlertClick&#125;&gt;        Show alert      &lt;/button&gt;    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我按照下面的步骤去操作：</p><ul><li><strong>点击增加</strong> counter 到 3</li><li><strong>点击一下</strong> “Show alert”</li><li><strong>点击增加</strong> counter 到 5 并且在定时器回调触发前完成</li></ul><p><img src="https://overreacted.io/counter-46c55d5f1f749462b7a173f1e748e41e.gif" alt></p><p>你猜 alert 会弹出什么呢？会是 5 吗？— 这个值是 alert 的时候 counter 的实时状态。或者会是 3 吗？— 这个值是我点击时候的状态。</p><p><em>剧透预警</em></p><p>来自己 <a href="https://codesandbox.io/s/w2wxl3yo0l" target="_blank" rel="noopener">试试吧！</a></p><p>如果结果和你预料不一样，你可以想象一个更实际的例子：一个聊天应用在 state 中保存了当前接收者的 ID，以及一个发送按钮。 <a href="https://overreacted.io/how-are-function-components-different-from-classes" target="_blank" rel="noopener">这篇文章</a>深入探索了个中缘由。正确的答案就是 3。</p><p>alert 会 “捕获” 我点击按钮时候的状态。</p><p><em>（虽然有其他办法可以实现不同的行为，但现在我会专注于这个默认的场景。当我们在构建一种心智模型的时候，在可选的策略中分辨出 “最小阻力路径” 是非常重要的。）</em></p><p>但它究竟是如何工作的呢？</p><p>我们发现<code>count</code>在每一次函数调用中都是一个常量值。值得强调的是 — <strong>我们的组件函数每次渲染都会被调用，但是每一次调用中<code>count</code>值都是常量，并且它被赋予了当前渲染中的状态值。</strong></p><p>这并不是 React 特有的，普通的函数也有类似的行为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sayHi(person) &#123;</span><br><span class="line">  const name = person.name;  setTimeout(() =&gt; &#123;</span><br><span class="line">    alert(&apos;Hello, &apos; + name);</span><br><span class="line">  &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let someone = &#123;name: &apos;Dan&apos;&#125;;</span><br><span class="line">sayHi(someone);</span><br><span class="line"></span><br><span class="line">someone = &#123;name: &apos;Yuzhi&apos;&#125;;</span><br><span class="line">sayHi(someone);</span><br><span class="line"></span><br><span class="line">someone = &#123;name: &apos;Dominic&apos;&#125;;</span><br><span class="line">sayHi(someone);</span><br></pre></td></tr></table></figure><p>在 <a href="https://codesandbox.io/s/mm6ww11lk8" target="_blank" rel="noopener">这个例子</a>中, 外层的<code>someone</code>会被赋值很多次（就像在 React 中，_当前_的组件状态会改变一样）。<strong>然后，在<code>sayHi</code>函数中，局部常量<code>name</code>会和某次调用中的<code>person</code>关联。</strong>因为这个常量是局部的，所以每一次调用都是相互独立的。结果就是，当定时器回调触发的时候，每一个 alert 都会弹出它拥有的<code>name</code>。</p><p>这就解释了我们的事件处理函数如何捕获了点击时候的<code>count</code>值。如果我们应用相同的替换原理，每一次渲染 “看到” 的是它自己的<code>count</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const count = 0;   </span><br><span class="line">  function handleAlertClick() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      alert(&apos;You clicked on: &apos; + count);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const count = 1;   </span><br><span class="line">  function handleAlertClick() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      alert(&apos;You clicked on: &apos; + count);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const count = 2;   </span><br><span class="line">  function handleAlertClick() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      alert(&apos;You clicked on: &apos; + count);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以实际上，每一次渲染都有一个 “新版本” 的<code>handleAlertClick</code>。每一个版本的<code>handleAlertClick</code>“记住” 了它自己的 <code>count</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  function handleAlertClick() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      alert(&apos;You clicked on: &apos; + 0);    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  function handleAlertClick() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      alert(&apos;You clicked on: &apos; + 1);    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  function handleAlertClick() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      alert(&apos;You clicked on: &apos; + 2);    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是为什么<a href="https://codesandbox.io/s/w2wxl3yo0l" target="_blank" rel="noopener">在这个 demo 中</a>中，事件处理函数 “属于” 某一次特定的渲染，当你点击的时候，它会使用那次渲染中<code>counter</code>的状态值。</p><p><strong>在任意一次渲染中，props 和 state 是始终保持不变的。</strong>如果 props 和 state 在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都 “属于” 一次特定的渲染。即便是事件处理中的异步函数调用 “看到” 的也是这次渲染中的<code>count</code>值。</p><p><em>备注：上面我将具体的<code>count</code>值直接内联到了<code>handleAlertClick</code>函数中。这种心智上的替换是安全的因为<code>count</code> 值在某次特定渲染中不可能被改变。它被声明成了一个常量并且是一个数字。这样去思考其他类型的值比如对象也同样是安全的，当然需要在我们都同意应该避免直接修改 state 这个前提下。通过调用<code>setSomething(newObj)</code>的方式去生成一个新的对象而不是直接修改它是更好的选择，因为这样能保证之前渲染中的 state 不会被污染。</em></p><h2 id="每次渲染都有它自己的-Effects"><a href="#每次渲染都有它自己的-Effects" class="headerlink" title="每次渲染都有它自己的 Effects"></a><a href="#%E6%AF%8F%E6%AC%A1%E6%B8%B2%E6%9F%93%E9%83%BD%E6%9C%89%E5%AE%83%E8%87%AA%E5%B7%B1%E7%9A%84effects"></a>每次渲染都有它自己的 Effects</h2><p>这篇文章是关于 effects 的，但目前我们居然还没有讨论 effects！ 言归正传，由上面的分析得出一个结果，effects 其实并没有什么两样。</p><p>让我们回到<a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener">官网文档</a>中的这个例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;    document.title = `You clicked $&#123;count&#125; times`;  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抛一个问题给你：effect 是如何读取到最新的<code>count</code> 状态值的呢？</strong></p><p>也许，是某种 “data binding” 或“watching”机制使得<code>count</code>能够在 effect 函数内更新？也或许<code>count</code>是一个可变的值，React 会在我们组件内部修改它以使我们的 effect 函数总能拿到最新的值？</p><p>都不是。</p><p>我们已经知道<code>count</code>是某个特定渲染中的常量。事件处理函数 “看到” 的是属于它那次特定渲染中的<code>count</code>状态值。对于 effects 也同样如此：</p><p><strong>并不是<code>count</code>的值在 “不变” 的 effect 中发生了改变，而是 <em>effect 函数本身</em>在每一次渲染中都不相同。</strong></p><p>每一个 effect 版本 “看到” 的<code>count</code>值都来自于它属于的那次渲染：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">        () =&gt; &#123;      document.title = `You clicked $&#123;0&#125; times`;    &#125;  );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">        () =&gt; &#123;      document.title = `You clicked $&#123;1&#125; times`;    &#125;  );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">        () =&gt; &#123;      document.title = `You clicked $&#123;2&#125; times`;    &#125;  );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 会记住你提供的 effect 函数，并且会在每次更改作用于 DOM 并让浏览器绘制屏幕后去调用它。</p><p>所以虽然我们说的是一个 <em>effect</em>（这里指更新 document 的 title），但其实每次渲染都是一个<em>不同的函数</em> — 并且每个 effect 函数 “看到” 的 props 和 state 都来自于它属于的那次特定渲染。</p><p><strong>概念上，你可以想象 effects 是渲染结果的一部分。</strong></p><p>严格地说，它们并不是（为了<a href="https://overreacted.io/why-do-hooks-rely-on-call-order/" target="_blank" rel="noopener">允许 Hook 的组合</a>并且不引入笨拙的语法或者运行时）。但是在我们构建的心智模型上，effect 函数_属于_某个特定的渲染，就像事件处理函数一样。</p><p>为了确保我们已经有了扎实的理解，我们再回顾一下第一次的渲染过程：</p><ul><li><strong>React:</strong> 给我状态为 <code>0</code>时候的 UI。</li><li><p><strong>你的组件:</strong></p><ul><li>给你需要渲染的内容: <code>&lt;p&gt;You clicked 0 times&lt;/p&gt;</code>。</li><li>记得在渲染完了之后调用这个 effect: <code>() =&gt; { document.title = &#39;You clicked 0 times&#39; }</code>。</li></ul></li><li><strong>React:</strong> 没问题。开始更新 UI，喂浏览器，我要给 DOM 添加一些东西。</li><li><strong>浏览器:</strong> 酷，我已经把它绘制到屏幕上了。</li><li><p><strong>React:</strong> 好的， 我现在开始运行给我的 effect</p><ul><li>运行 <code>() =&gt; { document.title = &#39;You clicked 0 times&#39; }</code>。</li></ul></li></ul><p>现在我们回顾一下我们点击之后发生了什么：</p><ul><li><strong>你的组件:</strong> 喂 React, 把我的状态设置为<code>1</code>。</li><li><strong>React:</strong> 给我状态为 <code>1</code>时候的 UI。</li><li><p><strong>你的组件:</strong></p><ul><li>给你需要渲染的内容: <code>&lt;p&gt;You clicked 1 times&lt;/p&gt;</code>。</li><li>记得在渲染完了之后调用这个 effect： <code>() =&gt; { document.title = &#39;You clicked 1 times&#39; }</code>。</li></ul></li><li><strong>React:</strong> 没问题。开始更新 UI，喂浏览器，我修改了 DOM。</li><li><strong>Browser:</strong> 酷，我已经将更改绘制到屏幕上了。</li><li><p><strong>React:</strong> 好的， 我现在开始运行属于这次渲染的 effect</p><ul><li>运行 <code>() =&gt; { document.title = &#39;You clicked 1 times&#39; }</code>。</li></ul></li></ul><h2 id="每一次渲染都有它自己的…-所有"><a href="#每一次渲染都有它自己的…-所有" class="headerlink" title="每一次渲染都有它自己的… 所有"></a><a href="#%E6%AF%8F%E4%B8%80%E6%AC%A1%E6%B8%B2%E6%9F%93%E9%83%BD%E6%9C%89%E5%AE%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%89%80%E6%9C%89"></a>每一次渲染都有它自己的… 所有</h2><p><strong>我们现在知道 effects 会在每次渲染后运行，并且概念上它是组件输出的一部分，可以 “看到” 属于某次特定渲染的 props 和 state。</strong></p><p>我们来做一个思想实验，思考下面的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(`You clicked $&#123;count&#125; times`);    &#125;, 3000);  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我点击了很多次并且在 effect 里设置了延时，打印出来的结果会是什么呢？</p><p><em>剧透预警</em></p><p>你可能会认为这是一个很绕的题并且结果是反直觉的。完全错了！我们看到的就是顺序的打印输出 — 每一个都属于某次特定的渲染，因此有它该有的<code>count</code>值。你可以<a href="https://codesandbox.io/s/lyx20m1ol" target="_blank" rel="noopener">自己试一试</a>：</p><p><img src="https://overreacted.io/timeout_counter-a5727d333c270e05942f508707265378.gif" alt></p><p>你可能会想：“它当然应该是这样的。否则还会怎么样呢？”</p><p>不过，class 中的<code>this.state</code>并不是这样运作的。你可能会想当然以为下面的 <a href="https://codesandbox.io/s/kkymzwjqz3" target="_blank" rel="noopener">class 实现</a>和上面是相等的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentDidUpdate() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(`You clicked $&#123;this.state.count&#125; times`);</span><br><span class="line">  &#125;, 3000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，<code>this.state.count</code>总是指向_最新_的 count 值，而不是属于某次特定渲染的值。所以你会看到每次打印输出都是<code>5</code>：</p><p><img src="https://overreacted.io/timeout_counter_class-264b329edc111a1973003bdf2bcacd65.gif" alt></p><p>我觉得 Hooks 这么依赖 Javascript 闭包是挺讽刺的一件事。有时候组件的 class 实现方式会受闭包相关的苦（<a href="https://wsvincent.com/javascript-closure-settimeout-for-loop/" target="_blank" rel="noopener">the canonical wrong-value-in-a-timeout confusion</a>），但其实这个例子中真正的混乱来源是可变数据（React 修改了 class 中的<code>this.state</code>使其指向最新状态），并不是闭包本身的错。</p><p><strong>当封闭的值始终不会变的情况下闭包是非常棒的。这使它们非常容易思考因为你本质上在引用常量。</strong>正如我们所讨论的，props 和 state 在某个特定渲染中是不会改变的。顺便说一下，我们可以<a href="https://codesandbox.io/s/w7vjo07055" target="_blank" rel="noopener">使用闭包</a>修复上面的 class 版本…</p><h2 id="逆潮而动"><a href="#逆潮而动" class="headerlink" title="逆潮而动"></a><a href="#%E9%80%86%E6%BD%AE%E8%80%8C%E5%8A%A8"></a>逆潮而动</h2><p>到目前为止，我们可以明确地喊出下面重要的事实：<strong>每一个</strong>组件内的函数（包括事件处理函数，effects，定时器或者 API 调用等等）会捕获某次渲染中定义的 props 和 state。</p><p>所以下面的两个例子是相等的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Example(props) &#123;</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(props.counter);    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Example(props) &#123;</span><br><span class="line">  const counter = props.counter;  useEffect(() =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(counter);    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在组件内什么时候去读取 props 或者 state 是无关紧要的。</strong>因为它们不会改变。在单次渲染的范围内，props 和 state 始终保持不变。（解构赋值的 props 使得这一点更明显。）</p><p>当然，有时候你可能_想_在 effect 的回调函数里读取最新的值而不是捕获的值。最简单的实现方法是使用 refs，<a href="https://overreacted.io/how-are-function-components-different-from-classes/" target="_blank" rel="noopener">这篇文章</a>的最后一部分介绍了相关内容。</p><p>需要注意的是当你想要从_过去<em>渲染中的函数里读取</em>未来<em>的 props 和 state，你是在逆潮而动。虽然它并没有</em>错_（有时候可能也需要这样做），但它因为打破了默认范式会使代码显得不够 “干净”。这是我们有意为之的，因为它能帮助突出哪些代码是脆弱的，是需要依赖时间次序的。在 class 中，如果发生这种情况就没那么显而易见了。</p><p>下面这个<a href="https://codesandbox.io/s/rm7z22qnlp" target="_blank" rel="noopener">计数器版本</a> 模拟了 class 中的行为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Example() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const latestCount = useRef(count);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">        latestCount.current = count;    setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(`You clicked $&#123;latestCount.current&#125; times`);    &#125;, 3000);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://overreacted.io/timeout_counter_refs-78f7948263dd13b023498b23cb99f4fc.gif" alt></p><p>在 React 中去直接修改值看上去有点怪异。然而，在 class 组件中 React 正是这样去修改<code>this.state</code>的。不像捕获的 props 和 state，你没法保证在任意一个回调函数中读取的<code>latestCount.current</code>是不变的。根据定义，你可以随时修改它。这就是为什么它不是默认行为，而是需要你主动选择这样做。</p><h2 id="那-Effect-中的清理又是怎样的呢？"><a href="#那-Effect-中的清理又是怎样的呢？" class="headerlink" title="那 Effect 中的清理又是怎样的呢？"></a><a href="#%E9%82%A3effect%E4%B8%AD%E7%9A%84%E6%B8%85%E7%90%86%E5%8F%88%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%91%A2%EF%BC%9F"></a>那 Effect 中的清理又是怎样的呢？</h2><p>像 <a href="https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup" target="_blank" rel="noopener">文档中解释的</a>, 有些 effects 可能需要有一个清理步骤。本质上，它的目的是消除副作用（effect)，比如取消订阅。</p><p>思考下面的代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>假设第一次渲染的时候<code>props</code>是<code>{id: 10}</code>，第二次渲染的时候是<code>{id: 20}</code>。你_可能_会认为发生了下面的这些事：</p><ul><li>React 清除了 <code>{id: 10}</code>的 effect。</li><li>React 渲染<code>{id: 20}</code>的 UI。</li><li>React 运行<code>{id: 20}</code>的 effect。</li></ul><p>(事实并不是这样。)</p><p>如果依赖这种心智模型，你可能会认为清除过程 “看到” 的是旧的 props 因为它是在重新渲染之前运行的，新的 effect“看到”的是新的 props 因为它是在重新渲染之后运行的。这种心智模型直接来源于 class 组件的生命周期。不过<strong>它并不精确</strong>。让我们来一探究竟。</p><p>React 只会在<a href="https://medium.com/@dan_abramov/this-benchmark-is-indeed-flawed-c3d6b5b6f97f" target="_blank" rel="noopener">浏览器绘制</a>后运行 effects。这使得你的应用更流畅因为大多数 effects 并不会阻塞屏幕的更新。Effect 的清除同样被延迟了。<strong>上一次的 effect 会在重新渲染后被清除：</strong></p><ul><li><strong>React 渲染<code>{id: 20}</code>的 UI。</strong></li><li>浏览器绘制。我们在屏幕上看到<code>{id: 20}</code>的 UI。</li><li><strong>React 清除<code>{id: 10}</code>的 effect。</strong></li><li>React 运行<code>{id: 20}</code>的 effect。</li></ul><p>你可能会好奇：如果清除上一次的 effect 发生在 props 变成<code>{id: 20}</code>之后，那它为什么还能 “看到” 旧的<code>{id: 10}</code>？</p><p>你曾经来过这里… 🤔</p><p><img src="https://overreacted.io/deja_vu-5fe238cf03a21dfa32af624124fcdcff.gif" alt></p><p>引用上半部分得到的结论:</p><blockquote><p>组件内的每一个函数（包括事件处理函数，effects，定时器或者 API 调用等等）会捕获定义它们的那次渲染中的 props 和 state。</p></blockquote><p>现在答案显而易见。effect 的清除并不会读取 “最新” 的 props。它只能读取到定义它的那次渲染中的 props 值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Example() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">    </span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      ChatAPI.subscribeToFriendStatus(10, handleStatusChange);</span><br><span class="line">            return () =&gt; &#123;        ChatAPI.unsubscribeFromFriendStatus(10, handleStatusChange);      &#125;;    &#125;</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">    </span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      ChatAPI.subscribeToFriendStatus(20, handleStatusChange);</span><br><span class="line">      </span><br><span class="line">      return () =&gt; &#123;</span><br><span class="line">        ChatAPI.unsubscribeFromFriendStatus(20, handleStatusChange);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>王国会崛起转而复归尘土，太阳会脱落外层变为白矮星，最后的文明也迟早会结束。但是第一次渲染中 effect 的清除函数只能看到<code>{id: 10}</code>这个 props。</p><p>这正是为什么 React 能做到在绘制后立即处理 effects — 并且默认情况下使你的应用运行更流畅。如果你的代码需要依然可以访问到老的 props。</p><h2 id="同步，-而非生命周期"><a href="#同步，-而非生命周期" class="headerlink" title="同步， 而非生命周期"></a><a href="#%E5%90%8C%E6%AD%A5%EF%BC%8C-%E8%80%8C%E9%9D%9E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"></a>同步， 而非生命周期</h2><p>我最喜欢 React 的一点是它统一描述了初始渲染和之后的更新。这降低了你程序的<a href="https://overreacted.io/the-bug-o-notation/" target="_blank" rel="noopener">熵</a>。</p><p>比如我有个组件像下面这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Greeting(&#123; name &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;h1 class&gt;</span><br><span class="line">      Hello, &#123;name&#125;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我先渲染<code>&lt;Greeting /&gt;</code>然后渲染<code>&lt;Greeting /&gt;</code>，和我直接渲染<code>&lt;Greeting /&gt;</code>并没有什么区别。在这两种情况中，我最后看到的都是 “Hello, Yuzhi”。</p><p>人们总是说：“重要的是旅行过程，而不是目的地”。在 React 世界中，恰好相反。<strong>重要的是目的，而不是过程。</strong>这就是 JQuery 代码中 <code>$.addClass</code> 或 <code>$.removeClass</code>这样的调用（过程）和 React 代码中声明 CSS 类名<em>应该是什么</em>（目的）之间的区别。</p><p><strong>React 会根据我们当前的 props 和 state 同步到 DOM。</strong>“mount”和 “update” 之于渲染并没有什么区别。</p><p>你应该以相同的方式去思考 effects。<strong><code>useEffect</code>使你能够根据 props 和 state _同步_ React tree 之外的东西。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Greeting(&#123; name &#125;) &#123;</span><br><span class="line">  useEffect(() =&gt; &#123;    document.title = &apos;Hello, &apos; + name;  &#125;);  return (</span><br><span class="line">    &lt;h1 class&gt;</span><br><span class="line">      Hello, &#123;name&#125;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是和大家熟知的 <em>mount/update/unmount</em> 心智模型之间细微的区别。理解和内化这种区别是非常重要的。<strong>如果你试图写一个 effect 会根据是否第一次渲染而表现不一致，你正在逆潮而动。</strong>如果我们的结果依赖于过程而不是目的，我们会在同步中犯错。</p><p>先渲染属性 A，B 再渲染 C，和立即渲染 C 并没有什么区别。虽然他们可能短暂地会有点不同（比如请求数据时），但最终的结果是一样的。</p><p>不过话说回来，在<em>每一次</em>渲染后都去运行所有的 effects 可能并不高效。（并且在某些场景下，它可能会导致无限循环。）</p><p>所以我们该怎么解决这个问题？</p><h2 id="告诉-React-去比对你的-Effects"><a href="#告诉-React-去比对你的-Effects" class="headerlink" title="告诉 React 去比对你的 Effects"></a><a href="#%E5%91%8A%E8%AF%89react%E5%8E%BB%E6%AF%94%E5%AF%B9%E4%BD%A0%E7%9A%84effects"></a>告诉 React 去比对你的 Effects</h2><p>其实我们已经从 React 处理 DOM 的方式中学习到了解决办法。React 只会更新 DOM 真正发生改变的部分，而不是每次渲染都大动干戈。</p><p>当你把</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 class&gt;</span><br><span class="line">  Hello, Dan</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>更新到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 class&gt;</span><br><span class="line">  Hello, Yuzhi</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>React 能够看到两个对象:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const oldProps = &#123;className: &apos;Greeting&apos;, children: &apos;Hello, Dan&apos;&#125;;</span><br><span class="line">const newProps = &#123;className: &apos;Greeting&apos;, children: &apos;Hello, Yuzhi&apos;&#125;;</span><br></pre></td></tr></table></figure><p>它会检测每一个 props，并且发现<code>children</code>发生改变需要更新 DOM，但<code>className</code>并没有。所以它只需要这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">domNode.innerText = &apos;Hello, Yuzhi&apos;;</span><br></pre></td></tr></table></figure><p><strong>我们也可以用类似的方式处理 effects 吗？如果能够在不需要的时候避免调用 effect 就太好了。</strong></p><p>举个例子，我们的组件可能因为状态变更而重新渲染：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Greeting(&#123; name &#125;) &#123;</span><br><span class="line">  const [counter, setCounter] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    document.title = &apos;Hello, &apos; + name;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;h1 class&gt;</span><br><span class="line">      Hello, &#123;name&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCounter(counter + 1)&#125;&gt;        Increment      &lt;/button&gt;    &lt;/h1&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们的 effect 并没有使用<code>counter</code>这个状态。<strong>我们的 effect 只会同步<code>name</code>属性给<code>document.title</code>，但<code>name</code>并没有变。</strong>在每一次 counter 改变后重新给<code>document.title</code>赋值并不是理想的做法。</p><p>好了，那 React 可以… 区分 effects 的不同吗？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let oldEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;</span><br><span class="line">let newEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;</span><br></pre></td></tr></table></figure><p>并不能。React 并不能猜测到函数做了什么如果不先调用的话。（源码中并没有包含特殊的值，它仅仅是引用了<code>name</code>属性。）</p><p>这是为什么你如果想要避免 effects 不必要的重复调用，你可以提供给<code>useEffect</code>一个依赖数组参数 (deps)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  document.title = &apos;Hello, &apos; + name;</span><br><span class="line">&#125;, [name]);</span><br></pre></td></tr></table></figure><p><strong>这好比你告诉 React：“Hey，我知道你看不到这个函数里的东西，但我可以保证只使用了渲染中的<code>name</code>，别无其他。”</strong></p><p>如果当前渲染中的这些依赖项和上一次运行这个 effect 的时候值一样，因为没有什么需要同步 React 会自动跳过这次 effect：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const oldEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;</span><br><span class="line">const oldDeps = [&apos;Dan&apos;];</span><br><span class="line"></span><br><span class="line">const newEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;</span><br><span class="line">const newDeps = [&apos;Dan&apos;];</span><br></pre></td></tr></table></figure><p>即使依赖数组中只有一个值在两次渲染中不一样，我们也不能跳过 effect 的运行。要同步所有！</p><h2 id="关于依赖项不要对-React-撒谎"><a href="#关于依赖项不要对-React-撒谎" class="headerlink" title="关于依赖项不要对 React 撒谎"></a><a href="#%E5%85%B3%E4%BA%8E%E4%BE%9D%E8%B5%96%E9%A1%B9%E4%B8%8D%E8%A6%81%E5%AF%B9react%E6%92%92%E8%B0%8E"></a>关于依赖项不要对 React 撒谎</h2><p>关于依赖项对 React 撒谎会有不好的结果。直觉上，这很好理解，但我曾看到几乎所有依赖 class 心智模型使用<code>useEffect</code>的人都试图违反这个规则。（我刚开始也这么干了！）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  async function fetchData() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>(官网的 <a href="https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" target="_blank" rel="noopener">Hooks FAQ</a> 解释了应该怎么做。 我们在<a href="#moving-functions-inside-effects">下面</a>会重新回顾这个例子。)</em></p><p>“但我只是想在挂载的时候运行它！”，你可能会说。现在只需要记住：如果你设置了依赖项，<strong>effect 中用到的所有组件内的值都要包含在依赖中。</strong>这包括 props，state，函数 — 组件内的任何东西。</p><p>有时候你是这样做了，但可能会引起一个问题。比如，你可能会遇到无限请求的问题，或者 socket 被频繁创建的问题。<strong>解决问题的方法不是移除依赖项。</strong>我们会很快了解具体的解决方案。</p><p>不过在我们深入解决方案之前，我们先尝试更好地理解问题。</p><h2 id="如果设置了错误的依赖会怎么样呢？"><a href="#如果设置了错误的依赖会怎么样呢？" class="headerlink" title="如果设置了错误的依赖会怎么样呢？"></a><a href="#%E5%A6%82%E6%9E%9C%E8%AE%BE%E7%BD%AE%E4%BA%86%E9%94%99%E8%AF%AF%E7%9A%84%E4%BE%9D%E8%B5%96%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%E5%91%A2%EF%BC%9F"></a>如果设置了错误的依赖会怎么样呢？</h2><p>如果依赖项包含了所有 effect 中使用到的值，React 就能知道何时需要运行它：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  document.title = &apos;Hello, &apos; + name;</span><br><span class="line">&#125;, [name]);</span><br></pre></td></tr></table></figure><p><img src="https://overreacted.io/deps-compare-correct-fae247cd068eedbd4b62ba50592d2b3d.gif" alt></p><p><em>(依赖发生了变更，所以会重新运行 effect。)</em></p><p>但是如果我们将<code>[]</code>设为 effect 的依赖，新的 effect 函数不会运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  document.title = &apos;Hello, &apos; + name;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p><img src="https://overreacted.io/deps-compare-wrong-25f75db3f9f57ffe1426912093577445.gif" alt></p><p><em>(依赖没有变，所以不会再次运行 effect。)</em></p><p>在这个例子中，问题看起来显而易见。但在某些情况下如果你脑子里 “跳出”class 组件的解决办法，你的直觉很可能会欺骗你。</p><p>举个例子，我们来写一个每秒递增的计数器。在 Class 组件中，我们的直觉是：“开启一次定时器，清除也是一次”。这里有一个<a href="https://codesandbox.io/s/n5mjzjy9kl" target="_blank" rel="noopener">例子</a>说明怎么实现它。当我们理所当然地把它用<code>useEffect</code>的方式翻译，直觉上我们会设置依赖为<code>[]</code>。“我只想运行一次 effect”，对吗？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const id = setInterval(() =&gt; &#123;</span><br><span class="line">      setCount(count + 1);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    return () =&gt; clearInterval(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，这个例子<a href="https://codesandbox.io/s/91n5z8jo7r" target="_blank" rel="noopener">只会递增一次</a>。<em>天了噜。</em></p><p>如果你的心智模型是 “只有当我想重新触发 effect 的时候才需要去设置依赖”，这个例子可能会让你产生存在危机。你想要触发一次因为它是定时器 — 但为什么会有问题？</p><p>如果你知道依赖是我们给 React 的暗示，告诉它 effect 所有需要使用的渲染中的值，你就不会吃惊了。effect 中使用了<code>count</code>但我们撒谎说它没有依赖。如果我们这样做迟早会出幺蛾子。</p><p>在第一次渲染中，<code>count</code>是<code>0</code>。因此，<code>setCount(count + 1)</code>在第一次渲染中等价于<code>setCount(0 + 1)</code>。<strong>既然我们设置了<code>[]</code>依赖，effect 不会再重新运行，它后面每一秒都会调用<code>setCount(0 + 1)</code> ：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">    </span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      const id = setInterval(() =&gt; &#123;</span><br><span class="line">        setCount(0 + 1);       &#125;, 1000);</span><br><span class="line">      return () =&gt; clearInterval(id);</span><br><span class="line">    &#125;,</span><br><span class="line">    []   );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">            () =&gt; &#123;</span><br><span class="line">      const id = setInterval(() =&gt; &#123;</span><br><span class="line">        setCount(1 + 1);</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">      return () =&gt; clearInterval(id);</span><br><span class="line">    &#125;,</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对 React 撒谎说我们的 effect 不依赖组件内的任何值，可实际上我们的 effect 有依赖！</p><p>我们的 effect 依赖<code>count</code> - 它是组件内的值（不过在 effect 外面定义）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const count = </span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const id = setInterval(() =&gt; &#123;</span><br><span class="line">    setCount(count + 1);    &#125;, 1000);</span><br><span class="line">  return () =&gt; clearInterval(id);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>因此，设置<code>[]</code>为依赖会引入一个 bug。React 会对比依赖，并且跳过后面的 effect：</p><p><img src="https://overreacted.io/interval-wrong-29e53bd0c9b7d2ac70d3cd924886b030.gif" alt></p><p><em>(依赖没有变，所以不会再次运行 effect。)</em></p><p>类似于这样的问题是很难被想到的。因此，我鼓励你将诚实地告知 effect 依赖作为一条硬性规则，并且要列出所以依赖。（我们提供了一个 <a href="https://github.com/facebook/react/issues/14920" target="_blank" rel="noopener">lint 规则</a>如果你想在你的团队内做硬性规定。）</p><h2 id="两种诚实告知依赖的方法"><a href="#两种诚实告知依赖的方法" class="headerlink" title="两种诚实告知依赖的方法"></a><a href="#%E4%B8%A4%E7%A7%8D%E8%AF%9A%E5%AE%9E%E5%91%8A%E7%9F%A5%E4%BE%9D%E8%B5%96%E7%9A%84%E6%96%B9%E6%B3%95"></a>两种诚实告知依赖的方法</h2><p>有两种诚实告知依赖的策略。你应该从第一种开始，然后在需要的时候应用第二种。</p><p><strong>第一种策略是在依赖中包含所有 effect 中用到的组件内的值。</strong>让我们在依赖中包含<code>count</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const id = setInterval(() =&gt; &#123;</span><br><span class="line">    setCount(count + 1);  &#125;, 1000);</span><br><span class="line">  return () =&gt; clearInterval(id);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure><p>现在依赖数组正确了。虽然它可能不是<em>太理想</em>但确实解决了上面的问题。现在，每次<code>count</code>修改都会重新运行 effect，并且定时器中的<code>setCount(count + 1)</code>会正确引用某次渲染中的 <code>count</code>值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">    </span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      const id = setInterval(() =&gt; &#123;</span><br><span class="line">        setCount(0 + 1);       &#125;, 1000);</span><br><span class="line">      return () =&gt; clearInterval(id);</span><br><span class="line">    &#125;,</span><br><span class="line">    [0]   );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">    </span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      const id = setInterval(() =&gt; &#123;</span><br><span class="line">        setCount(1 + 1);       &#125;, 1000);</span><br><span class="line">      return () =&gt; clearInterval(id);</span><br><span class="line">    &#125;,</span><br><span class="line">    [1]   );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这能<a href="https://codesandbox.io/s/0x0mnlyq8l" target="_blank" rel="noopener">解决问题</a>但是我们的定时器会在每一次<code>count</code>改变后清除和重新设定。这应该不是我们想要的结果：</p><p><img src="https://overreacted.io/interval-rightish-5734271ddfa94d2d65ac6160515e0069.gif" alt></p><p><em>(依赖发生了变更，所以会重新运行 effect。)</em></p><p><strong>第二种策略是修改 effect 内部的代码以确保它包含的值只会在需要的时候发生变更。</strong>我们不想告知错误的依赖 - 我们只是修改 effect 使得依赖更少。</p><p>让我们来看一些移除依赖的常用技巧。</p><h2 id="让-Effects-自给自足"><a href="#让-Effects-自给自足" class="headerlink" title="让 Effects 自给自足"></a><a href="#%E8%AE%A9effects%E8%87%AA%E7%BB%99%E8%87%AA%E8%B6%B3"></a>让 Effects 自给自足</h2><p>我们想去掉 effect 的<code>count</code>依赖。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const id = setInterval(() =&gt; &#123;</span><br><span class="line">    setCount(count + 1);    &#125;, 1000);</span><br><span class="line">  return () =&gt; clearInterval(id);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure><p>为了实现这个目的，我们需要问自己一个问题：<strong>我们为什么要用<code>count</code>？</strong>可以看到我们只在<code>setCount</code>调用中用到了<code>count</code>。在这个场景中，我们其实并不需要在 effect 中使用<code>count</code>。当我们想要根据前一个状态更新状态的时候，我们可以使用<code>setState</code>的<a href="https://reactjs.org/docs/hooks-reference.html#functional-updates" target="_blank" rel="noopener">函数形式</a>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const id = setInterval(() =&gt; &#123;</span><br><span class="line">    setCount(c =&gt; c + 1);    &#125;, 1000);</span><br><span class="line">  return () =&gt; clearInterval(id);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>我喜欢把类似这种情况称为 “错误的依赖”。是的，因为我们在 effect 中写了<code>setCount(count + 1)</code>所以<code>count</code>是一个必需的依赖。但是，我们真正想要的是把<code>count</code>转换为<code>count+1</code>，然后返回给 React。可是 React 其实已经知道当前的<code>count</code>。<strong>我们需要告知 React 的仅仅是去递增状态 - 不管它现在具体是什么值。</strong></p><p>这正是<code>setCount(c =&gt; c + 1)</code>做的事情。你可以认为它是在给 React“发送指令”告知如何更新状态。这种 “更新形式” 在其他情况下也有帮助，比如你需要<a href="https://overreacted.io/react-as-a-ui-runtime/#batching" target="_blank" rel="noopener">批量更新</a>。</p><p><strong>注意我们做到了移除依赖，并且没有撒谎。我们的 effect 不再读取渲染中的<code>count</code>值。</strong></p><p><img src="https://overreacted.io/interval-right-f128ad20c28317ed27a3cb68197fc906.gif" alt></p><p><em>(依赖没有变，所以不会再次运行 effect。)</em></p><p>你可以自己 <a href="https://codesandbox.io/s/q3181xz1pj" target="_blank" rel="noopener">试试</a>。</p><p>尽管 effect 只运行了一次，第一次渲染中的定时器回调函数可以完美地在每次触发的时候给 React 发送<code>c =&gt; c + 1</code>更新指令。它不再需要知道当前的<code>count</code>值。因为 React 已经知道了。</p><h2 id="函数式更新-和-Google-Docs"><a href="#函数式更新-和-Google-Docs" class="headerlink" title="函数式更新 和 Google Docs"></a><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%9B%B4%E6%96%B0-%E5%92%8C-google-docs"></a>函数式更新 和 Google Docs</h2><p>还记得我们说过同步才是理解 effects 的心智模型吗？同步的一个有趣地方在于你通常想要把同步的 “信息” 和状态解耦。举个例子，当你在 Google Docs 编辑文档的时候，Google 并不会把整篇文章发送给服务器。那样做会非常低效。相反的，它只是把你的修改以一种形式发送给服务端。</p><p>虽然我们 effect 的情况不尽相同，但可以应用类似的思想。<strong>只在 effects 中传递最小的信息会很有帮助。</strong>类似于<code>setCount(c =&gt; c + 1)</code>这样的更新形式比<code>setCount(count + 1)</code>传递了更少的信息，因为它不再被当前的 count 值 “污染”。它只是表达了一种行为（“递增”）。“Thinking in React” 也讨论了<a href="https://reactjs.org/docs/thinking-in-react.html#step-3-identify-the-minimal-but-complete-representation-of-ui-state" target="_blank" rel="noopener">如何找到最小状态</a>。原则是类似的，只不过现在关注的是如何更新。</p><p>表达_意图_（而不是结果）和 Google Docs <a href="https://medium.com/@srijancse/how-real-time-collaborative-editing-work-operational-transformation-ac4902d75682" target="_blank" rel="noopener">如何处理</a>共同编辑异曲同工。虽然这个类比略微延伸了一点，函数式更新在 React 中扮演了类似的角色。它们确保能以批量地和可预测的方式来处理各种源头（事件处理函数，effect 中的订阅，等等）的状态更新。</p><p><strong>然而，即使是<code>setCount(c =&gt; c + 1)</code>也并不完美。</strong>它看起来有点怪，并且非常受限于它能做的事。举个例子，如果我们有两个互相依赖的状态，或者我们想基于一个 prop 来计算下一次的 state，它并不能做到。幸运的是， <code>setCount(c =&gt; c + 1)</code>有一个更强大的姐妹模式，它的名字叫<code>useReducer</code>。</p><h2 id="解耦来自-Actions-的更新"><a href="#解耦来自-Actions-的更新" class="headerlink" title="解耦来自 Actions 的更新"></a><a href="#%E8%A7%A3%E8%80%A6%E6%9D%A5%E8%87%AAactions%E7%9A%84%E6%9B%B4%E6%96%B0"></a>解耦来自 Actions 的更新</h2><p>我们来修改上面的例子让它包含两个状态：<code>count</code> 和 <code>step</code>。我们的定时器会每次在 count 上增加一个<code>step</code>值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const [step, setStep] = useState(1);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const id = setInterval(() =&gt; &#123;</span><br><span class="line">      setCount(c =&gt; c + step);    &#125;, 1000);</span><br><span class="line">    return () =&gt; clearInterval(id);</span><br><span class="line">  &#125;, [step]);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;input value=&#123;step&#125; onChange=&#123;e =&gt; setStep(Number(e.target.value))&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(这里是 <a href="https://codesandbox.io/s/zxn70rnkx" target="_blank" rel="noopener">demo</a>.)</p><p>注意<strong>我们没有撒谎</strong>。既然我们在 effect 里使用了<code>step</code>，我们就把它加到依赖里。所以这也是为什么代码能运行正确。</p><p>这个例子目前的行为是修改<code>step</code>会重启定时器 - 因为它是依赖项之一。在大多数场景下，这正是你所需要的。清除上一次的 effect 然后重新运行新的 effect 并没有任何错。除非我们有很好的理由，我们不应该改变这个默认行为。</p><p>不过，假如我们不想在<code>step</code>改变后重启定时器，我们该如何从 effect 中移除对<code>step</code>的依赖呢？</p><p><strong>当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用<code>useReducer</code>去替换它们。</strong></p><p>当你写类似<code>setSomething(something =&gt; ...)</code>这种代码的时候，也许就是考虑使用 reducer 的契机。reducer 可以让你<strong>把组件内发生了什么 (actions) 和状态如何响应并更新分开表述。</strong></p><p>我们用一个<code>dispatch</code>依赖去替换 effect 的<code>step</code>依赖：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [state, dispatch] = useReducer(reducer, initialState);const &#123; count, step &#125; = state;</span><br><span class="line"></span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const id = setInterval(() =&gt; &#123;</span><br><span class="line">    dispatch(&#123; type: &apos;tick&apos; &#125;);   &#125;, 1000);</span><br><span class="line">  return () =&gt; clearInterval(id);</span><br><span class="line">&#125;, [dispatch]);</span><br></pre></td></tr></table></figure><p>(查看 <a href="https://codesandbox.io/s/xzr480k0np" target="_blank" rel="noopener">demo</a>。)</p><p>你可能会问：“这怎么就更好了？” 答案是 <strong>React 会保证<code>dispatch</code>在组件的声明周期内保持不变。所以上面例子中不再需要重新订阅定时器。</strong></p><p>我们解决了问题!</p><p><em>（你可以从依赖中去除<code>dispatch</code>, <code>setState</code>, 和<code>useRef</code>包裹的值因为 React 会确保它们是静态的。不过你设置了它们作为依赖也没什么问题。）</em></p><p>相比于直接在 effect 里面读取状态，它 dispatch 了一个 <em>action</em> 来描述发生了什么。这使得我们的 effect 和<code>step</code>状态解耦。我们的 effect 不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由 reducer 去统一处理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const initialState = &#123;</span><br><span class="line">  count: 0,</span><br><span class="line">  step: 1,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">  const &#123; count, step &#125; = state;</span><br><span class="line">  if (action.type === &apos;tick&apos;) &#123;    return &#123; count: count + step, step &#125;;  &#125; else if (action.type === &apos;step&apos;) &#123;</span><br><span class="line">    return &#123; count, step: action.step &#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw new Error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(这里是 <a href="https://codesandbox.io/s/xzr480k0np" target="_blank" rel="noopener">demo</a> 如果你之前错过了。)</p><h2 id="为什么-useReducer-是-Hooks-的作弊模式"><a href="#为什么-useReducer-是-Hooks-的作弊模式" class="headerlink" title="为什么 useReducer 是 Hooks 的作弊模式"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88usereducer%E6%98%AFhooks%E7%9A%84%E4%BD%9C%E5%BC%8A%E6%A8%A1%E5%BC%8F"></a>为什么 useReducer 是 Hooks 的作弊模式</h2><p>我们已经学习到如何移除 effect 的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态。<strong>但假如我们需要依赖 <em>props</em> 去计算下一个状态呢？</strong>举个例子，也许我们的 API 是<code>&lt;Counter step={1} /&gt;</code>。确定的是，在这种情况下，我们没法避免依赖<code>props.step</code> 。是吗？</p><p>实际上， 我们可以避免！我们可以把 <em>reducer</em> 函数放到组件内去读取 props：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter(&#123; step &#125;) &#123;  const [count, dispatch] = useReducer(reducer, 0);</span><br><span class="line"></span><br><span class="line">  function reducer(state, action) &#123;</span><br><span class="line">    if (action.type === &apos;tick&apos;) &#123;</span><br><span class="line">      return state + step;    &#125; else &#123;</span><br><span class="line">      throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const id = setInterval(() =&gt; &#123;</span><br><span class="line">      dispatch(&#123; type: &apos;tick&apos; &#125;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    return () =&gt; clearInterval(id);</span><br><span class="line">  &#125;, [dispatch]);</span><br><span class="line"></span><br><span class="line">  return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式会使一些优化失效，所以你应该避免滥用它，不过如果你需要你完全可以在 reducer 里面访问 props。（这里是 <a href="https://codesandbox.io/s/7ypm405o8q" target="_blank" rel="noopener">demo</a>。）</p><p><strong>即使是在这个例子中，React 也保证<code>dispatch</code>在每次渲染中都是一样的。</strong> 所以你可以在依赖中去掉它。它不会引起 effect 不必要的重复执行。</p><p>你可能会疑惑：这怎么可能？在之前渲染中调用的 reducer 怎么 “知道” 新的 props？答案是当你<code>dispatch</code>的时候，React 只是记住了 action - 它会在下一次渲染中再次调用 reducer。在那个时候，新的 props 就可以被访问到，而且 reducer 调用也不是在 effect 里。</p><p><strong>这就是为什么我倾向认为<code>useReducer</code>是 Hooks 的 “作弊模式”。它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必需的依赖，避免不必要的 effect 调用。</strong></p><h2 id="把函数移到-Effects-里"><a href="#把函数移到-Effects-里" class="headerlink" title="把函数移到 Effects 里"></a><a href="#%E6%8A%8A%E5%87%BD%E6%95%B0%E7%A7%BB%E5%88%B0effects%E9%87%8C"></a>把函数移到 Effects 里</h2><p>一个典型的误解是认为函数不应该成为依赖。举个例子，下面的代码看上去可以运行正常：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  const [data, setData] = useState(&#123; hits: [] &#125;);</span><br><span class="line"></span><br><span class="line">  async function fetchData() &#123;</span><br><span class="line">    const result = await axios(</span><br><span class="line">      &apos;https://hn.algolia.com/api/v1/search?query=react&apos;,</span><br><span class="line">    );</span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure><p><em>(<a href="https://codesandbox.io/s/8j4ykjyv0" target="_blank" rel="noopener">这个例子</a> 改编自 Robin Wieruch 这篇很棒的文章 — <a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="noopener">点击查看</a>！)</em></p><p>需要明确的是，上面的代码可以正常工作。<strong>但这样做在组件日渐复杂的迭代过程中我们很难确保它在各种情况下还能正常运行。</strong></p><p>想象一下我们的代码做下面这样的分离，并且每一个函数的体量是现在的五倍：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  </span><br><span class="line">  function getFetchUrl() &#123;</span><br><span class="line">    return &apos;https://hn.algolia.com/api/v1/search?query=react&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  async function fetchData() &#123;</span><br><span class="line">    const result = await axios(getFetchUrl());</span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在某些函数内使用了某些 state 或者 prop：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  const [query, setQuery] = useState(&apos;react&apos;);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  function getFetchUrl() &#123;</span><br><span class="line">    return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  async function fetchData() &#123;</span><br><span class="line">    const result = await axios(getFetchUrl());</span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们忘记去更新使用这些函数（很可能通过其他函数调用）的 effects 的依赖，我们的 effects 就不会同步 props 和 state 带来的变更。这当然不是我们想要的。</p><p>幸运的是，对于这个问题有一个简单的解决方案。<strong>如果某些函数仅在 effect 中调用，你可以把它们的定义移到 effect 中：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">        function getFetchUrl() &#123;      return &apos;https://hn.algolia.com/api/v1/search?query=react&apos;;    &#125;    async function fetchData() &#123;      const result = await axios(getFetchUrl());      setData(result.data);    &#125;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []); </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(<a href="https://codesandbox.io/s/04kp3jwwql" target="_blank" rel="noopener">这里是 demo</a>.)</p><p>这么做有什么好处呢？我们不再需要去考虑这些 “间接依赖”。我们的依赖数组也不再撒谎：<strong>在我们的 effect 中确实没有再使用组件范围内的任何东西。</strong></p><p>如果我们后面修改 <code>getFetchUrl</code>去使用<code>query</code>状态，我们更可能会意识到我们正在 effect 里面编辑它 - 因此，我们需要把<code>query</code>添加到 effect 的依赖里：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  const [query, setQuery] = useState(&apos;react&apos;);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    function getFetchUrl() &#123;</span><br><span class="line">      return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;    &#125;</span><br><span class="line"></span><br><span class="line">    async function fetchData() &#123;</span><br><span class="line">      const result = await axios(getFetchUrl());</span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [query]); </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(这里是 <a href="https://codesandbox.io/s/pwm32zx7z7" target="_blank" rel="noopener">demo</a>.)</p><p>添加这个依赖，我们不仅仅是在 “取悦 React”。在 query 改变后去重新请求数据是合理的。<code>useEffect</code>的设计意图就是要强迫你关注数据流的改变，然后决定我们的 effects 该如何和它同步 - 而不是忽视它直到我们的用户遇到了 bug。</p><p>感谢<code>eslint-plugin-react-hooks</code> 插件的<code>exhaustive-deps</code>lint 规则，它会在你<a href="https://github.com/facebook/react/issues/14920" target="_blank" rel="noopener">编码的时候就分析 effects</a> 并且提供可能遗漏依赖的建议。换句话说，机器会告诉你组件中哪些数据流变更没有被正确地处理。</p><p><img src="https://overreacted.io/exhaustive-deps-04a90dcbacb01105d634964880ebed19.gif" alt></p><p>非常棒。</p><h2 id="但我不能把这个函数放到-Effect-里"><a href="#但我不能把这个函数放到-Effect-里" class="headerlink" title="但我不能把这个函数放到 Effect 里"></a><a href="#%E4%BD%86%E6%88%91%E4%B8%8D%E8%83%BD%E6%8A%8A%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E6%94%BE%E5%88%B0effect%E9%87%8C"></a>但我不能把这个函数放到 Effect 里</h2><p>有时候你可能不想把函数移入 effect 里。比如，组件内有几个 effect 使用了相同的函数，你不想在每个 effect 里复制黏贴一遍这个逻辑。也或许这个函数是一个 prop。</p><p>在这种情况下你应该忽略对函数的依赖吗？我不这么认为。再次强调，<strong>efffects 不应该对它的依赖撒谎。</strong>通常我们还有更好的解决办法。一个常见的误解是，“函数从来不会改变”。但是这篇文章你读到现在，你知道这显然不是事实。实际上，在组件内定义的函数每一次渲染都在变。</p><p><strong>函数每次渲染都会改变这个事实本身就是个问题。</strong> 比如有两个 effects 会调用 <code>getFetchUrl</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  function getFetchUrl(query) &#123;</span><br><span class="line">    return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;react&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, []); </span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;redux&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, []); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，你可能不想把<code>getFetchUrl</code> 移到 effects 中，因为你想复用逻辑。</p><p>另一方面，如果你对依赖很 “诚实”，你可能会掉到陷阱里。我们的两个 effects 都依赖<code>getFetchUrl</code>，<strong>而它每次渲染都不同</strong>，所以我们的依赖数组会变得无用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">    function getFetchUrl(query) &#123;    return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;  &#125;</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;react&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, [getFetchUrl]); </span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;redux&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, [getFetchUrl]); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个可能的解决办法是把<code>getFetchUrl</code>从依赖中去掉。但是，我不认为这是好的解决方式。这会使我们后面对数据流的改变很难被发现从而忘记去处理。这会导致类似于上面 “定时器不更新值” 的问题。</p><p>相反的，我们有两个更简单的解决办法。</p><p><strong>第一个， 如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在 effects 中使用：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getFetchUrl(query) &#123;  return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;&#125;</span><br><span class="line">function SearchResults() &#123;</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;react&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, []); </span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;redux&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, []); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你不再需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响。它不可能突然意外地依赖于 props 或 state。</p><p>或者， 你也可以把它包装成 <a href="https://reactjs.org/docs/hooks-reference.html#usecallback" target="_blank" rel="noopener"><code>useCallback</code> Hook</a>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">    const getFetchUrl = useCallback((query) =&gt; &#123;    return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;  &#125;, []);  </span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;react&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, [getFetchUrl]); </span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;redux&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, [getFetchUrl]); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>useCallback</code>本质上是添加了一层依赖检查。它以另一种方式解决了问题 - <strong>我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖。</strong></p><p>我们来看看为什么这种方式是有用的。之前，我们的例子中展示了两种搜索结果（查询条件分别为<code>&#39;react&#39;</code>和<code>&#39;redux&#39;</code>）。但如果我们想添加一个输入框允许你输入任意的查询条件 (<code>query</code>)。不同于传递<code>query</code>参数的方式，现在<code>getFetchUrl</code>会从状态中读取。</p><p>我们很快发现它遗漏了<code>query</code>依赖：</p><p>如果我把<code>query</code>添加到<code>useCallback</code> 的依赖中，任何调用了<code>getFetchUrl</code>的 effect 在<code>query</code>改变后都会重新运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  const [query, setQuery] = useState(&apos;react&apos;);</span><br><span class="line"></span><br><span class="line">    const getFetchUrl = useCallback(() =&gt; &#123;    return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;  &#125;, [query]);  </span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl();</span><br><span class="line">    </span><br><span class="line">  &#125;, [getFetchUrl]); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要感谢<code>useCallback</code>，因为如果<code>query</code> 保持不变，<code>getFetchUrl</code>也会保持不变，我们的 effect 也不会重新运行。但是如果<code>query</code>修改了，<code>getFetchUrl</code>也会随之改变，因此会重新请求数据。这就像你在 Excel 里修改了一个单元格的值，另一个使用它的单元格会自动重新计算一样。</p><p>这正是拥抱数据流和同步思维的结果。<strong>对于通过属性从父组件传入的函数这个方法也适用：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">  const [query, setQuery] = useState(&apos;react&apos;);</span><br><span class="line"></span><br><span class="line">    const fetchData = useCallback(() =&gt; &#123;    const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;      &#125;, [query]);  </span><br><span class="line">  return &lt;Child fetchData=&#123;fetchData&#125; /&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child(&#123; fetchData &#125;) &#123;</span><br><span class="line">  let [data, setData] = useState(null);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData().then(setData);</span><br><span class="line">  &#125;, [fetchData]); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>fetchData</code>只有在<code>Parent</code>的<code>query</code>状态变更时才会改变，所以我们的<code>Child</code>只会在需要的时候才去重新请求数据。</p><h2 id="函数是数据流的一部分吗？"><a href="#函数是数据流的一部分吗？" class="headerlink" title="函数是数据流的一部分吗？"></a><a href="#%E5%87%BD%E6%95%B0%E6%98%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%E5%90%97%EF%BC%9F"></a>函数是数据流的一部分吗？</h2><p>有趣的是，这种模式在 class 组件中行不通，并且这种行不通恰到好处地揭示了 effect 和生命周期范式之间的区别。考虑下面的转换：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Parent extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    query: &apos;react&apos;</span><br><span class="line">  &#125;;</span><br><span class="line">  fetchData = () =&gt; &#123;    const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + this.state.query;      &#125;;  render() &#123;</span><br><span class="line">    return &lt;Child fetchData=&#123;this.fetchData&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    data: null</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;    this.props.fetchData();  &#125;  render() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会想：“少来了 Dan，我们都知道<code>useEffect</code> 就像<code>componentDidMount</code> 和 <code>componentDidUpdate</code>的结合，你不能老是破坏这一条！” <strong>好吧，就算加了<code>componentDidUpdate</code>照样无用：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Child extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    data: null</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.props.fetchData();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps) &#123;        if (this.props.fetchData !== prevProps.fetchData) &#123;      this.props.fetchData();    &#125;  &#125;  render() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然如此，<code>fetchData</code>是一个 class 方法！（或者你也可以说是 class 属性 - 但这不能改变什么。）它不会因为状态的改变而不同，所以<code>this.props.fetchData</code>和 <code>prevProps.fetchData</code>始终相等，因此不会重新请求。那我们删掉条件判断怎么样？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentDidUpdate(prevProps) &#123;</span><br><span class="line">  this.props.fetchData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等等，这样会在每次渲染后都去请求。(添加一个加载动画可能是一种有趣的发现这种情况的方式。) 也许我们可以绑定一个特定的 query?</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return &lt;Child fetchData=&#123;this.fetchData.bind(this, this.state.query)&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样一来，<code>this.props.fetchData !== prevProps.fetchData</code> 表达式永远是<code>true</code>，即使<code>query</code>并未改变。这会导致我们总是去请求。</p><p>想要解决这个 class 组件中的难题，唯一现实可行的办法是硬着头皮把<code>query</code>本身传入 <code>Child</code> 组件。 <code>Child</code> 虽然实际并没有直接_使用_这个<code>query</code>的值，但能在它改变的时候触发一次重新请求：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Parent extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    query: &apos;react&apos;</span><br><span class="line">  &#125;;</span><br><span class="line">  fetchData = () =&gt; &#123;</span><br><span class="line">    const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + this.state.query;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;Child fetchData=&#123;this.fetchData&#125; query=&#123;this.state.query&#125; /&gt;;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    data: null</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.props.fetchData();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps) &#123;</span><br><span class="line">    if (this.props.query !== prevProps.query) &#123;      this.props.fetchData();    &#125;  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 React 的 class 组件这么多年后，我已经如此习惯于把不必要的 props 传递下去并且破坏父组件的封装以至于我在一周之前才意识到我为什么一定要这样做。</p><p><strong>在 class 组件中，函数属性本身并不是数据流的一部分。</strong>组件的方法中包含了可变的<code>this</code>变量导致我们不能确定无疑地认为它是不变的。因此，即使我们只需要一个函数，我们也必须把一堆数据传递下去仅仅是为了做 “diff”。我们无法知道传入的<code>this.props.fetchData</code> 是否依赖状态，并且不知道它依赖的状态是否改变了。</p><p><strong>使用<code>useCallback</code>，函数完全可以参与到数据流中。</strong>我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。感谢周到的<code>useCallback</code>，属性比如<code>props.fetchData</code>的改变也会自动传递下去。</p><p>类似的，<a href="https://reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener"><code>useMemo</code></a>可以让我们对复杂对象做类似的事情。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ColorPicker() &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  const [color, setColor] = useState(&apos;pink&apos;);</span><br><span class="line">  const style = useMemo(() =&gt; (&#123; color &#125;), [color]);</span><br><span class="line">  return &lt;Child style=&#123;style&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我想强调的是，到处使用<code>useCallback</code>是件挺笨拙的事。</strong>当我们需要将函数传递下去并且函数会在子组件的 effect 中被调用的时候，<code>useCallback</code> 是很好的技巧且非常有用。或者你想试图减少对子组件的记忆负担，也不妨一试。但总的来说 Hooks 本身能更好地<a href="https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down" target="_blank" rel="noopener">避免传递回调函数</a>。</p><p>在上面的例子中，我更倾向于把<code>fetchData</code>放在我的 effect 里（它可以抽离成一个自定义 Hook）或者是从顶层引入。我想让 effects 保持简单，而在里面调用回调会让事情变得复杂。（“如果某个<code>props.onComplete</code>回调改变了而请求还在进行中会怎么样？”）你可以<a href="#swimming-against-the-tide">模拟 class 的行为</a>但那样并不能解决竞态的问题。</p><h2 id="说说竞态"><a href="#说说竞态" class="headerlink" title="说说竞态"></a><a href="#%E8%AF%B4%E8%AF%B4%E7%AB%9E%E6%80%81"></a>说说竞态</h2><p>下面是一个典型的在 class 组件里发请求的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Article extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    article: null</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.fetchData(this.props.id);</span><br><span class="line">  &#125;</span><br><span class="line">  async fetchData(id) &#123;</span><br><span class="line">    const article = await API.fetchArticle(id);</span><br><span class="line">    this.setState(&#123; article &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你很可能已经知道，上面的代码埋伏了一些问题。它并没有处理更新的情况。所以第二个你能够在网上找到的经典例子是下面这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Article extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    article: null</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.fetchData(this.props.id);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps) &#123;    if (prevProps.id !== this.props.id) &#123;      this.fetchData(this.props.id);    &#125;  &#125;  async fetchData(id) &#123;</span><br><span class="line">    const article = await API.fetchArticle(id);</span><br><span class="line">    this.setState(&#123; article &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这显然好多了！但依旧有问题。有问题的原因是请求结果返回的顺序不能保证一致。比如我先请求 <code>{id: 10}</code>，然后更新到<code>{id: 20}</code>，但<code>{id: 20}</code>的请求更先返回。请求更早但返回更晚的情况会错误地覆盖状态值。</p><p>这被叫做竞态，这在混合了<code>async</code> / <code>await</code>（假设在等待结果返回）和自顶向下数据流的代码中非常典型（props 和 state 可能会在 async 函数调用过程中发生改变）。</p><p>Effects 并没有神奇地解决这个问题，尽管它会警告你如果你直接传了一个<code>async</code> 函数给 effect。（我们会改善这个警告来更好地解释你可能会遇到的这些问题。）</p><p>如果你使用的异步方式支持取消，那太棒了。你可以直接在清除函数中取消异步请求。</p><p>或者，最简单的权宜之计是用一个布尔值来跟踪它：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Article(&#123; id &#125;) &#123;</span><br><span class="line">  const [article, setArticle] = useState(null);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    let didCancel = false;</span><br><span class="line">    async function fetchData() &#123;</span><br><span class="line">      const article = await API.fetchArticle(id);</span><br><span class="line">      if (!didCancel) &#123;        setArticle(article);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;      didCancel = true;    &#125;;  &#125;, [id]);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="noopener">这篇文章</a>讨论了更多关于如何处理错误和加载状态，以及抽离逻辑到自定义的 Hook。我推荐你认真阅读一下如果你想学习更多关于如何在 Hooks 里请求数据的内容。</p><h2 id="提高水准"><a href="#提高水准" class="headerlink" title="提高水准"></a><a href="#%E6%8F%90%E9%AB%98%E6%B0%B4%E5%87%86"></a>提高水准</h2><p>在 class 组件生命周期的思维模型中，副作用的行为和渲染输出是不同的。UI 渲染是被 props 和 state 驱动的，并且能确保步调一致，但副作用并不是这样。这是一类常见问题的来源。</p><p>而在<code>useEffect</code>的思维模型中，默认都是同步的。副作用变成了 React 数据流的一部分。对于每一个<code>useEffect</code>调用，一旦你处理正确，你的组件能够更好地处理边缘情况。</p><p>然而，用好<code>useEffect</code>的前期学习成本更高。这可能让人气恼。用同步的代码去处理边缘情况天然就比触发一次不用和渲染结果步调一致的副作用更难。</p><p>这难免让人担忧如果<code>useEffect</code>是你现在使用最多的工具。不过，目前大抵还处理低水平使用阶段。因为 Hooks 太新了所以大家都还在低水平地使用它，尤其是在一些教程示例中。但在实践中，社区很可能即将开始高水平地使用 Hooks，因为好的 API 会有更好的动量和冲劲。</p><p>我看到不同的应用在创造他们自己的 Hooks，比如封装了应用鉴权逻辑的<code>useFetch</code>或者使用 theme context 的<code>useTheme</code> 。你一旦有了包含这些的工具箱，你就不会那么频繁地直接使用<code>useEffect</code>。但每一个基于它的 Hook 都能从它的适应能力中得到益处。</p><p>目前为止，<code>useEffect</code>主要用于数据请求。但是数据请求准确说并不是一个同步问题。因为我们的依赖经常是<code>[]</code>所以这一点尤其明显。那我们究竟在同步什么？</p><p>长远来看， <a href="https://reactjs.org/blog/2018/11/27/react-16-roadmap.html#react-16x-mid-2019-the-one-with-suspense-for-data-fetching" target="_blank" rel="noopener">Suspense 用于数据请求</a> 会允许第三方库通过第一等的途径告诉 React 暂停渲染直到某些异步事物（任何东西：代码，数据，图片）已经准备就绪。</p><p>当 Suspense 逐渐地覆盖到更多的数据请求使用场景，我预料<code>useEffect</code> 会退居幕后作为一个强大的工具，用于同步 props 和 state 到某些副作用。不像数据请求，它可以很好地处理这些场景因为它就是为此而设计的。不过在那之前，自定义的 Hooks 比如<a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="noopener">这儿提到的</a>是复用数据请求逻辑很好的方式。</p><h2 id="在结束前"><a href="#在结束前" class="headerlink" title="在结束前"></a><a href="#%E5%9C%A8%E7%BB%93%E6%9D%9F%E5%89%8D"></a>在结束前</h2><p>现在你差不多知道了我关于如何使用 effects 的所有知识，可以检查一下开头的 <a href="#tldr">TLDR</a>。你现在觉得它说得有道理吗？我有遗漏什么吗？（我的纸还没有写完！）</p><p>我很想在 Twitter 上听听你的想法。谢谢阅读。</p>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
        <category>React Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React Hooks</tag>
        <tag>useEffect</tag>
      </tags>
  </entry>
  <entry>
    <title>A Complete Guide to useEffect</title>
    <url>/archives/6387.html</url>
    <content><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://overreacted.io/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">https://overreacted.io/a-complete-guide-to-useeffect/</a></p></blockquote><p>You wrote a few components with <a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">Hooks</a>. Maybe even a small app. You’re mostly satisfied. You’re comfortable with the API and picked up a few tricks along the way. You even made some <a href="https://reactjs.org/docs/hooks-custom.html" target="_blank" rel="noopener">custom Hooks</a> to extract repetitive logic (300 lines gone!) and showed it off to your colleagues. “Great job”, they said.</p><p>But sometimes when you <code>useEffect</code>, the pieces don’t quite fit together. You have a nagging feeling that you’re missing something. It seems similar to class lifecycles… but is it really? You find yourself asking questions like:</p><ul><li>🤔 How do I replicate <code>componentDidMount</code> with <code>useEffect</code>?</li><li>🤔 How do I correctly fetch data inside <code>useEffect</code>? What is <code>[]</code>?</li><li>🤔 Do I need to specify functions as effect dependencies or not?</li><li>🤔 Why do I sometimes get an infinite refetching loop?</li><li>🤔 Why do I sometimes get an old state or prop value inside my effect?</li></ul><p>When I just started using Hooks, I was confused by all of those questions too. Even when writing the initial docs, I didn’t have a firm grasp on some of the subtleties. I’ve since had a few “aha” moments that I want to share with you. <strong>This deep dive will make the answers to these questions look obvious to you.</strong></p><p>To <em>see</em> the answers, we need to take a step back. The goal of this article isn’t to give you a list of bullet point recipes. It’s to help you truly “grok” <code>useEffect</code>. There won’t be much to learn. In fact, we’ll spend most of our time _un_learning.</p><p><strong>It’s only after I stopped looking at the <code>useEffect</code> Hook through the prism of the familiar class lifecycle methods that everything came together for me.</strong></p><blockquote><p>“Unlearn what you have learned.” — Yoda</p></blockquote><p><a href="https://overreacted.io/static/6203a1f1f2c771816a5ba0969baccd12/5ed8a/yoda.jpg" target="_blank" rel="noopener"><img src="https://overreacted.io/static/6203a1f1f2c771816a5ba0969baccd12/5ed8a/yoda.jpg" alt></a></p><p><strong>This article assumes that you’re somewhat familiar with <a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener"><code>useEffect</code></a> API.</strong></p><p><strong>It’s also <em>really</em> long. It’s like a mini-book. That’s just my preferred format. But I wrote a TLDR just below if you’re in a rush or don’t really care.</strong></p><p><strong>If you’re not comfortable with deep dives, you might want to wait until these explanations appear elsewhere. Just like when React came out in 2013, it will take some time for people to recognize a different mental model and teach it.</strong></p><h2 id="TLDR"><a href="#TLDR" class="headerlink" title="TLDR"></a><a href="#tldr"></a>TLDR</h2><p>Here’s a quick TLDR if you don’t want to read the whole thing. If some parts don’t make sense, you can scroll down until you find something related.</p><p>Feel free to skip it if you plan to read the whole post. I’ll link to it at the end.</p><p><strong>🤔 Question: How do I replicate <code>componentDidMount</code> with <code>useEffect</code>?</strong></p><p>While you can <code>useEffect(fn, [])</code>, it’s not an exact equivalent. Unlike <code>componentDidMount</code>, it will <em>capture</em> props and state. So even inside the callbacks, you’ll see the initial props and state. If you want to see “latest” something, you can write it to a ref. But there’s usually a simpler way to structure the code so that you don’t have to. Keep in mind that the mental model for effects is different from <code>componentDidMount</code> and other lifecycles, and trying to find their exact equivalents may confuse you more than help. To get productive, you need to “think in effects”, and their mental model is closer to implementing synchronization than to responding to lifecycle events.</p><p><strong>🤔 Question: How do I correctly fetch data inside <code>useEffect</code>? What is <code>[]</code>?</strong></p><p><a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="noopener">This article</a> is a good primer on data fetching with <code>useEffect</code>. Make sure to read it to the end! It’s not as long as this one. <code>[]</code> means the effect doesn’t use any value that participates in React data flow, and is for that reason safe to apply once. It is also a common source of bugs when the value actually _is_ used. You’ll need to learn a few strategies (primarily <code>useReducer</code> and <code>useCallback</code>) that can <em>remove the need</em> for a dependency instead of incorrectly omitting it.</p><p><strong>🤔 Question: Do I need to specify functions as effect dependencies or not?</strong></p><p>The recommendation is to hoist functions that don’t need props or state <em>outside</em> of your component, and pull the ones that are used only by an effect <em>inside</em> of that effect. If after that your effect still ends up using functions in the render scope (including function from props), wrap them into <code>useCallback</code> where they’re defined, and repeat the process. Why does it matter? Functions can “see” values from props and state — so they participate in the data flow. There’s a <a href="https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" target="_blank" rel="noopener">more detailed answer</a> in our FAQ.</p><p><strong>🤔 Question: Why do I sometimes get an infinite refetching loop?</strong></p><p>This can happen if you’re doing data fetching in an effect without the second dependencies argument. Without it, effects run after every render — and setting the state will trigger the effects again. An infinite loop may also happen if you specify a value that <em>always</em> changes in the dependency array. You can tell which one by removing them one by one. However, removing a dependency you use (or blindly specifying <code>[]</code>) is usually the wrong fix. Instead, fix the problem at its source. For example, functions can cause this problem, and putting them inside effects, hoisting them out, or wrapping them with <code>useCallback</code> helps. To avoid recreating objects, <code>useMemo</code> can serve a similar purpose.</p><p><strong>🤔 Why do I sometimes get an old state or prop value inside my effect?</strong></p><p>Effects always “see” props and state from the render they were defined in. That <a href="https://overreacted.io/how-are-function-components-different-from-classes/" target="_blank" rel="noopener">helps prevent bugs</a> but in some cases can be annoying. For those cases, you can explicitly maintain some value in a mutable ref (the linked article explains it at the end). If you think you’re seeing some props or state from an old render but don’t expect it, you probably missed some dependencies. Try using the <a href="https://github.com/facebook/react/issues/14920" target="_blank" rel="noopener">lint rule</a> to train yourself to see them. A few days, and it’ll be like a second nature to you. See also <a href="https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function" target="_blank" rel="noopener">this answer</a> in our FAQ.</p><p>I hope this TLDR was helpful! Otherwise, let’s go.</p><h2 id="Each-Render-Has-Its-Own-Props-and-State"><a href="#Each-Render-Has-Its-Own-Props-and-State" class="headerlink" title="Each Render Has Its Own Props and State"></a><a href="#each-render-has-its-own-props-and-state"></a>Each Render Has Its Own Props and State</h2><p>Before we can talk about effects, we need to talk about rendering.</p><p>Here’s a counter. Look at the highlighted line closely:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>What does it mean? Does <code>count</code> somehow “watch” changes to our state and update automatically? That might be a useful first intuition when you learn React but it’s <em>not</em> an <a href="https://overreacted.io/react-as-a-ui-runtime/" target="_blank" rel="noopener">accurate mental model</a>.</p><p><strong>In this example, <code>count</code> is just a number.</strong> It’s not a magic “data binding”, a “watcher”, a “proxy”, or anything else. It’s a good old number like this one:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const count = 42;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>The first time our component renders, the <code>count</code> variable we get from <code>useState()</code> is <code>0</code>. When we call <code>setCount(1)</code>, React calls our component again. This time, <code>count</code> will be <code>1</code>. And so on:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const count = 0;   </span><br><span class="line">  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const count = 1;   </span><br><span class="line">  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const count = 2;   </span><br><span class="line">  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Whenever we update the state, React calls our component. Each render result “sees” its own <code>counter</code> state value which is a <em>constant</em> inside our function.</strong></p><p>So this line doesn’t do any special data binding:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><strong>It only embeds a number value into the render output.</strong> That number is provided by React. When we <code>setCount</code>, React calls our component again with a different <code>count</code> value. Then React updates the DOM to match our latest render output.</p><p>The key takeaway is that the <code>count</code> constant inside any particular render doesn’t change over time. It’s our component that’s called again — and each render “sees” its own <code>count</code> value that’s isolated between renders.</p><p><em>(For an in-depth overview of this process, check out my post <a href="https://overreacted.io/react-as-a-ui-runtime/" target="_blank" rel="noopener">React as a UI Runtime</a>.)</em></p><h2 id="Each-Render-Has-Its-Own-Event-Handlers"><a href="#Each-Render-Has-Its-Own-Event-Handlers" class="headerlink" title="Each Render Has Its Own Event Handlers"></a><a href="#each-render-has-its-own-event-handlers"></a>Each Render Has Its Own Event Handlers</h2><p>So far so good. What about event handlers?</p><p>Look at this example. It shows an alert with the <code>count</code> after three seconds:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  function handleAlertClick() &#123;    setTimeout(() =&gt; &#123;      alert(&apos;You clicked on: &apos; + count);    &#125;, 3000);  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleAlertClick&#125;&gt;        Show alert      &lt;/button&gt;    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s say I do this sequence of steps:</p><ul><li><strong>Increment</strong> the counter to 3</li><li><strong>Press</strong> “Show alert”</li><li><strong>Increment</strong> it to 5 before the timeout fires</li></ul><p><img src="https://overreacted.io/counter-46c55d5f1f749462b7a173f1e748e41e.gif" alt></p><p>What do you expect the alert to show? Will it show 5 — which is the counter state at the time of the alert? Or will it show 3 — the state when I clicked?</p><p><em>spoilers ahead</em></p><p>Go ahead and <a href="https://codesandbox.io/s/w2wxl3yo0l" target="_blank" rel="noopener">try it yourself!</a></p><p>If the behavior doesn’t quite make sense to you, imagine a more practical example: a chat app with the current recipient ID in the state, and a Send button. <a href="https://overreacted.io/how-are-function-components-different-from-classes/" target="_blank" rel="noopener">This article</a> explores the reasons in depth but the correct answer is 3.</p><p>The alert will “capture” the state at the time I clicked the button.</p><p><em>(There are ways to implement the other behavior too but I’ll be focusing on the default case for now. When building a mental model, it’s important that we distinguish the “path of least resistance” from the opt-in escape hatches.)</em></p><p>But how does it work?</p><p>We’ve discussed that the <code>count</code> value is constant for every particular call to our function. It’s worth emphasizing this — <strong>our function gets called many times (once per each render), but every one of those times the <code>count</code> value inside of it is constant and set to a particular value (state for that render).</strong></p><p>This is not specific to React — regular functions work in a similar way:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sayHi(person) &#123;</span><br><span class="line">  const name = person.name;  setTimeout(() =&gt; &#123;</span><br><span class="line">    alert(&apos;Hello, &apos; + name);</span><br><span class="line">  &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let someone = &#123;name: &apos;Dan&apos;&#125;;</span><br><span class="line">sayHi(someone);</span><br><span class="line"></span><br><span class="line">someone = &#123;name: &apos;Yuzhi&apos;&#125;;</span><br><span class="line">sayHi(someone);</span><br><span class="line"></span><br><span class="line">someone = &#123;name: &apos;Dominic&apos;&#125;;</span><br><span class="line">sayHi(someone);</span><br></pre></td></tr></table></figure><p>In <a href="https://codesandbox.io/s/mm6ww11lk8" target="_blank" rel="noopener">this example</a>, the outer <code>someone</code> variable is reassigned several times. (Just like somewhere in React, the <em>current</em> component state can change.) <strong>However, inside <code>sayHi</code>, there is a local <code>name</code> constant that is associated with a <code>person</code> from a particular call.</strong> That constant is local, so it’s isolated between the calls! As a result, when the timeouts fire, each alert “remembers” its own <code>name</code>.</p><p>This explains how our event handler captures the <code>count</code> at the time of the click. If we apply the same substitution principle, each render “sees” its own <code>count</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const count = 0;   </span><br><span class="line">  function handleAlertClick() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      alert(&apos;You clicked on: &apos; + count);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const count = 1;   </span><br><span class="line">  function handleAlertClick() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      alert(&apos;You clicked on: &apos; + count);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  const count = 2;   </span><br><span class="line">  function handleAlertClick() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      alert(&apos;You clicked on: &apos; + count);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So effectively, each render returns its own “version” of <code>handleAlertClick</code>. Each of those versions “remembers” its own <code>count</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  function handleAlertClick() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      alert(&apos;You clicked on: &apos; + 0);    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  function handleAlertClick() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      alert(&apos;You clicked on: &apos; + 1);    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  function handleAlertClick() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      alert(&apos;You clicked on: &apos; + 2);    &#125;, 3000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is why <a href="https://codesandbox.io/s/w2wxl3yo0l" target="_blank" rel="noopener">in this demo</a> event handlers “belong” to a particular render, and when you click, it keeps using the <code>counter</code> state <em>from</em> that render.</p><p><strong>Inside any particular render, props and state forever stay the same.</strong> But if props and state are isolated between renders, so are any values using them (including the event handlers). They also “belong” to a particular render. So even async functions inside an event handler will “see” the same <code>count</code> value.</p><p><em>Side note: I inlined concrete <code>count</code> values right into <code>handleAlertClick</code> functions above. This mental substitution is safe because <code>count</code> can’t possibly change within a particular render. It’s declared as a <code>const</code> and is a number. It would be safe to think the same way about other values like objects too, but only if we agree to avoid mutating state. Calling <code>setSomething(newObj)</code> with a newly created object instead of mutating it is fine because state belonging to previous renders is intact.</em></p><h2 id="Each-Render-Has-Its-Own-Effects"><a href="#Each-Render-Has-Its-Own-Effects" class="headerlink" title="Each Render Has Its Own Effects"></a><a href="#each-render-has-its-own-effects"></a>Each Render Has Its Own Effects</h2><p>This was supposed to be a post about effects but we still haven’t talked about effects yet! We’ll rectify this now. Turns out, effects aren’t really any different.</p><p>Let’s go back to an example from <a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener">the docs</a>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;    document.title = `You clicked $&#123;count&#125; times`;  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Here’s a question for you: how does the effect read the latest <code>count</code> state?</strong></p><p>Maybe, there’s some kind of “data binding” or “watching” that makes <code>count</code> update live inside the effect function? Maybe <code>count</code> is a mutable variable that React sets inside our component so that our effect always sees the latest value?</p><p>Nope.</p><p>We already know that <code>count</code> is constant within a particular component render. Event handlers “see” the <code>count</code> state from the render that they “belong” to because <code>count</code> is a variable in their scope. The same is true for effects!</p><p><strong>It’s not the <code>count</code> variable that somehow changes inside an “unchanging” effect. It’s the <em>effect function itself</em> that’s different on every render.</strong></p><p>Each version “sees” the <code>count</code> value from the render that it “belongs” to:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">        () =&gt; &#123;      document.title = `You clicked $&#123;0&#125; times`;    &#125;  );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">        () =&gt; &#123;      document.title = `You clicked $&#123;1&#125; times`;    &#125;  );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">        () =&gt; &#123;      document.title = `You clicked $&#123;2&#125; times`;    &#125;  );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React remembers the effect function you provided, and runs it after flushing changes to the DOM and letting the browser paint the screen.</p><p>So even if we speak of a single conceptual <em>effect</em> here (updating the document title), it is represented by a <em>different function</em> on every render — and each effect function “sees” props and state from the particular render it “belongs” to.</p><p><strong>Conceptually, you can imagine effects are a <em>part of the render result</em>.</strong></p><p>Strictly saying, they’re not (in order to <a href="https://overreacted.io/why-do-hooks-rely-on-call-order/" target="_blank" rel="noopener">allow Hook composition</a> without clumsy syntax or runtime overhead). But in the mental model we’re building up, effect functions <em>belong</em> to a particular render in the same way that event handlers do.</p><p>To make sure we have a solid understanding, let’s recap our first render:</p><ul><li><strong>React:</strong> Give me the UI when the state is <code>0</code>.</li><li><p><strong>Your component:</strong></p><ul><li>Here’s the render result: <code>&lt;p&gt;You clicked 0 times&lt;/p&gt;</code>.</li><li>Also remember to run this effect after you’re done: <code>() =&gt; { document.title = &#39;You clicked 0 times&#39; }</code>.</li></ul></li><li><strong>React:</strong> Sure. Updating the UI. Hey browser, I’m adding some stuff to the DOM.</li><li><strong>Browser:</strong> Cool, I painted it to the screen.</li><li><p><strong>React:</strong> OK, now I’m going to run the effect you gave me.</p><ul><li>Running <code>() =&gt; { document.title = &#39;You clicked 0 times&#39; }</code>.</li></ul></li></ul><p>Now let’s recap what happens after we click:</p><ul><li><strong>Your component:</strong> Hey React, set my state to <code>1</code>.</li><li><strong>React:</strong> Give me the UI for when the state is <code>1</code>.</li><li><p><strong>Your component:</strong></p><ul><li>Here’s the render result: <code>&lt;p&gt;You clicked 1 times&lt;/p&gt;</code>.</li><li>Also remember to run this effect after you’re done: <code>() =&gt; { document.title = &#39;You clicked 1 times&#39; }</code>.</li></ul></li><li><strong>React:</strong> Sure. Updating the UI. Hey browser, I’ve changed the DOM.</li><li><strong>Browser:</strong> Cool, I painted your changes to the screen.</li><li><p><strong>React:</strong> OK, now I’ll run the effect that belongs to the render I just did.</p><ul><li>Running <code>() =&gt; { document.title = &#39;You clicked 1 times&#39; }</code>.</li></ul></li></ul><h2 id="Each-Render-Has-Its-Own…-Everything"><a href="#Each-Render-Has-Its-Own…-Everything" class="headerlink" title="Each Render Has Its Own… Everything"></a><a href="#each-render-has-its-own-everything"></a>Each Render Has Its Own… Everything</h2><p><strong>We know now that effects run after every render, are conceptually a part of the component output, and “see” the props and state from that particular render.</strong></p><p>Let’s try a thought experiment. Consider this code:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(`You clicked $&#123;count&#125; times`);    &#125;, 3000);  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If I click several times with a small delay, what is the log going to look like?</p><p><em>spoilers ahead</em></p><p>You might think this is a gotcha and the end result is unintuitive. It’s not! We’re going to see a sequence of logs — each one belonging to a particular render and thus with its own <code>count</code> value. You can <a href="https://codesandbox.io/s/lyx20m1ol" target="_blank" rel="noopener">try it yourself</a>:</p><p><img src="https://overreacted.io/timeout_counter-a5727d333c270e05942f508707265378.gif" alt></p><p>You may think: “Of course that’s how it works! How else could it work?”</p><p>Well, that’s not how <code>this.state</code> works in classes. It’s easy to make the mistake of thinking that this <a href="https://codesandbox.io/s/kkymzwjqz3" target="_blank" rel="noopener">class implementation</a> is equivalent:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentDidUpdate() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(`You clicked $&#123;this.state.count&#125; times`);</span><br><span class="line">  &#125;, 3000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>However, <code>this.state.count</code> always points at the <em>latest</em> count rather than the one belonging to a particular render. So you’ll see <code>5</code> logged each time instead:</p><p><img src="https://overreacted.io/timeout_counter_class-264b329edc111a1973003bdf2bcacd65.gif" alt></p><p>I think it’s ironic that Hooks rely so much on JavaScript closures, and yet it’s the class implementation that suffers from <a href="https://wsvincent.com/javascript-closure-settimeout-for-loop/" target="_blank" rel="noopener">the canonical wrong-value-in-a-timeout confusion</a> that’s often associated with closures. This is because the actual source of the confusion in this example is the mutation (React mutates <code>this.state</code> in classes to point to the latest state) and not closures themselves.</p><p><strong>Closures are great when the values you close over never change. That makes them easy to think about because you’re essentially referring to constants.</strong> And as we discussed, props and state never change within a particular render. By the way, we can fix the class version… by <a href="https://codesandbox.io/s/w7vjo07055" target="_blank" rel="noopener">using a closure</a>.</p><h2 id="Swimming-Against-the-Tide"><a href="#Swimming-Against-the-Tide" class="headerlink" title="Swimming Against the Tide"></a><a href="#swimming-against-the-tide"></a>Swimming Against the Tide</h2><p>At this point it’s important that we call it out explicitly: <strong>every</strong> function inside the component render (including event handlers, effects, timeouts or API calls inside them) captures the props and state of the render call that defined it.</p><p>So these two examples are equivalent:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Example(props) &#123;</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(props.counter);    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Example(props) &#123;</span><br><span class="line">  const counter = props.counter;  useEffect(() =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(counter);    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>It doesn’t matter whether you read from props or state “early” inside of your component.</strong> They’re not going to change! Inside the scope of a single render, props and state stay the same. (Destructuring props makes this more obvious.)</p><p>Of course, sometimes you <em>want</em> to read the latest rather than captured value inside some callback defined in an effect. The easiest way to do it is by using refs, as described in the last section of <a href="https://overreacted.io/how-are-function-components-different-from-classes/" target="_blank" rel="noopener">this article</a>.</p><p>Be aware that when you want to read the <em>future</em> props or state from a function in a <em>past</em> render, you’re swimming against the tide. It’s not <em>wrong</em> (and in some cases necessary) but it might look less “clean” to break out of the paradigm. This is an intentional consequence because it helps highlight which code is fragile and depends on timing. In classes, it’s less obvious when this happens.</p><p>Here’s a <a href="https://codesandbox.io/s/rm7z22qnlp" target="_blank" rel="noopener">version of our counter example</a> that replicates the class behavior:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Example() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const latestCount = useRef(count);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">        latestCount.current = count;    setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(`You clicked $&#123;latestCount.current&#125; times`);    &#125;, 3000);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://overreacted.io/timeout_counter_refs-78f7948263dd13b023498b23cb99f4fc.gif" alt></p><p>It might seem quirky to mutate something in React. However, this is exactly how React itself reassigns <code>this.state</code> in classes. Unlike with captured props and state, you don’t have any guarantees that reading <code>latestCount.current</code> would give you the same value in any particular callback. By definition, you can mutate it any time. This is why it’s not a default, and you have to opt into that.</p><h2 id="So-What-About-Cleanup"><a href="#So-What-About-Cleanup" class="headerlink" title="So What About Cleanup?"></a><a href="#so-what-about-cleanup"></a>So What About Cleanup?</h2><p>As <a href="https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup" target="_blank" rel="noopener">the docs explain</a>, some effects might have a cleanup phase. Essentially, its purpose is to “undo” an effect for cases like subscriptions.</p><p>Consider this code:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Say <code>props</code> is <code>{id: 10}</code> on the first render, and <code>{id: 20}</code> on the second render. You <em>might</em> think that something like this happens:</p><ul><li>React cleans up the effect for <code>{id: 10}</code>.</li><li>React renders UI for <code>{id: 20}</code>.</li><li>React runs the effect for <code>{id: 20}</code>.</li></ul><p>(This is not quite the case.)</p><p>With this mental model, you might think the cleanup “sees” the old props because it runs before we re-render, and then the new effect “sees” the new props because it runs after the re-render. That’s the mental model lifted directly from the class lifecycles, and <strong>it’s not accurate here</strong>. Let’s see why.</p><p>React only runs the effects after <a href="https://medium.com/@dan_abramov/this-benchmark-is-indeed-flawed-c3d6b5b6f97f" target="_blank" rel="noopener">letting the browser paint</a>. This makes your app faster as most effects don’t need to block screen updates. Effect cleanup is also delayed. <strong>The previous effect is cleaned up <em>after</em> the re-render with new props:</strong></p><ul><li><strong>React renders UI for <code>{id: 20}</code>.</strong></li><li>The browser paints. We see the UI for <code>{id: 20}</code> on the screen.</li><li><strong>React cleans up the effect for <code>{id: 10}</code>.</strong></li><li>React runs the effect for <code>{id: 20}</code>.</li></ul><p>You might be wondering: but how can the cleanup of the previous effect still “see” the old <code>{id: 10}</code> props if it runs <em>after</em> the props change to <code>{id: 20}</code>?</p><p>We’ve been here before… 🤔</p><p><img src="https://overreacted.io/deja_vu-5fe238cf03a21dfa32af624124fcdcff.gif" alt></p><p>Quoting the previous section:</p><blockquote><p>Every function inside the component render (including event handlers, effects, timeouts or API calls inside them) captures the props and state of the render call that defined it.</p></blockquote><p>Now the answer is clear! The effect cleanup doesn’t read the “latest” props, whatever that means. It reads props that belong to the render it’s defined in:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Example() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">    </span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      ChatAPI.subscribeToFriendStatus(10, handleStatusChange);</span><br><span class="line">            return () =&gt; &#123;        ChatAPI.unsubscribeFromFriendStatus(10, handleStatusChange);      &#125;;    &#125;</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">    </span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      ChatAPI.subscribeToFriendStatus(20, handleStatusChange);</span><br><span class="line">      </span><br><span class="line">      return () =&gt; &#123;</span><br><span class="line">        ChatAPI.unsubscribeFromFriendStatus(20, handleStatusChange);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kingdoms will rise and turn into ashes, the Sun will shed its outer layers to be a white dwarf, and the last civilization will end. But nothing will make the props “seen” by the first render effect’s cleanup anything other than <code>{id: 10}</code>.</p><p>That’s what allows React to deal with effects right after painting — and make your apps faster by default. The old props are still there if our code needs them.</p><h2 id="Synchronization-Not-Lifecycle"><a href="#Synchronization-Not-Lifecycle" class="headerlink" title="Synchronization, Not Lifecycle"></a><a href="#synchronization-not-lifecycle"></a>Synchronization, Not Lifecycle</h2><p>One of my favorite things about React is that it unifies describing the initial render result and the updates. This <a href="https://overreacted.io/the-bug-o-notation/" target="_blank" rel="noopener">reduces the entropy</a> of your program.</p><p>Say my component looks like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Greeting(&#123; name &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;h1 class&gt;</span><br><span class="line">      Hello, &#123;name&#125;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It doesn’t matter if I render <code>&lt;Greeting /&gt;</code> and later <code>&lt;Greeting /&gt;</code>, or if I just render <code>&lt;Greeting /&gt;</code>. In the end, we will see “Hello, Yuzhi” in both cases.</p><p>People say: “It’s all about the journey, not the destination”. With React, it’s the opposite. <strong>It’s all about the destination, not the journey.</strong> That’s the difference between <code>$.addClass</code> and <code>$.removeClass</code> calls in jQuery code (our “journey”) and specifying what the CSS class <em>should be</em> in React code (our “destination”).</p><p><strong>React synchronizes the DOM according to our current props and state.</strong> There is no distinction between a “mount” or an “update” when rendering.</p><p>You should think of effects in a similar way. <strong><code>useEffect</code> lets you <em>synchronize</em> things outside of the React tree according to our props and state.</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Greeting(&#123; name &#125;) &#123;</span><br><span class="line">  useEffect(() =&gt; &#123;    document.title = &apos;Hello, &apos; + name;  &#125;);  return (</span><br><span class="line">    &lt;h1 class&gt;</span><br><span class="line">      Hello, &#123;name&#125;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is subtly different from the familiar <em>mount/update/unmount</em> mental model. It is important really to internalize this. <strong>If you’re trying to write an effect that behaves differently depending on whether the component renders for the first time or not, you’re swimming against the tide!</strong> We’re failing at synchronizing if our result depends on the “journey” rather than the “destination”.</p><p>It shouldn’t matter whether we rendered with props A, B, and C, or if we rendered with C immediately. While there may be some temporary differences (e.g. while we’re fetching data), eventually the end result should be the same.</p><p>Still, of course running all effects on <em>every</em> render might not be efficient. (And in some cases, it would lead to infinite loops.)</p><p>So how can we fix this?</p><h2 id="Teaching-React-to-Diff-Your-Effects"><a href="#Teaching-React-to-Diff-Your-Effects" class="headerlink" title="Teaching React to Diff Your Effects"></a><a href="#teaching-react-to-diff-your-effects"></a>Teaching React to Diff Your Effects</h2><p>We’ve already learned that lesson with the DOM itself. Instead of touching it on every re-render, React only updates the parts of the DOM that actually change.</p><p>When you’re updating</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 class&gt;</span><br><span class="line">  Hello, Dan</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>to</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 class&gt;</span><br><span class="line">  Hello, Yuzhi</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>React sees two objects:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const oldProps = &#123;className: &apos;Greeting&apos;, children: &apos;Hello, Dan&apos;&#125;;</span><br><span class="line">const newProps = &#123;className: &apos;Greeting&apos;, children: &apos;Hello, Yuzhi&apos;&#125;;</span><br></pre></td></tr></table></figure><p>It goes over each of their props and determine that <code>children</code> have changed and need a DOM update, but <code>className</code> did not. So it can just do:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">domNode.innerText = &apos;Hello, Yuzhi&apos;;</span><br></pre></td></tr></table></figure><p><strong>Could we do something like this with effects too? It would be nice to avoid re-running them when applying the effect is unnecessary.</strong></p><p>For example, maybe our component re-renders because of a state change:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Greeting(&#123; name &#125;) &#123;</span><br><span class="line">  const [counter, setCounter] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    document.title = &apos;Hello, &apos; + name;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;h1 class&gt;</span><br><span class="line">      Hello, &#123;name&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCounter(count + 1)&#125;&gt;        Increment      &lt;/button&gt;    &lt;/h1&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But our effect doesn’t use the <code>counter</code> state. <strong>Our effect synchronizes the <code>document.title</code> with the <code>name</code> prop, but the <code>name</code> prop is the same.</strong> Re-assigning <code>document.title</code> on every counter change seems non-ideal.</p><p>OK, so can React just… diff effects?</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let oldEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;</span><br><span class="line">let newEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;</span><br></pre></td></tr></table></figure><p>Not really. React can’t guess what the function does without calling it. (The source doesn’t really contain specific values, it just closes over the <code>name</code> prop.)</p><p>This is why if you want to avoid re-running effects unnecessarily, you can provide a dependency array (also known as “deps”) argument to <code>useEffect</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  document.title = &apos;Hello, &apos; + name;</span><br><span class="line">&#125;, [name]);</span><br></pre></td></tr></table></figure><p><strong>It’s like if we told React: “Hey, I know you can’t see <em>inside</em> this function, but I promise it only uses <code>name</code> and nothing else from the render scope.”</strong></p><p>If each of these values is the same between the current and the previous time this effect ran, there’s nothing to synchronize so React can skip the effect:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const oldEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;</span><br><span class="line">const oldDeps = [&apos;Dan&apos;];</span><br><span class="line"></span><br><span class="line">const newEffect = () =&gt; &#123; document.title = &apos;Hello, Dan&apos;; &#125;;</span><br><span class="line">const newDeps = [&apos;Dan&apos;];</span><br></pre></td></tr></table></figure><p>If even one of the values in the dependency array is different between renders, we know running the effect can’t be skipped. Synchronize all the things!</p><h2 id="Don’t-Lie-to-React-About-Dependencies"><a href="#Don’t-Lie-to-React-About-Dependencies" class="headerlink" title="Don’t Lie to React About Dependencies"></a><a href="#dont-lie-to-react-about-dependencies"></a>Don’t Lie to React About Dependencies</h2><p>Lying to React about dependencies has bad consequences. Intuitively, this makes sense, but I’ve seen pretty much everyone who tries <code>useEffect</code> with a mental model from classes try to cheat the rules. (And I did that too at first!)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  async function fetchData() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>(The <a href="https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" target="_blank" rel="noopener">Hooks FAQ</a> explains what to do instead. We’ll come back to this example <a href="#moving-functions-inside-effects">below</a>.)</em></p><p>“But I only want to run it on mount!”, you’ll say. For now, remember: if you specify deps, <strong><em>all</em> values from inside your component that are used by the effect <em>must</em> be there</strong>. Including props, state, functions — anything in your component.</p><p>Sometimes when you do that, it causes a problem. For example, maybe you see an infinite refetching loop, or a socket is recreated too often. <strong>The solution to that problem is <em>not</em> to remove a dependency.</strong> We’ll look at the solutions soon.</p><p>But before we jump to solutions, let’s understand the problem better.</p><h2 id="What-Happens-When-Dependencies-Lie"><a href="#What-Happens-When-Dependencies-Lie" class="headerlink" title="What Happens When Dependencies Lie"></a><a href="#what-happens-when-dependencies-lie"></a>What Happens When Dependencies Lie</h2><p>If deps contain every value used by the effect, React knows when to re-run it:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  document.title = &apos;Hello, &apos; + name;</span><br><span class="line">&#125;, [name]);</span><br></pre></td></tr></table></figure><p><img src="https://overreacted.io/deps-compare-correct-fae247cd068eedbd4b62ba50592d2b3d.gif" alt></p><p><em>(Dependencies are different, so we re-run the effect.)</em></p><p>But if we specified <code>[]</code> for this effect, the new effect function wouldn’t run:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  document.title = &apos;Hello, &apos; + name;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p><img src="https://overreacted.io/deps-compare-wrong-25f75db3f9f57ffe1426912093577445.gif" alt></p><p><em>(Dependencies are equal, so we skip the effect.)</em></p><p>In this case the problem might seem obvious. But the intuition can fool you in other cases where a class solution “jumps out” from your memory.</p><p>For example, let’s say we’re writing a counter that increments every second. With a class, our intuition is: “Set up the interval once and destroy it once”. Here’s an <a href="https://codesandbox.io/s/n5mjzjy9kl" target="_blank" rel="noopener">example</a> of how we can do it. When we mentally translate this code to <code>useEffect</code>, we instinctively add <code>[]</code> to the deps. “I want it to run once”, right?</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const id = setInterval(() =&gt; &#123;</span><br><span class="line">      setCount(count + 1);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    return () =&gt; clearInterval(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>However, this example <a href="https://codesandbox.io/s/91n5z8jo7r" target="_blank" rel="noopener">only <em>increments</em> once</a>. <em>Oops.</em></p><p>If your mental model is “dependencies let me specify when I want to re-trigger the effect”, this example might give you an existential crisis. You <em>want</em> to trigger it once because it’s an interval — so why is it causing issues?</p><p>However, this makes sense if you know that dependencies are our hint to React about <em>everything</em> that the effect uses from the render scope. It uses <code>count</code> but we lied that it doesn’t with <code>[]</code>. It’s only a matter of time before this bites us!</p><p>In the first render, <code>count</code> is <code>0</code>. Therefore, <code>setCount(count + 1)</code> in the first render’s effect means <code>setCount(0 + 1)</code>. <strong>Since we never re-run the effect because of <code>[]</code> deps, it will keep calling <code>setCount(0 + 1)</code> every second:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">    </span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      const id = setInterval(() =&gt; &#123;</span><br><span class="line">        setCount(0 + 1);       &#125;, 1000);</span><br><span class="line">      return () =&gt; clearInterval(id);</span><br><span class="line">    &#125;,</span><br><span class="line">    []   );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">            () =&gt; &#123;</span><br><span class="line">      const id = setInterval(() =&gt; &#123;</span><br><span class="line">        setCount(1 + 1);</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">      return () =&gt; clearInterval(id);</span><br><span class="line">    &#125;,</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We lied to React by saying our effect doesn’t depend on a value from inside our component, when in fact it does!</p><p>Our effect uses <code>count</code> — a value inside the component (but outside the effect):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const count = </span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const id = setInterval(() =&gt; &#123;</span><br><span class="line">    setCount(count + 1);    &#125;, 1000);</span><br><span class="line">  return () =&gt; clearInterval(id);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>Therefore, specifying <code>[]</code> as a dependency will create a bug. React will compare the dependencies, and skip updating this effect:</p><p><img src="https://overreacted.io/interval-wrong-29e53bd0c9b7d2ac70d3cd924886b030.gif" alt></p><p><em>(Dependencies are equal, so we skip the effect.)</em></p><p>Issues like this are difficult to think about. Therefore, I encourage you to adopt it as a hard rule to always be honest about the effect dependencies, and specify them all. (We provide a <a href="https://github.com/facebook/react/issues/14920" target="_blank" rel="noopener">lint rule</a> if you want to enforce this on your team.)</p><h2 id="Two-Ways-to-Be-Honest-About-Dependencies"><a href="#Two-Ways-to-Be-Honest-About-Dependencies" class="headerlink" title="Two Ways to Be Honest About Dependencies"></a><a href="#two-ways-to-be-honest-about-dependencies"></a>Two Ways to Be Honest About Dependencies</h2><p>There are two strategies to be honest about dependencies. You should generally start with the first one, and then apply the second one if needed.</p><p><strong>The first strategy is to fix the dependency array to include <em>all</em> the values inside the component that are used inside the effect.</strong> Let’s include <code>count</code> as a dep:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const id = setInterval(() =&gt; &#123;</span><br><span class="line">    setCount(count + 1);  &#125;, 1000);</span><br><span class="line">  return () =&gt; clearInterval(id);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure><p>This makes the dependency array correct. It may not be <em>ideal</em> but that’s the first issue we needed to fix. Now a change to <code>count</code> will re-run the effect, with each next interval referencing <code>count</code> from its render in <code>setCount(count + 1)</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">    </span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      const id = setInterval(() =&gt; &#123;</span><br><span class="line">        setCount(0 + 1);       &#125;, 1000);</span><br><span class="line">      return () =&gt; clearInterval(id);</span><br><span class="line">    &#125;,</span><br><span class="line">    [0]   );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(</span><br><span class="line">    </span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      const id = setInterval(() =&gt; &#123;</span><br><span class="line">        setCount(1 + 1);       &#125;, 1000);</span><br><span class="line">      return () =&gt; clearInterval(id);</span><br><span class="line">    &#125;,</span><br><span class="line">    [1]   );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>That would <a href="https://codesandbox.io/s/0x0mnlyq8l" target="_blank" rel="noopener">fix the problem</a> but our interval would be cleared and set again whenever the <code>count</code> changes. That may be undesirable:</p><p><img src="https://overreacted.io/interval-rightish-5734271ddfa94d2d65ac6160515e0069.gif" alt></p><p><em>(Dependencies are different, so we re-run the effect.)</em></p><p><strong>The second strategy is to change our effect code so that it wouldn’t <em>need</em> a value that changes more often than we want.</strong> We don’t want to lie about the dependencies — we just want to change our effect to have <em>fewer</em> of them.</p><p>Let’s look at a few common techniques for removing dependencies.</p><h2 id="Making-Effects-Self-Sufficient"><a href="#Making-Effects-Self-Sufficient" class="headerlink" title="Making Effects Self-Sufficient"></a><a href="#making-effects-self-sufficient"></a>Making Effects Self-Sufficient</h2><p>We want to get rid of the <code>count</code> dependency in our effect.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const id = setInterval(() =&gt; &#123;</span><br><span class="line">    setCount(count + 1);    &#125;, 1000);</span><br><span class="line">  return () =&gt; clearInterval(id);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure><p>To do this, we need to ask ourselves: <strong>what are we using <code>count</code> for?</strong> It seems like we only use it for the <code>setCount</code> call. In that case, we don’t actually need <code>count</code> in the scope at all. When we want to update state based on the previous state, we can use the <a href="https://reactjs.org/docs/hooks-reference.html#functional-updates" target="_blank" rel="noopener">functional updater form</a> of <code>setState</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const id = setInterval(() =&gt; &#123;</span><br><span class="line">    setCount(c =&gt; c + 1);    &#125;, 1000);</span><br><span class="line">  return () =&gt; clearInterval(id);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>I like to think of these cases as “false dependencies”. Yes, <code>count</code> was a necessary dependency because we wrote <code>setCount(count + 1)</code> inside the effect. However, we only truly needed <code>count</code> to transform it into <code>count + 1</code> and “send it back” to React. But React <em>already knows</em> the current <code>count</code>. <strong>All we needed to tell React is to increment the state — whatever it is right now.</strong></p><p>That’s exactly what <code>setCount(c =&gt; c + 1)</code> does. You can think of it as “sending an instruction” to React about how the state should change. This “updater form” also helps in other cases, like when you <a href="https://overreacted.io/react-as-a-ui-runtime/#batching" target="_blank" rel="noopener">batch multiple updates</a>.</p><p><strong>Note that we actually <em>did the work</em> to remove the dependency. We didn’t cheat. Our effect doesn’t read the <code>counter</code> value from the render scope anymore:</strong></p><p><img src="https://overreacted.io/interval-right-f128ad20c28317ed27a3cb68197fc906.gif" alt></p><p><em>(Dependencies are equal, so we skip the effect.)</em></p><p>You can try it <a href="https://codesandbox.io/s/q3181xz1pj" target="_blank" rel="noopener">here</a>.</p><p>Even though this effect only runs once, the interval callback that belongs to the first render is perfectly capable of sending the <code>c =&gt; c + 1</code> update instruction every time the interval fires. It doesn’t need to know the current <code>counter</code> state anymore. React already knows it.</p><h2 id="Functional-Updates-and-Google-Docs"><a href="#Functional-Updates-and-Google-Docs" class="headerlink" title="Functional Updates and Google Docs"></a><a href="#functional-updates-and-google-docs"></a>Functional Updates and Google Docs</h2><p>Remember how we talked about synchronization being the mental model for effects? An interesting aspect of synchronization is that you often want to keep the “messages” between the systems untangled from their state. For example, editing a document in Google Docs doesn’t actually send the <em>whole</em> page to the server. That would be very inefficient. Instead, it sends a representation of what the user tried to do.</p><p>While our use case is different, a similar philosophy applies to effects. <strong>It helps to send only the minimal necessary information from inside the effects into a component.</strong> The updater form like <code>setCount(c =&gt; c + 1)</code> conveys strictly less information than <code>setCount(count + 1)</code> because it isn’t “tainted” by the current count. It only expresses the action (“incrementing”). Thinking in React involves <a href="https://reactjs.org/docs/thinking-in-react.html#step-3-identify-the-minimal-but-complete-representation-of-ui-state" target="_blank" rel="noopener">finding the minimal state</a>. This is the same principle, but for updates.</p><p>Encoding the <em>intent</em> (rather than the result) is similar to how Google Docs <a href="https://medium.com/@srijancse/how-real-time-collaborative-editing-work-operational-transformation-ac4902d75682" target="_blank" rel="noopener">solves</a> collaborative editing. While this is stretching the analogy, functional updates serve a similar role in React. They ensure updates from multiple sources (event handlers, effect subscriptions, etc) can be correctly applied in a batch and in a predictable way.</p><p><strong>However, even <code>setCount(c =&gt; c + 1)</code> isn’t that great.</strong> It looks a bit weird and it’s very limited in what it can do. For example, if we had two state variables whose values depend on each other, or if we needed to calculate the next state based on a prop, it wouldn’t help us. Luckily, <code>setCount(c =&gt; c + 1)</code> has a more powerful sister pattern. Its name is <code>useReducer</code>.</p><h2 id="Decoupling-Updates-from-Actions"><a href="#Decoupling-Updates-from-Actions" class="headerlink" title="Decoupling Updates from Actions"></a><a href="#decoupling-updates-from-actions"></a>Decoupling Updates from Actions</h2><p>Let’s modify the previous example to have two state variables: <code>count</code> and <code>step</code>. Our interval will increment the count by the value of the <code>step</code> input:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const [step, setStep] = useState(1);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const id = setInterval(() =&gt; &#123;</span><br><span class="line">      setCount(c =&gt; c + step);    &#125;, 1000);</span><br><span class="line">    return () =&gt; clearInterval(id);</span><br><span class="line">  &#125;, [step]);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;input value=&#123;step&#125; onChange=&#123;e =&gt; setStep(Number(e.target.value))&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(Here’s a <a href="https://codesandbox.io/s/zxn70rnkx" target="_blank" rel="noopener">demo</a>.)</p><p>Note that <strong>we’re not cheating</strong>. Since I started using <code>step</code> inside the effect, I added it to the dependencies. And that’s why the code runs correctly.</p><p>The current behavior in this example is that changing the <code>step</code> restarts the interval — because it’s one of the dependencies. And in many cases, that is exactly what you want! There’s nothing wrong with tearing down an effect and setting it up anew, and we shouldn’t avoid that unless we have a good reason.</p><p>However, let’s say we want the interval clock to not reset on changes to the <code>step</code>. How do we remove the <code>step</code> dependency from our effect?</p><p><strong>When setting a state variable depends on the current value of another state variable, you might want to try replacing them both with <code>useReducer</code>.</strong></p><p>When you find yourself writing <code>setSomething(something =&gt; ...)</code>, it’s a good time to consider using a reducer instead. A reducer lets you <strong>decouple expressing the “actions” that happened in your component from how the state updates in response to them</strong>.</p><p>Let’s trade the <code>step</code> dependency for a <code>dispatch</code> dependency in our effect:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [state, dispatch] = useReducer(reducer, initialState);const &#123; count, step &#125; = state;</span><br><span class="line"></span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const id = setInterval(() =&gt; &#123;</span><br><span class="line">    dispatch(&#123; type: &apos;tick&apos; &#125;);   &#125;, 1000);</span><br><span class="line">  return () =&gt; clearInterval(id);</span><br><span class="line">&#125;, [dispatch]);</span><br></pre></td></tr></table></figure><p>(See the <a href="https://codesandbox.io/s/xzr480k0np" target="_blank" rel="noopener">demo</a>.)</p><p>You might ask me: “How is this any better?” The answer is that <strong>React guarantees the <code>dispatch</code> function to be constant throughout the component lifetime. So the example above doesn’t ever need to resubscribe the interval.</strong></p><p>We solved our problem!</p><p><em>(You may omit <code>dispatch</code>, <code>setState</code>, and <code>useRef</code> container values from the deps because React guarantees them to be static. But it also doesn’t hurt to specify them.)</em></p><p>Instead of reading the state <em>inside</em> an effect, it dispatches an <em>action</em> that encodes the information about <em>what happened</em>. This allows our effect to stay decoupled from the <code>step</code> state. Our effect doesn’t care <em>how</em> we update the state, it just tells us about <em>what happened</em>. And the reducer centralizes the update logic:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const initialState = &#123;</span><br><span class="line">  count: 0,</span><br><span class="line">  step: 1,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">  const &#123; count, step &#125; = state;</span><br><span class="line">  if (action.type === &apos;tick&apos;) &#123;    return &#123; count: count + step, step &#125;;  &#125; else if (action.type === &apos;step&apos;) &#123;</span><br><span class="line">    return &#123; count, step: action.step &#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw new Error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(Here’s a <a href="https://codesandbox.io/s/xzr480k0np" target="_blank" rel="noopener">demo</a> if you missed it earlier).</p><h2 id="Why-useReducer-Is-the-Cheat-Mode-of-Hooks"><a href="#Why-useReducer-Is-the-Cheat-Mode-of-Hooks" class="headerlink" title="Why useReducer Is the Cheat Mode of Hooks"></a><a href="#why-usereducer-is-the-cheat-mode-of-hooks"></a>Why useReducer Is the Cheat Mode of Hooks</h2><p>We’ve seen how to remove dependencies when an effect needs to set state based on previous state, or on another state variable. <strong>But what if we need <em>props</em> to calculate the next state?</strong> For example, maybe our API is <code>&lt;Counter step={1} /&gt;</code>. Surely, in this case we can’t avoid specifying <code>props.step</code> as a dependency?</p><p>In fact, we can! We can put <em>the reducer itself</em> inside our component to read props:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Counter(&#123; step &#125;) &#123;  const [count, dispatch] = useReducer(reducer, 0);</span><br><span class="line"></span><br><span class="line">  function reducer(state, action) &#123;</span><br><span class="line">    if (action.type === &apos;tick&apos;) &#123;</span><br><span class="line">      return state + step;    &#125; else &#123;</span><br><span class="line">      throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const id = setInterval(() =&gt; &#123;</span><br><span class="line">      dispatch(&#123; type: &apos;tick&apos; &#125;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    return () =&gt; clearInterval(id);</span><br><span class="line">  &#125;, [dispatch]);</span><br><span class="line"></span><br><span class="line">  return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This pattern disables a few optimizations so try not to use it everywhere, but you can totally access props from a reducer if you need to. (Here’s a <a href="https://codesandbox.io/s/7ypm405o8q" target="_blank" rel="noopener">demo</a>.)</p><p><strong>Even in that case, <code>dispatch</code> identity is still guaranteed to be stable between re-renders.</strong> So you may omit it from the effect deps if you want. It’s not going to cause the effect to re-run.</p><p>You may be wondering: how can this possibly work? How can the reducer “know” props when called from inside an effect that belongs to another render? The answer is that when you <code>dispatch</code>, React just remembers the action — but it will <em>call</em> your reducer during the next render. At that point the fresh props will be in scope, and you won’t be inside an effect.</p><p><strong>This is why I like to think of <code>useReducer</code> as the “cheat mode” of Hooks. It lets me decouple the update logic from describing what happened. This, in turn, helps me remove unnecessary dependencies from my effects and avoid re-running them more often than necessary.</strong></p><h2 id="Moving-Functions-Inside-Effects"><a href="#Moving-Functions-Inside-Effects" class="headerlink" title="Moving Functions Inside Effects"></a><a href="#moving-functions-inside-effects"></a>Moving Functions Inside Effects</h2><p>A common mistake is to think functions shouldn’t be dependencies. For example, this seems like it could work:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  const [data, setData] = useState(&#123; hits: [] &#125;);</span><br><span class="line"></span><br><span class="line">  async function fetchData() &#123;</span><br><span class="line">    const result = await axios(</span><br><span class="line">      &apos;https://hn.algolia.com/api/v1/search?query=react&apos;,</span><br><span class="line">    );</span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure><p><em>(<a href="https://codesandbox.io/s/8j4ykjyv0" target="_blank" rel="noopener">This example</a> is adapted from a great article by Robin Wieruch — <a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="noopener">check it out</a>!)</em></p><p>And to be clear, this code <em>does</em> work. <strong>But the problem with simply omitting local functions is that it gets pretty hard to tell whether we’re handling all cases as the component grows!</strong></p><p>Imagine our code was split like this and each function was five times larger:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  </span><br><span class="line">  function getFetchUrl() &#123;</span><br><span class="line">    return &apos;https://hn.algolia.com/api/v1/search?query=react&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  async function fetchData() &#123;</span><br><span class="line">    const result = await axios(getFetchUrl());</span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now let’s say we later use some state or prop in one of these functions:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  const [query, setQuery] = useState(&apos;react&apos;);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  function getFetchUrl() &#123;</span><br><span class="line">    return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  async function fetchData() &#123;</span><br><span class="line">    const result = await axios(getFetchUrl());</span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If we forget to update the deps of any effects that call these functions (possibly, through other functions!), our effects will fail to synchronize changes from our props and state. This doesn’t sound great.</p><p>Luckily, there is an easy solution to this problem. <strong>If you only use some functions <em>inside</em> an effect, move them directly <em>into</em> that effect:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  </span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">        function getFetchUrl() &#123;      return &apos;https://hn.algolia.com/api/v1/search?query=react&apos;;    &#125;    async function fetchData() &#123;      const result = await axios(getFetchUrl());      setData(result.data);    &#125;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []); </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(<a href="https://codesandbox.io/s/04kp3jwwql" target="_blank" rel="noopener">Here’s a demo</a>.)</p><p>So what is the benefit? We no longer have to think about the “transitive dependencies”. Our dependencies array isn’t lying anymore: <strong>we truly <em>aren’t</em> using anything from the outer scope of the component in our effect</strong>.</p><p>If we later edit <code>getFetchUrl</code> to use the <code>query</code> state, we’re much more likely to notice that we’re editing it <em>inside</em> an effect — and therefore, we need to add <code>query</code> to the effect dependencies:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  const [query, setQuery] = useState(&apos;react&apos;);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    function getFetchUrl() &#123;</span><br><span class="line">      return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;    &#125;</span><br><span class="line"></span><br><span class="line">    async function fetchData() &#123;</span><br><span class="line">      const result = await axios(getFetchUrl());</span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [query]); </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(Here’s a <a href="https://codesandbox.io/s/pwm32zx7z7" target="_blank" rel="noopener">demo</a>.)</p><p>By adding this dependency, we’re not just “appeasing React”. It <em>makes sense</em> to refetch the data when the query changes. <strong>The design of <code>useEffect</code> forces you to notice the change in our data flow and choose how our effects should synchronize it — instead of ignoring it until our product users hit a bug.</strong></p><p>Thanks to the <code>exhaustive-deps</code> lint rule from the <code>eslint-plugin-react-hooks</code> plugin, you can <a href="https://github.com/facebook/react/issues/14920" target="_blank" rel="noopener">analyze the effects as you type in your editor</a> and receive suggestions about which dependencies are missing. In other words, a machine can tell you which data flow changes aren’t handled correctly by a component.</p><p><img src="https://overreacted.io/exhaustive-deps-04a90dcbacb01105d634964880ebed19.gif" alt></p><p>Pretty sweet.</p><h2 id="But-I-Can’t-Put-This-Function-Inside-an-Effect"><a href="#But-I-Can’t-Put-This-Function-Inside-an-Effect" class="headerlink" title="But I Can’t Put This Function Inside an Effect"></a><a href="#but-i-cant-put-this-function-inside-an-effect"></a>But I Can’t Put This Function Inside an Effect</h2><p>Sometimes you might not want to move a function <em>inside</em> an effect. For example, several effects in the same component may call the same function, and you don’t want to copy and paste its logic. Or maybe it’s a prop.</p><p>Should you skip a function like this in the effect dependencies? I think not. Again, <strong>effects shouldn’t lie about their dependencies.</strong> There are usually better solutions. A common misconception is that “a function would never change”. But as we learned throughout this article, this couldn’t be further from truth. Indeed, a function defined inside a component changes on every render!</p><p><strong>That by itself presents a problem.</strong> Say two effects call <code>getFetchUrl</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  function getFetchUrl(query) &#123;</span><br><span class="line">    return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;react&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, []); </span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;redux&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, []); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In that case you might not want to move <code>getFetchUrl</code> inside either of the effects since you wouldn’t be able to share the logic.</p><p>On the other hand, if you’re “honest” about the effect dependencies, you may run into a problem. Since both our effects depend on <code>getFetchUrl</code> <strong>(which is different on every render)</strong>, our dependency arrays are useless:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">    function getFetchUrl(query) &#123;    return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;  &#125;</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;react&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, [getFetchUrl]); </span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;redux&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, [getFetchUrl]); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A tempting solution to this is to just skip the <code>getFetchUrl</code> function in the deps list. However, I don’t think it’s a good solution. This makes it difficult to notice when we <em>are</em> adding a change to the data flow that <em>needs</em> to be handled by an effect. This leads to bugs like the “never updating interval” we saw earlier.</p><p>Instead, there are two other solutions that are simpler.</p><p><strong>First of all, if a function doesn’t use anything from the component scope, you can hoist it outside the component and then freely use it inside your effects:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getFetchUrl(query) &#123;  return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;&#125;</span><br><span class="line">function SearchResults() &#123;</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;react&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, []); </span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;redux&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, []); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There’s no need to specify it in deps because it’s not in the render scope and can’t be affected by the data flow. It can’t accidentally depend on props or state.</p><p>Alternatively, you can wrap it into the <a href="https://reactjs.org/docs/hooks-reference.html#usecallback" target="_blank" rel="noopener"><code>useCallback</code> Hook</a>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">    const getFetchUrl = useCallback((query) =&gt; &#123;    return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;  &#125;, []);  </span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;react&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, [getFetchUrl]); </span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl(&apos;redux&apos;);</span><br><span class="line">    </span><br><span class="line">  &#125;, [getFetchUrl]); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>useCallback</code> is essentially like adding another layer of dependency checks. It’s solving the problem on the other end — <strong>rather than avoid a function dependency, we make the function itself only change when necessary</strong>.</p><p>Let’s see why this approach is useful. Previously, our example showed two search results (for <code>&#39;react&#39;</code> and <code>&#39;redux&#39;</code> search queries). But let’s say we want to add an input so that you can search for an arbitrary <code>query</code>. So instead of taking <code>query</code> as an argument, <code>getFetchUrl</code> will now read it from local state.</p><p>We’ll immediately see that it’s missing a <code>query</code> dependency:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  const [query, setQuery] = useState(&apos;react&apos;);</span><br><span class="line">  const getFetchUrl = useCallback(() =&gt; &#123; </span><br><span class="line">    return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;</span><br><span class="line">  &#125;, []);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If I fix my <code>useCallback</code> deps to include <code>query</code>, any effect with <code>getFetchUrl</code> in deps will re-run whenever the <code>query</code> changes:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SearchResults() &#123;</span><br><span class="line">  const [query, setQuery] = useState(&apos;react&apos;);</span><br><span class="line"></span><br><span class="line">    const getFetchUrl = useCallback(() =&gt; &#123;    return &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;  &#125;, [query]);  </span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const url = getFetchUrl();</span><br><span class="line">    </span><br><span class="line">  &#125;, [getFetchUrl]); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thanks to <code>useCallback</code>, if <code>query</code> is the same, <code>getFetchUrl</code> also stays the same, and our effect doesn’t re-run. But if <code>query</code> changes, <code>getFetchUrl</code> will also change, and we will re-fetch the data. It’s a lot like when you change some cell in an Excel spreadsheet, and the other cells using it recalculate automatically.</p><p>This is just a consequence of embracing the data flow and the synchronization mindset. <strong>The same solution works for function props passed from parents:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">  const [query, setQuery] = useState(&apos;react&apos;);</span><br><span class="line"></span><br><span class="line">    const fetchData = useCallback(() =&gt; &#123;    const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + query;      &#125;, [query]);  </span><br><span class="line">  return &lt;Child fetchData=&#123;fetchData&#125; /&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child(&#123; fetchData &#125;) &#123;</span><br><span class="line">  let [data, setData] = useState(null);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    fetchData().then(setData);</span><br><span class="line">  &#125;, [fetchData]); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since <code>fetchData</code> only changes inside <code>Parent</code> when its <code>query</code> state changes, our <code>Child</code> won’t refetch the data until it’s actually necessary for the app.</p><h2 id="Are-Functions-Part-of-the-Data-Flow"><a href="#Are-Functions-Part-of-the-Data-Flow" class="headerlink" title="Are Functions Part of the Data Flow?"></a><a href="#are-functions-part-of-the-data-flow"></a>Are Functions Part of the Data Flow?</h2><p>Interestingly, this pattern is broken with classes in a way that really shows the difference between the effect and lifecycle paradigms. Consider this translation:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Parent extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    query: &apos;react&apos;</span><br><span class="line">  &#125;;</span><br><span class="line">  fetchData = () =&gt; &#123;    const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + this.state.query;      &#125;;  render() &#123;</span><br><span class="line">    return &lt;Child fetchData=&#123;this.fetchData&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    data: null</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;    this.props.fetchData();  &#125;  render() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You might be thinking: “Come on Dan, we all know that <code>useEffect</code> is like <code>componentDidMount</code> and <code>componentDidUpdate</code> combined, you can’t keep beating that drum!” <strong>Yet this doesn’t work even with <code>componentDidUpdate</code>:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Child extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    data: null</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.props.fetchData();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps) &#123;        if (this.props.fetchData !== prevProps.fetchData) &#123;      this.props.fetchData();    &#125;  &#125;  render() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Of course, <code>fetchData</code> is a class method! (Or, rather, a class property — but that doesn’t change anything.) It’s not going to be different because of a state change. So <code>this.props.fetchData</code> will stay equal to <code>prevProps.fetchData</code> and we’ll never refetch. Let’s just remove this condition then?</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentDidUpdate(prevProps) &#123;</span><br><span class="line">  this.props.fetchData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Oh wait, this fetches on <em>every</em> re-render. (Adding an animation above in the tree is a fun way to discover it.) Maybe let’s bind it to a particular query?</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return &lt;Child fetchData=&#123;this.fetchData.bind(this, this.state.query)&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But then <code>this.props.fetchData !== prevProps.fetchData</code> is <em>always</em> <code>true</code>, even if the <code>query</code> didn’t change! So we’ll <em>always</em> refetch.</p><p>The only real solution to this conundrum with classes is to bite the bullet and pass the <code>query</code> itself into the <code>Child</code> component. The <code>Child</code> doesn’t actually end up <em>using</em> the <code>query</code>, but it can trigger a refetch when it changes:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Parent extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    query: &apos;react&apos;</span><br><span class="line">  &#125;;</span><br><span class="line">  fetchData = () =&gt; &#123;</span><br><span class="line">    const url = &apos;https://hn.algolia.com/api/v1/search?query=&apos; + this.state.query;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;Child fetchData=&#123;this.fetchData&#125; query=&#123;this.state.query&#125; /&gt;;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    data: null</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.props.fetchData();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps) &#123;</span><br><span class="line">    if (this.props.query !== prevProps.query) &#123;      this.props.fetchData();    &#125;  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Over the years of working with classes with React, I’ve gotten so used to passing unnecessary props down and breaking encapsulation of parent components that I only realized a week ago why we had to do it.</p><p><strong>With classes, function props by themselves aren’t truly a part of the data flow.</strong> Methods close over the mutable <code>this</code> variable so we can’t rely on their identity to mean anything. Therefore, even when we only want a function, we have to pass a bunch of other data around in order to be able to “diff” it. We can’t know whether <code>this.props.fetchData</code> passed from the parent depends on some state or not, and whether that state has just changed.</p><p><strong>With <code>useCallback</code>, functions can fully participate in the data flow.</strong> We can say that if the function inputs changed, the function itself has changed, but if not, it stayed the same. Thanks to the granularity provided by <code>useCallback</code>, changes to props like <code>props.fetchData</code> can propagate down automatically.</p><p>Similarly, <a href="https://reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener"><code>useMemo</code></a> lets us do the same for complex objects:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ColorPicker() &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  const [color, setColor] = useState(&apos;pink&apos;);</span><br><span class="line">  const style = useMemo(() =&gt; (&#123; color &#125;), [color]);</span><br><span class="line">  return &lt;Child style=&#123;style&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>I want to emphasize that putting <code>useCallback</code> everywhere is pretty clunky.</strong> It’s a nice escape hatch and it’s useful when a function is both passed down <em>and</em> called from inside an effect in some children. Or if you’re trying to prevent breaking memoization of a child component. But Hooks lend themselves better to <a href="https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down" target="_blank" rel="noopener">avoiding passing callbacks down</a> altogether.</p><p>In the above examples, I’d much prefer if <code>fetchData</code> was either inside my effect (which itself could be extracted to a custom Hook) or a top-level import. I want to keep the effects simple, and callbacks in them don’t help that. (“What if some <code>props.onComplete</code> callback changes while the request was in flight?”) You can <a href="#swimming-against-the-tide">simulate the class behavior</a> but that doesn’t solve race conditions.</p><h2 id="Speaking-of-Race-Conditions"><a href="#Speaking-of-Race-Conditions" class="headerlink" title="Speaking of Race Conditions"></a><a href="#speaking-of-race-conditions"></a>Speaking of Race Conditions</h2><p>A classic data fetching example with classes might look like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Article extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    article: null</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.fetchData(this.props.id);</span><br><span class="line">  &#125;</span><br><span class="line">  async fetchData(id) &#123;</span><br><span class="line">    const article = await API.fetchArticle(id);</span><br><span class="line">    this.setState(&#123; article &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As you probably know, this code is buggy. It doesn’t handle updates. So the second classic example you could find online is something like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Article extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    article: null</span><br><span class="line">  &#125;;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.fetchData(this.props.id);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps) &#123;    if (prevProps.id !== this.props.id) &#123;      this.fetchData(this.props.id);    &#125;  &#125;  async fetchData(id) &#123;</span><br><span class="line">    const article = await API.fetchArticle(id);</span><br><span class="line">    this.setState(&#123; article &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is definitely better! But it’s still buggy. The reason it’s buggy is that the request may come out of order. So if I’m fetching <code>{id: 10}</code>, switch to <code>{id: 20}</code>, but the <code>{id: 20}</code> request comes first, the request that started earlier but finished later would incorrectly overwrite my state.</p><p>This is called a race condition, and it’s typical in code that mixes <code>async</code> / <code>await</code> (which assumes something waits for the result) with top-down data flow (props or state can change while we’re in the middle of an async function).</p><p>Effects don’t magically solve this problem, although they’ll warn you if you try to pass an <code>async</code> function to the effect directly. (We’ll need to improve that warning to better explain the problems you might run into.)</p><p>If the async approach you use supports cancellation, that’s great! You can cancel the async request right in your cleanup function.</p><p>Alternatively, the easiest stopgap approach is to track it with a boolean:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Article(&#123; id &#125;) &#123;</span><br><span class="line">  const [article, setArticle] = useState(null);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    let didCancel = false;</span><br><span class="line">    async function fetchData() &#123;</span><br><span class="line">      const article = await API.fetchArticle(id);</span><br><span class="line">      if (!didCancel) &#123;        setArticle(article);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123;      didCancel = true;    &#125;;  &#125;, [id]);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="noopener">This article</a> goes into more detail about how you can handle errors and loading states, as well as extract that logic into a custom Hook. I recommend you to check it out if you’re interested to learn more about data fetching with Hooks.</p><h2 id="Raising-the-Bar"><a href="#Raising-the-Bar" class="headerlink" title="Raising the Bar"></a><a href="#raising-the-bar"></a>Raising the Bar</h2><p>With the class lifecycle mindset, side effects behave differently from the render output. Rendering the UI is driven by props and state, and is guaranteed to be consistent with them, but side effects are not. This is a common source of bugs.</p><p>With the mindset of <code>useEffect</code>, things are synchronized by default. Side effects become a part of the React data flow. For every <code>useEffect</code> call, once you get it right, your component handles edge cases much better.</p><p>However, the upfront cost of getting it right is higher. This can be annoying. Writing synchronization code that handles edge cases well is inherently more difficult than firing one-off side effects that aren’t consistent with rendering.</p><p>This could be worrying if <code>useEffect</code> was meant to be <em>the</em> tool you use most of the time. However, it’s a low-level building block. It’s an early time for Hooks so everybody uses low-level ones all the time, especially in tutorials. But in practice, it’s likely the community will start moving to higher-level Hooks as good APIs gain momentum.</p><p>I’m seeing different apps create their own Hooks like <code>useFetch</code> that encapsulates some of their app’s auth logic or <code>useTheme</code> which uses theme context. Once you have a toolbox of those, you don’t reach for <code>useEffect</code> <em>that</em> often. But the resilience it brings benefits every Hook built on top of it.</p><p>So far, <code>useEffect</code> is most commonly used for data fetching. But data fetching isn’t exactly a synchronization problem. This is especially obvious because our deps are often <code>[]</code>. What are we even synchronizing?</p><p>In the longer term, <a href="https://reactjs.org/blog/2018/11/27/react-16-roadmap.html#react-16x-mid-2019-the-one-with-suspense-for-data-fetching" target="_blank" rel="noopener">Suspense for Data Fetching</a> will allow third-party libraries to have a first-class way to tell React to suspend rendering until something async (anything: code, data, images) is ready.</p><p>As Suspense gradually covers more data fetching use cases, I anticipate that <code>useEffect</code> will fade into background as a power user tool for cases when you actually want to synchronize props and state to some side effect. Unlike data fetching, it handles this case naturally because it was designed for it. But until then, custom Hooks like <a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="noopener">shown here</a> are a good way to reuse data fetching logic.</p><h2 id="In-Closing"><a href="#In-Closing" class="headerlink" title="In Closing"></a><a href="#in-closing"></a>In Closing</h2><p>Now that you know pretty much everything I know about using effects, check out the <a href="#tldr">TLDR</a> in the beginning. Does it make sense? Did I miss something? (I haven’t run out of paper yet!)</p><p>I’d love to hear from you on Twitter! Thanks for reading.</p>]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
        <category>React Hooks</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React Hooks</tag>
        <tag>useEffect</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的工作原理：现代网络浏览器幕后揭秘</title>
    <url>/archives/35c4.html</url>
    <content><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a></p></blockquote><p>网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 <code>google.com</code> 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。</p><h3 id="我们要讨论的浏览器"><a href="#我们要讨论的浏览器" class="headerlink" title="我们要讨论的浏览器"></a>我们要讨论的浏览器</h3><p>目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera。本文中以开放源代码浏览器为例，即 Firefox、Chrome 浏览器和 Safari（部分开源）。根据 <a href="http://gs.statcounter.com/" target="_blank" rel="noopener">StatCounter 浏览器统计数据</a>，目前（2011 年 8 月）Firefox、Safari 和 Chrome 浏览器的总市场占有率将近 60%。由此可见，如今开放源代码浏览器在浏览器市场中占据了非常坚实的部分。</p><h3 id="浏览器的主要功能"><a href="#浏览器的主要功能" class="headerlink" title="浏览器的主要功能"></a>浏览器的主要功能</h3><p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</p><p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。<br>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。</p><p>浏览器的用户界面有很多彼此相同的元素，其中包括：</p><ul><li>用来输入 URI 的地址栏</li><li>前进和后退按钮</li><li>书签设置选项</li><li>用于刷新和停止加载当前文档的刷新和停止按钮</li><li>用于返回主页的主页按钮</li></ul><p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。</p><h3 id="浏览器的高层结构"><a href="#浏览器的高层结构" class="headerlink" title="浏览器的高层结构"></a>浏览器的高层结构</h3><p>浏览器的主要组件为 (<a href="#1_1">1.1</a>)：</p><ol><li><strong>用户界面</strong> - 包括地址栏、前进 / 后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li><li><strong>浏览器引擎</strong> - 在用户界面和呈现引擎之间传送指令。</li><li><strong>呈现引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li><li><strong>网络</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li><li><strong>用户界面后端</strong> - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li><li><strong>JavaScript 解释器</strong>。用于解析和执行 JavaScript 代码。</li><li><strong>数据存储</strong>。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了 “网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li></ol><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/layers.png" alt> 图：浏览器的主要组件。</p><p>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p><h2 id="呈现引擎"><a href="#呈现引擎" class="headerlink" title="呈现引擎"></a>呈现引擎</h2><p>呈现引擎的作用嘛… 当然就是 “呈现” 了，也就是在浏览器的屏幕上显示请求的内容。</p><p>默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。</p><h3 id="呈现引擎-1"><a href="#呈现引擎-1" class="headerlink" title="呈现引擎"></a>呈现引擎</h3><p>本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司 “自制” 的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。</p><p>WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。有关详情，请参阅 <a href="http://webkit.org/" target="_blank" rel="noopener">webkit.org</a>。</p><h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><p>呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p><p>然后进行如下所示的基本流程：</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/flow.png" alt> 图：呈现引擎的基本流程。</p><p>呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成 “内容树” 上的 <a href="#DOM">DOM</a> 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：<a href="#Render_tree_construction">呈现树</a>。</p><p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p><p>呈现树构建完毕之后，进入 “<a href="#layout">布局</a>” 处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是<a href="#Painting">绘制</a> - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p><p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p><h4 id="主流程示例"><a href="#主流程示例" class="headerlink" title="主流程示例"></a>主流程示例</h4><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png" alt> 图：WebKit 主流程 <img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image008.jpg" alt> 图：Mozilla 的 Gecko 呈现引擎主流程 (<a href="#3_6">3.6</a>)</p><p>从图 3 和图 4 可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</p><p>Gecko 将视觉格式化元素组成的树称为 “框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它由“呈现对象” 组成。对于元素的放置，WebKit 使用的术语是 “布局”，而 Gecko 称之为“重排”。对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽” 的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：</p><h3 id="解析-综述"><a href="#解析-综述" class="headerlink" title="解析 - 综述"></a>解析 - 综述</h3><p>解析是呈现引擎中非常重要的一个环节，因此我们要更深入地讲解。首先，来介绍一下解析。</p><p>解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。</p><p>示例 - 解析 2 + 3 - 1 这个表达式，会返回下面的树：</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image009.png" alt> 图：数学表达式树节点</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为<a href="#context_free_grammar">与上下文无关的语法</a>。人类语言并不属于这样的语言，因此无法用常规的解析技术进行解析。</p><h4 id="解析器和词法分析器的组合"><a href="#解析器和词法分析器的组合" class="headerlink" title="解析器和词法分析器的组合"></a>解析器和词法分析器的组合</h4><p>解析的过程可以分成两个子过程：词法分析和语法分析。</p><p>词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。</p><p>语法分析是应用语言的语法规则的过程。</p><p>解析器通常将解析工作分给以下两个组件来处理：<strong>词法分析器</strong>（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而<strong>解析器</strong>负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image011.png" alt> 图：从源文档到解析树</p><p>解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。</p><p>如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。</p><h4 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h4><p>很多时候，解析树还不是最终产品。解析通常是在翻译过程中使用的，而翻译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image013.png" alt> 图：编译流程</p><h4 id="解析示例"><a href="#解析示例" class="headerlink" title="解析示例"></a>解析示例</h4><p>在图 5 中，我们通过一个数学表达式建立了解析树。现在，让我们试着定义一个简单的数学语言，用来演示解析的过程。</p><p>词汇：我们用的语言可包含整数、加号和减号。</p><p>语法：</p><ol><li>构成语言的语法单位是表达式、项和运算符。</li><li>我们用的语言可以包含任意数量的表达式。</li><li>表达式的定义是：一个 “项” 接一个“运算符”，然后再接一个“项”。</li><li>运算符是加号或减号。</li><li>项是一个整数或一个表达式。</li></ol><p>让我们分析一下 2 + 3 - 1。<br>匹配语法规则的第一个子串是 2，而根据第 5 条语法规则，这是一个项。匹配语法规则的第二个子串是 2 + 3，而根据第 3 条规则（一个项接一个运算符，然后再接一个项），这是一个表达式。下一个匹配项已经到了输入的结束。2 + 3 - 1 是一个表达式，因为我们已经知道 2 + 3 是一个项，这样就符合 “一个项接一个运算符，然后再接一个项” 的规则。2 + + 不与任何规则匹配，因此是无效的输入。</p><h4 id="词汇和语法的正式定义"><a href="#词汇和语法的正式定义" class="headerlink" title="词汇和语法的正式定义"></a>词汇和语法的正式定义</h4><p>词汇通常用<a href="http://www.regular-expressions.info/" target="_blank" rel="noopener">正则表达式</a>表示。</p><p>例如，我们的示例语言可以定义如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INTEGER :0|[1-9][0-9]*</span><br><span class="line">PLUS : +</span><br><span class="line">MINUS: -</span><br></pre></td></tr></table></figure><p>正如您所看到的，这里用正则表达式给出了整数的定义。</p><p>语法通常使用一种称为 <a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form" target="_blank" rel="noopener">BNF</a> 的格式来定义。我们的示例语言可以定义如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expression :=  term  operation  term</span><br><span class="line">operation :=  PLUS | MINUS</span><br><span class="line">term := INTEGER | expression</span><br></pre></td></tr></table></figure><p>之前我们说过，如果语言的语法是与上下文无关的语法，就可以由常规解析器进行解析。与上下文无关的语法的直观定义就是可以完全用 BNF 格式表达的语法。有关正式定义，请参阅<a href="http://en.wikipedia.org/wiki/Context-free_grammar" target="_blank" rel="noopener">关于与上下文无关的语法的维基百科文章</a>。</p><h4 id="解析器类型"><a href="#解析器类型" class="headerlink" title="解析器类型"></a>解析器类型</h4><p>有两种基本类型的解析器：自上而下解析器和自下而上解析器。直观地来说，自上而下的解析器从语法的高层结构出发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。</p><p>让我们来看看这两种解析器会如何解析我们的示例：</p><p>自上而下的解析器会从高层的规则开始：首先将 2 + 3 标识为一个表达式，然后将 2 + 3 - 1 标识为一个表达式（标识表达式的过程涉及到匹配其他规则，但是起点是最高级别的规则）。</p><p>自下而上的解析器将扫描输入内容，找到匹配的规则后，将匹配的输入内容替换成规则。如此继续替换，直到输入内容的结尾。部分匹配的表达式保存在解析器的堆栈中。</p><table><thead><tr><th>堆栈</th><th>输入</th></tr></thead><tbody><tr><td></td><td>2 + 3 - 1</td></tr><tr><td>项</td><td>+ 3 - 1</td></tr><tr><td>项运算</td><td>3 - 1</td></tr><tr><td>表达式</td><td>- 1</td></tr><tr><td>表达式运算符</td><td>1</td></tr><tr><td>表达式</td></tr></tbody></table><p>这种自下而上的解析器称为移位归约解析器，因为输入在向右移位（设想有一个指针从输入内容的开头移动到结尾），并且逐渐归约到语法规则上。</p><h4 id="自动生成解析器"><a href="#自动生成解析器" class="headerlink" title="自动生成解析器"></a>自动生成解析器</h4><p>有一些工具可以帮助您生成解析器，它们称为解析器生成器。您只要向其提供您所用语言的语法（词汇和语法规则），它就会生成相应的解析器。创建解析器需要对解析有深刻理解，而人工创建并优化解析器并不是一件容易的事情，所以解析器生成器是非常实用的。</p><p>WebKit 使用了两种非常有名的解析器生成器：用于创建词法分析器的 <a href="http://en.wikipedia.org/wiki/Flex_lexical_analyser" target="_blank" rel="noopener">Flex</a> 以及用于创建解析器的 <a href="http://www.gnu.org/software/bison/" target="_blank" rel="noopener">Bison</a>（您也可能遇到 Lex 和 Yacc 这样的别名）。Flex 的输入是包含标记的正则表达式定义的文件。Bison 的输入是采用 BNF 格式的语言语法规则。</p><h3 id="HTML-解析器"><a href="#HTML-解析器" class="headerlink" title="HTML 解析器"></a>HTML 解析器</h3><p>HTML 解析器的任务是将 HTML 标记解析成解析树。</p><h4 id="HTML-语法定义"><a href="#HTML-语法定义" class="headerlink" title="HTML 语法定义"></a>HTML 语法定义</h4><p>HTML 的词汇和语法在 W3C 组织创建的<a href="#w3c">规范</a>中进行了定义。当前的版本是 HTML4，HTML5 正在处理过程中。</p><h4 id="非与上下文无关的语法"><a href="#非与上下文无关的语法" class="headerlink" title="非与上下文无关的语法"></a>非与上下文无关的语法</h4><p>正如我们在解析过程的简介中已经了解到的，语法可以用 BNF 等格式进行正式定义。</p><p>很遗憾，所有的常规解析器都不适用于 HTML（我并不是开玩笑，它们可以用于解析 CSS 和 JavaScript）。HTML 并不能很容易地用解析器所需的与上下文无关的语法来定义。</p><p>有一种可以定义 HTML 的正规格式：DTD（Document Type Definition，文档类型定义），但它不是与上下文无关的语法。</p><p>这初看起来很奇怪：HTML 和 XML 非常相似。有很多 XML 解析器可以使用。HTML 存在一个 XML 变体 (XHTML)，那么有什么大的区别呢？</p><p>区别在于 HTML 的处理更为 “宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性” 的语法。</p><p>显然，这种看上去细微的差别实际上却带来了巨大的影响。一方面，这是 HTML 如此流行的原因：它能包容您的错误，简化网络开发。另一方面，这使得它很难编写正式的语法。概括地说，HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 XML 解析器来解析。</p><h4 id="HTML-DTD"><a href="#HTML-DTD" class="headerlink" title="HTML DTD"></a>HTML DTD</h4><p>HTML 的定义采用了 DTD 格式。此格式可用于定义 <a href="http://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language" target="_blank" rel="noopener">SGML</a> 族的语言。它包括所有允许使用的元素及其属性和层次结构的定义。如上文所述，HTML DTD 无法构成与上下文无关的语法。</p><p>DTD 存在一些变体。严格模式完全遵守 HTML 规范，而其他模式可支持以前的浏览器所使用的标记。这样做的目的是确保向下兼容一些早期版本的内容。最新的严格模式 DTD 可以在这里找到：<a href="http://www.w3.org/TR/html4/strict.dtd" target="_blank" rel="noopener">www.w3.org/TR/html4/strict.dtd</a></p><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>解析器的输出 “解析树” 是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。<br>解析树的根节点是 “<a href="http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html#i-Document" target="_blank" rel="noopener">Document</a>” 对象。</p><p>DOM 与标记之间几乎是一一对应的关系。比如下面这段标记：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      Hello World</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;div&gt; &lt;img src=&quot;example.png&quot;/&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>可翻译成如下的 DOM 树：</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image015.png" alt> 图：示例标记的 DOM 树</p><p>和 HTML 一样，DOM 也是由 W3C 组织指定的。请参见 <a href="http://www.w3.org/DOM/DOMTR" target="_blank" rel="noopener">www.w3.org/DOM/DOMTR</a>。这是关于文档操作的通用规范。其中一个特定模块描述针对 HTML 的元素。HTML 的定义可以在这里找到：<a href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html" target="_blank" rel="noopener">www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html</a>。</p><p>我所说的树包含 DOM 节点，指的是树是由实现了某个 DOM 接口的元素构成的。浏览器在具体的实现中会有一些供内部使用的其他属性。</p><h4 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h4><p>我们在之前章节已经说过，HTML 无法用常规的自上而下或自下而上的解析器进行解析。</p><p>原因在于：</p><ol><li>语言的宽容本质。</li><li>浏览器历来对一些常见的无效 HTML 用法采取包容态度。</li><li>解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 <code>document.write</code>，就会添加额外的标记，这样解析过程实际上就更改了输入内容。</li></ol><p>由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML。</p><p><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html" target="_blank" rel="noopener">HTML5 规范详细地描述了解析算法</a>。此算法由两个阶段组成：标记化和树构建。</p><p>标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。</p><p>标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image017.png" alt> 图：HTML 解析流程（摘自 HTML5 规范）</p><h4 id="标记化算法"><a href="#标记化算法" class="headerlink" title="标记化算法"></a>标记化算法</h4><p>该算法的输出结果是 HTML 标记。该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。该算法相当复杂，无法在此详述，所以我们通过一个简单的示例来帮助大家理解其原理。</p><p>基本示例 - 将下面的 HTML 代码标记化：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    Hello world</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>初始状态是数据状态。遇到字符 <code>&lt;</code> 时，状态更改为 <strong>“标记打开状态”</strong>。接收一个 <code>a-z</code> 字符会创建 “起始标记”，状态更改为 <strong>“标记名称状态”</strong>。这个状态会一直保持到接收 <code>&gt;</code> 字符。在此期间接收的每个字符都会附加到新的标记名称上。在本例中，我们创建的标记是 <code>html</code> 标记。</p><p>遇到 <code>&gt;</code> 标记时，会发送当前的标记，状态改回 <strong>“数据状态”</strong>。<code>&lt;body&gt;</code> 标记也会进行同样的处理。目前 <code>html</code> 和 <code>body</code> 标记均已发出。现在我们回到 <strong>“数据状态”</strong>。接收到 <code>Hello world</code> 中的 <code>H</code> 字符时，将创建并发送字符标记，直到接收 <code>&lt;/body&gt;</code> 中的 <code>&lt;</code>。我们将为 <code>Hello world</code> 中的每个字符都发送一个字符标记。</p><p>现在我们回到 <strong>“标记打开状态”</strong>。接收下一个输入字符 <code>/</code> 时，会创建 <code>end tag token</code> 并改为 <strong>“标记名称状态”</strong>。我们会再次保持这个状态，直到接收 <code>&gt;</code>。然后将发送新的标记，并回到 <strong>“数据状态”</strong>。<code>&lt;/html&gt;</code> 输入也会进行同样的处理。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image019.png" alt> 图：对示例输入进行标记化</p><h4 id="树构建算法"><a href="#树构建算法" class="headerlink" title="树构建算法"></a>树构建算法</h4><p>在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为 “插入模式”。</p><p>让我们来看看示例输入的树构建过程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    Hello world</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是 <strong>“initial mode”</strong>。接收 HTML 标记后转为 <strong>“before html”</strong> 模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。</p><p>然后状态将改为 <strong>“before head”</strong>。此时我们接收 “body” 标记。即使我们的示例中没有 “head” 标记，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。</p><p>现在我们进入了 <strong>“in head”</strong> 模式，然后转入 <strong>“after head”</strong> 模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为 <strong>“in body”</strong>。</p><p>现在，接收由 “Hello world” 字符串生成的一系列字符标记。接收第一个字符时会创建并插入 “Text” 节点，而其他字符也将附加到该节点。</p><p>接收 body 结束标记会触发 <strong>“after body”</strong> 模式。现在我们将接收 HTML 结束标记，然后进入 <strong>“after after body”</strong> 模式。接收到文件结束标记后，解析过程就此结束。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image022.gif" alt> 图：示例 HTML 的树构建</p><h4 id="解析结束后的操作"><a href="#解析结束后的操作" class="headerlink" title="解析结束后的操作"></a>解析结束后的操作</h4><p>在此阶段，浏览器会将文档标注为交互状态，并开始解析那些处于 “deferred” 模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为 “完成”，一个“加载” 事件将随之触发。</p><p>您可以<a href="http://www.w3.org/TR/html5/syntax.html#html-parser" target="_blank" rel="noopener">在 HTML5 规范中查看标记化和树构建的完整算法</a></p><h4 id="浏览器的容错机制"><a href="#浏览器的容错机制" class="headerlink" title="浏览器的容错机制"></a>浏览器的容错机制</h4><p>您在浏览 HTML 网页时从来不会看到 “语法无效” 的错误。这是因为浏览器会纠正任何无效内容，然后继续工作。</p><p>以下面的 HTML 代码为例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;mytag&gt;</span><br><span class="line">  &lt;/mytag&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">    Really lousy HTML</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在这里，我已经违反了很多语法规则（“mytag”不是标准的标记，“p”和 “div” 元素之间的嵌套有误等等），但是浏览器仍然会正确地显示这些内容，并且毫无怨言。因为有大量的解析器代码会纠正 HTML 网页作者的错误。</p><p>不同浏览器的错误处理机制相当一致，但令人称奇的是，这种机制并不是 HTML 当前规范的一部分。和书签管理以及前进 / 后退按钮一样，它也是浏览器在多年发展中的产物。很多网站都普遍存在着一些已知的无效 HTML 结构，每一种浏览器都会尝试通过和其他浏览器一样的方式来修复这些无效结构。</p><p>HTML5 规范定义了一部分这样的要求。WebKit 在 HTML 解析器类的开头注释中对此做了很好的概括。</p><blockquote><p>解析器对标记化输入内容进行解析，以构建文档树。如果文档的格式正确，就直接进行解析。</p><p>遗憾的是，我们不得不处理很多格式错误的 HTML 文档，所以解析器必须具备一定的容错性。</p><p>我们至少要能够处理以下错误情况：</p><ol><li>明显不能在某些外部标记中添加的元素。在此情况下，我们应该关闭所有标记，直到出现禁止添加的元素，然后再加入该元素。</li><li>我们不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：HTML HEAD BODY TBODY TR TD LI（还有遗漏的吗？）。</li><li>向 inline 元素内添加 block 元素。关闭所有 inline 元素，直到出现下一个较高级的 block 元素。</li><li>如果这样仍然无效，可关闭所有元素，直到可以添加元素为止，或者忽略该标记。</li></ol></blockquote><p>让我们看一些 WebKit 容错的示例：</p><h5 id="使用了-而不是"><a href="#使用了-而不是" class="headerlink" title="使用了  而不是 "></a>使用了<br>而不是<br></h5><p>有些网站使用了<br>而不是<br>。为了与 IE 和 Firefox 兼容，WebKit 将其与<br>做同样的处理。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) &#123;</span><br><span class="line">     reportError(MalformedBRError);</span><br><span class="line">     t-&gt;beginTag = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，错误处理是在内部进行的，用户并不会看到这个过程。</p><h5 id="离散表格"><a href="#离散表格" class="headerlink" title="离散表格"></a>离散表格</h5><p>离散表格是指位于其他表格内容中，但又不在任何一个单元格内的表格。<br>比如以下的示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>WebKit 会将其层次结构更改为两个同级表格：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (m_inStrayTableContent &amp;&amp; localName == tableTag)</span><br><span class="line">        popBlock(tableTag);</span><br></pre></td></tr></table></figure><p>WebKit 使用一个堆栈来保存当前的元素内容，它会从外部表格的堆栈中弹出内部表格。现在，这两个表格就变成了同级关系。</p><h5 id="嵌套的表单元素"><a href="#嵌套的表单元素" class="headerlink" title="嵌套的表单元素"></a>嵌套的表单元素</h5><p>如果用户在一个表单元素中又放入了另一个表单，那么第二个表单将被忽略。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!m_currentFormElement) &#123;</span><br><span class="line">        m_currentFormElement = new HTMLFormElement(formTag,    m_document);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="过于复杂的标记层次结构"><a href="#过于复杂的标记层次结构" class="headerlink" title="过于复杂的标记层次结构"></a>过于复杂的标记层次结构</h5><p>代码的注释已经说得很清楚了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool HTMLParser::allowNestedRedundantTag(const AtomicString&amp; tagName)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">unsigned i = 0;</span><br><span class="line">for (HTMLStackElem* curr = m_blockStack;</span><br><span class="line">         i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName == tagName;</span><br><span class="line">     curr = curr-&gt;next, i++) &#123; &#125;</span><br><span class="line">return i != cMaxRedundantTagDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="放错位置的-html-或者-body-结束标记"><a href="#放错位置的-html-或者-body-结束标记" class="headerlink" title="放错位置的 html 或者 body 结束标记"></a>放错位置的 html 或者 body 结束标记</h5><p>同样，代码的注释已经说得很清楚了。</p><blockquote><p>支持格式非常糟糕的 HTML 代码。我们从不关闭 body 标记，因为一些愚蠢的网页会在实际文档结束之前就关闭。我们通过调用 end() 来执行关闭操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (t-&gt;tagName == htmlTag || t-&gt;tagName == bodyTag )</span><br><span class="line">        return;</span><br></pre></td></tr></table></figure><p>所以网页作者需要注意，除非您想作为反面教材出现在 WebKit 容错代码段的示例中，否则还请编写格式正确的 HTML 代码。</p><h3 id="CSS-解析"><a href="#CSS-解析" class="headerlink" title="CSS 解析"></a>CSS 解析</h3><p>还记得简介中解析的概念吗？和 HTML 不同，CSS 是上下文无关的语法，可以使用简介中描述的各种解析器进行解析。事实上，<a href="http://www.w3.org/TR/CSS2/grammar.html" target="_blank" rel="noopener">CSS 规范定义了 CSS 的词法和语法</a>。</p><p>让我们来看一些示例：<br>词法语法（词汇）是针对各个标记用正则表达式定义的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comment   \/\*[^*]*\*+([^/*][^*]*\*+)*\/</span><br><span class="line">num   [0-9]+|[0-9]*&quot;.&quot;[0-9]+</span><br><span class="line">nonascii  [\200-\377]</span><br><span class="line">nmstart   [_a-z]|&#123;nonascii&#125;|&#123;escape&#125;</span><br><span class="line">nmchar    [_a-z0-9-]|&#123;nonascii&#125;|&#123;escape&#125;</span><br><span class="line">name    &#123;nmchar&#125;+</span><br><span class="line">ident   &#123;nmstart&#125;&#123;nmchar&#125;*</span><br></pre></td></tr></table></figure><p>“ident”是标识符 (identifier) 的缩写，比如类名。“name”是元素的 ID（通过 “#” 来引用）。</p><p>语法是采用 BNF 格式描述的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruleset</span><br><span class="line">  : selector [ &apos;,&apos; S* selector ]*</span><br><span class="line">    &apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S*</span><br><span class="line">  ;</span><br><span class="line">selector</span><br><span class="line">  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?</span><br><span class="line">  ;</span><br><span class="line">simple_selector</span><br><span class="line">  : element_name [ HASH | class | attrib | pseudo ]*</span><br><span class="line">  | [ HASH | class | attrib | pseudo ]+</span><br><span class="line">  ;</span><br><span class="line">class</span><br><span class="line">  : &apos;.&apos; IDENT</span><br><span class="line">  ;</span><br><span class="line">element_name</span><br><span class="line">  : IDENT | &apos;*&apos;</span><br><span class="line">  ;</span><br><span class="line">attrib</span><br><span class="line">  : &apos;[&apos; S* IDENT S* [ [ &apos;=&apos; | INCLUDES | DASHMATCH ] S*</span><br><span class="line">    [ IDENT | STRING ] S* ] &apos;]&apos;</span><br><span class="line">  ;</span><br><span class="line">pseudo</span><br><span class="line">  : &apos;:&apos; [ IDENT | FUNCTION S* [IDENT S*] &apos;)&apos; ]</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure><p>解释：这是一个规则集的结构：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div.error , a.error &#123;</span><br><span class="line">  color:red;</span><br><span class="line">  font-weight:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>div.error 和 a.error 是选择器。大括号内的部分包含了由此规则集应用的规则。此结构的正式定义是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruleset</span><br><span class="line">  : selector [ &apos;,&apos; S* selector ]*</span><br><span class="line">    &apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S*</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure><p>这表示一个规则集就是一个选择器，或者由逗号和空格（S 表示空格）分隔的多个（数量可选）选择器。规则集包含了大括号，以及其中的一个或多个（数量可选）由分号分隔的声明。“声明”和 “选择器” 将由下面的 BNF 格式定义。</p><h4 id="WebKit-CSS-解析器"><a href="#WebKit-CSS-解析器" class="headerlink" title="WebKit CSS 解析器"></a>WebKit CSS 解析器</h4><p>WebKit 使用 <a href="#parser_generators">Flex 和 Bison</a> 解析器生成器，通过 CSS 语法文件自动创建解析器。正如我们之前在解析器简介中所说，Bison 会创建自下而上的移位归约解析器。Firefox 使用的是人工编写的自上而下的解析器。这两种解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image023.png" alt> 图：解析 CSS</p><h3 id="处理脚本和样式表的顺序"><a href="#处理脚本和样式表的顺序" class="headerlink" title="处理脚本和样式表的顺序"></a>处理脚本和样式表的顺序</h3><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>网络的模型是同步的。网页作者希望解析器遇到 <code>&lt;script&gt;</code> 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为 “defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。</p><h4 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h4><p>WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p><h4 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h4><p>另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</p><h3 id="呈现树构建"><a href="#呈现树构建" class="headerlink" title="呈现树构建"></a>呈现树构建</h3><p>在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。</p><p>Firefox 将呈现树中的元素称为 “框架”。WebKit 使用的术语是呈现器或呈现对象。<br>呈现器知道如何布局并将自身及其子元素绘制出来。<br>WebKits RenderObject 类是所有呈现器的基类，其定义如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RenderObject&#123;</span><br><span class="line">  virtual void layout();</span><br><span class="line">  virtual void paint(PaintInfo);</span><br><span class="line">  virtual void rect repaintRect();</span><br><span class="line">  Node* node;  //the DOM node</span><br><span class="line">  RenderStyle* style;  // the computed style</span><br><span class="line">  RenderLayer* containgLayer; //the containing z-index layer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个呈现器都代表了一个矩形的区域，通常对应于相关节点的 CSS 框，这一点在 CSS2 规范中有所描述。它包含诸如宽度、高度和位置等几何信息。<br>框的类型会受到与节点相关的 “display” 样式属性的影响（请参阅<a href="#style_computation">样式计算</a>章节）。下面这段 WebKit 代码描述了根据 display 属性的不同，针对同一个 DOM 节点应创建什么类型的呈现器。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)</span><br><span class="line">&#123;</span><br><span class="line">    Document* doc = node-&gt;document();</span><br><span class="line">    RenderArena* arena = doc-&gt;renderArena();</span><br><span class="line">    ...</span><br><span class="line">    RenderObject* o = 0;</span><br><span class="line"></span><br><span class="line">    switch (style-&gt;display()) &#123;</span><br><span class="line">        case NONE:</span><br><span class="line">            break;</span><br><span class="line">        case INLINE:</span><br><span class="line">            o = new (arena) RenderInline(node);</span><br><span class="line">            break;</span><br><span class="line">        case BLOCK:</span><br><span class="line">            o = new (arena) RenderBlock(node);</span><br><span class="line">            break;</span><br><span class="line">        case INLINE_BLOCK:</span><br><span class="line">            o = new (arena) RenderBlock(node);</span><br><span class="line">            break;</span><br><span class="line">        case LIST_ITEM:</span><br><span class="line">            o = new (arena) RenderListItem(node);</span><br><span class="line">            break;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素类型也是考虑因素之一，例如表单控件和表格都对应特殊的框架。<br>在 WebKit 中，如果一个元素需要创建特殊的呈现器，就会替换 <code>createRenderer</code> 方法。呈现器所指向的样式对象中包含了一些和几何无关的信息。</p><h5 id="呈现树和-DOM-树的关系"><a href="#呈现树和-DOM-树的关系" class="headerlink" title="呈现树和 DOM 树的关系"></a>呈现树和 DOM 树的关系</h5><p>呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如 “head” 元素。如果元素的 display 属性值为 “none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden” 的元素仍会显示）。</p><p>有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select” 元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。<br>另一个关于多呈现器的例子是格式无效的 HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 呈现器，以包裹 inline 元素。</p><p>有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image025.png" alt> 图：呈现树及其对应的 DOM 树 (<a href="#3_1">3.1</a>)。初始容器 block 为 “viewport”，而在 WebKit 中则为“RenderView” 对象。</p><h5 id="构建呈现树的流程"><a href="#构建呈现树的流程" class="headerlink" title="构建呈现树的流程"></a>构建呈现树的流程</h5><p>在 Firefox 中，系统会针对 DOM 更新注册展示层，作为侦听器。展示层将框架创建工作委托给 <code>FrameConstructor</code>，由该构造器解析样式（请参阅<a href="#style">样式计算</a>）并创建框架。</p><p>在 WebKit 中，解析样式和创建呈现器的过程称为 “附加”。每个 DOM 节点都有一个“attach” 方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点 “attach” 方法。</p><p>处理 html 和 body 标记就会构建呈现树根节点。这个根节点呈现对象对应于 CSS 规范中所说的容器 block，这是最上层的 block，包含了其他所有 block。它的尺寸就是视口，即浏览器窗口显示区域的尺寸。Firefox 称之为 <code>ViewPortFrame</code>，而 WebKit 称之为 <code>RenderView</code>。这就是文档所指向的呈现对象。呈现树的其余部分以 DOM 树节点插入的形式来构建。</p><p>请参阅<a href="http://www.w3.org/TR/CSS21/intro.html#processing-model" target="_blank" rel="noopener">关于处理模型的 CSS2 规范</a>。</p><h4 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h4><p>构建呈现树时，需要计算每一个呈现对象的可视化属性。这是通过计算每个元素的样式属性来完成的。</p><p>样式包括来自各种来源的样式表、inline 样式元素和 HTML 中的可视化属性（例如 “bgcolor” 属性）。其中后者将经过转化以匹配 CSS 样式属性。</p><p>样式表的来源包括浏览器的默认样式表、由网页作者提供的样式表以及由浏览器用户提供的用户样式表（浏览器允许您定义自己喜欢的样式。以 Firefox 为例，用户可以将自己喜欢的样式表放在 “Firefox Profile” 文件夹下）。</p><p>样式计算存在以下难点：</p><ol><li>样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。</li><li><p>如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。</p><p>例如下面这个组合选择器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div div div div&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着规则适用于作为 3 个 div 元素的子代的 <code>&lt;div&gt;</code>。如果您要检查规则是否适用于某个指定的 <code>&lt;div&gt;</code> 元素，应选择树上的一条向上路径进行检查。您可能需要向上遍历节点树，结果发现只有两个 div，而且规则并不适用。然后，您必须尝试树中的其他路径。</p></li><li>应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）。</li></ol><p>让我们来看看浏览器是如何处理这些问题的：</p><h5 id="共享样式数据"><a href="#共享样式数据" class="headerlink" title="共享样式数据"></a>共享样式数据</h5><p>WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：</p><ol><li>这些元素必须处于相同的鼠标状态（例如，不允许其中一个是 “:hover” 状态，而另一个不是）</li><li>任何元素都没有 ID</li><li>标记名称应匹配</li><li>类属性应匹配</li><li>映射属性的集合必须是完全相同的</li><li>链接状态必须匹配</li><li>焦点状态必须匹配</li><li>任何元素都不应受属性选择器的影响，这里所说的 “影响” 是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配</li><li>元素中不能有任何 inline 样式属性</li><li>不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。</li></ol><h5 id="Firefox-规则树"><a href="#Firefox-规则树" class="headerlink" title="Firefox 规则树"></a>Firefox 规则树</h5><p>为了简化样式计算，Firefox 还采用了另外两种树：规则树和样式上下文树。WebKit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image035.png" alt> 图：Firefox 样式上下文树 (<a href="#2_2">2.2</a>)</p><p>样式上下文包含端值。要计算出这些值，应按照正确顺序应用所有的匹配规则，并将其从逻辑值转化为具体的值。例如，如果逻辑值是屏幕大小的百分比，则需要换算成绝对的单位。规则树的点子真的很巧妙，它使得节点之间可以共享这些值，以避免重复计算，还可以节约空间。</p><p>所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。</p><p>这个想法相当于将规则树路径视为词典中的单词。如果我们已经计算出如下的规则树：</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/tree.png" alt></p><p>假设我们需要为内容树中的另一个元素匹配规则，并且找到匹配路径是 B - E - I（按照此顺序）。由于我们在树中已经计算出了路径 A - B - E - I - L，因此就已经有了此路径，这就减少了现在所需的工作量。</p><p>让我们看看规则树如何帮助我们减少工作。</p><h5 id="结构划分"><a href="#结构划分" class="headerlink" title="结构划分"></a>结构划分</h5><p>样式上下文可分割成多个结构。这些结构体包含了特定类别（如 border 或 color）的样式信息。结构中的属性都是继承的或非继承的。继承属性如果未由元素定义，则继承自其父代。非继承属性（也称为 “重置” 属性）如果未进行定义，则使用默认值。</p><p>规则树通过缓存整个结构（包含计算出的端值）为我们提供帮助。这一想法假定底层节点没有提供结构的定义，则可使用上层节点中的缓存结构。</p><h5 id="使用规则树计算样式上下文"><a href="#使用规则树计算样式上下文" class="headerlink" title="使用规则树计算样式上下文"></a>使用规则树计算样式上下文</h5><p>在计算某个特定元素的样式上下文时，我们首先计算规则树中的对应路径，或者使用现有的路径。然后我们沿此路径应用规则，在新的样式上下文中填充结构。我们从路径中拥有最高优先级的底层节点（通常也是最特殊的选择器）开始，并向上遍历规则树，直到结构填充完毕。如果该规则节点对于此结构没有任何规范，那么我们可以实现更好的优化：寻找路径更上层的节点，找到后指定完整的规范并指向相关节点即可。这是最好的优化方法，因为整个结构都能共享。这可以减少端值的计算量并节约内存。<br>如果我们找到了部分定义，就会向上遍历规则树，直到结构填充完毕。</p><p>如果我们找不到结构的任何定义，那么假如该结构是 “继承” 类型，我们会在<strong>上下文树</strong>中指向父代的结构，这样也可以共享结构。如果是 reset 类型的结构，则会使用默认值。</p><p>如果最特殊的节点确实添加了值，那么我们需要另外进行一些计算，以便将这些值转化成实际值。然后我们将结果缓存在树节点中，供子代使用。</p><p>如果某个元素与其同级元素都指向同一个树节点，那么它们就可以共享<strong>整个样式上下文</strong>。</p><p>让我们来看一个例子，假设我们有如下 HTML 代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        this is a &lt;span&gt; big error &lt;/span&gt;</span><br><span class="line">        this is also a</span><br><span class="line">        &lt;span&gt; very  big  error&lt;/span&gt; error</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;another error&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>还有如下规则：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div &#123;margin:5px;color:black&#125;</span><br><span class="line">.err &#123;color:red&#125;</span><br><span class="line">.big &#123;margin-top:3px&#125;</span><br><span class="line">div span &#123;margin-bottom:4px&#125;</span><br><span class="line">#div1 &#123;color:blue&#125;</span><br><span class="line">#div2 &#123;color:green&#125;</span><br><span class="line">div &#123;margin:5px;color:black&#125;</span><br><span class="line">.err &#123;color:red&#125;</span><br><span class="line">.big &#123;margin-top:3px&#125;</span><br><span class="line">div span &#123;margin-bottom:4px&#125;</span><br><span class="line">#div1 &#123;color:blue&#125;</span><br><span class="line">#div2 &#123;color:green&#125;</span><br></pre></td></tr></table></figure><p>为了简便起见，我们只需要填充两个结构：color 结构和 margin 结构。color 结构只包含一个成员（即 “color”），而 margin 结构包含四条边。<br>形成的规则树如下图所示（节点的标记方式为 “节点名 : 指向的规则序号”）：</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image027.png" alt> 图：规则树</p><p>上下文树如下图所示（节点名 : 指向的规则节点）：</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image029.png" alt> 图：上下文树</p><p>假设我们解析 HTML 时遇到了第二个</p><div>标记，我们需要为此节点创建样式上下文，并填充其样式结构。<br>经过规则匹配，我们发现该<div>的匹配规则是第 1、2 和 6 条。这意味着规则树中已有一条路径可供我们的元素使用，我们只需要再为其添加一个节点以匹配第 6 条规则（规则树中的 F 节点）。<br>我们将创建样式上下文并将其放入上下文树中。新的样式上下文将指向规则树中的 F 节点。<p></p><p>现在我们需要填充样式结构。首先要填充的是 margin 结构。由于最后的规则节点 (F) 并没有添加到 margin 结构，我们需要上溯规则树，直至找到在先前节点插入中计算过的缓存结构，然后使用该结构。我们会在指定 margin 规则的最上层节点（即 B 节点）上找到该结构。</p><p>我们已经有了 color 结构的定义，因此不能使用缓存的结构。由于 color 有一个属性，我们无需上溯规则树以填充其他属性。我们将计算端值（将字符串转化为 RGB 等）并在此节点上缓存经过计算的结构。</p><p>第二个 <span>元素处理起来更加简单。我们将匹配规则，最终发现它和之前的 span 一样指向规则 G。由于我们找到了指向同一节点的同级，就可以共享整个样式上下文了，只需指向之前 span 的上下文即可。</span></p><p>对于包含了继承自父代的规则的结构，缓存是在上下文树中进行的（事实上 color 属性是继承的，但是 Firefox 将其视为 reset 属性，并缓存到规则树上）。<br>例如，如果我们在某个段落中添加 font 规则：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#123;font-family:Verdana;font size:10px;font-weight:bold&#125;</span><br></pre></td></tr></table></figure><p>那么，该段落元素作为上下文树中的 div 的子代，就会共享与其父代相同的 font 结构（前提是该段落没有指定 font 规则）。</p><p>在 WebKit 中没有规则树，因此会对匹配的声明遍历 4 次。首先应用非重要高优先级的属性（由于作为其他属性的依据而应首先应用的属性，例如 display），接着是高优先级重要规则，然后是普通优先级非重要规则，最后是普通优先级重要规则。这意味着多次出现的属性会根据正确的层叠顺序进行解析。最后出现的最终生效。</p><p>因此概括来说，共享样式对象（整个对象或者对象中的部分结构）可以解决问题 <a href="#issue1">1</a> 和问题 <a href="#issue3">3</a>。Firefox 规则树还有助于按照正确的顺序应用属性。</p><h5 id="对规则进行处理以简化匹配"><a href="#对规则进行处理以简化匹配" class="headerlink" title="对规则进行处理以简化匹配"></a>对规则进行处理以简化匹配</h5><p>样式规则有一些来源：</p><ul><li><p>外部样式表或样式元素中的 CSS 规则</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#123;color:blue&#125;</span><br></pre></td></tr></table></figure></li><li><p>inline 样式属性及类似内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p /&gt;</span><br></pre></td></tr></table></figure></li><li><p>HTML 可视化属性（映射到相关的样式规则）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p bgcolor=&quot;blue&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul><p>后两种很容易和元素进行匹配，因为元素拥有样式属性，而且 HTML 属性可以使用元素作为键值进行映射。</p><p>我们之前在<a href="#issue2">第 2 个问题</a>中提到过，CSS 规则匹配可能比较棘手。为了解决这一难题，可以对 CSS 规则进行一些处理，以便访问。</p><p>样式表解析完毕后，系统会根据选择器将 CSS 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果选择器是 ID，规则就会添加到 ID 表中；如果选择器是类，规则就会添加到类表中，依此类推。<br>这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉 95% 以上规则，因此在匹配过程中根本就不用考虑这些规则了 (<a href="#4_1">4.1</a>)。</p><p>我们以如下的样式规则为例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p.error &#123;color:red&#125;</span><br><span class="line">#messageDiv &#123;height:50px&#125;</span><br><span class="line">div &#123;margin:5px&#125;</span><br></pre></td></tr></table></figure><p>第一条规则将插入类表，第二条将插入 ID 表，而第三条将插入标记表。<br>对于下面的 HTML 代码段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;an error occurred &lt;/p&gt;</span><br><span class="line">&lt;div&gt;this is a message&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>我们首先会为 p 元素寻找匹配的规则。类表中有一个 “error” 键，在下面可以找到 “p.error” 的规则。div 元素在 ID 表（键为 ID）和标记表中有相关的规则。剩下的工作就是找出哪些根据键提取的规则是真正匹配的了。<br>例如，如果 div 的对应规则如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">table div &#123;margin:5px&#125;</span><br></pre></td></tr></table></figure><p>这条规则仍然会从标记表中提取出来，因为键是最右边的选择器，但这条规则并不匹配我们的 div 元素，因为 div 没有 table 祖先。</p><p>WebKit 和 Firefox 都进行了这一处理。</p><h5 id="以正确的层叠顺序应用规则"><a href="#以正确的层叠顺序应用规则" class="headerlink" title="以正确的层叠顺序应用规则"></a>以正确的层叠顺序应用规则</h5><p>样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。</p><p>如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。</p><h5 id="样式表层叠顺序"><a href="#样式表层叠顺序" class="headerlink" title="样式表层叠顺序"></a>样式表层叠顺序</h5><p>某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为 “层叠” 顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：</p><ol><li>浏览器声明</li><li>用户普通声明</li><li>作者普通声明</li><li>作者重要声明</li><li>用户重要声明</li></ol><p>浏览器声明是重要程度最低的，而用户只有将该声明标记为 “重要” 才可以替换网页作者的声明。同样顺序的声明会根据<a href="#Specificity">特异性</a>进行排序，然后再是其指定顺序。HTML 可视化属性会转换成匹配的 CSS 声明。它们被视为低优先级的网页作者规则。</p><h5 id="特异性"><a href="#特异性" class="headerlink" title="特异性"></a>特异性</h5><p>选择器的特异性由 <a href="http://www.w3.org/TR/CSS2/cascade.html#specificity" target="_blank" rel="noopener">CSS2 规范</a>定义如下：</p><ul><li>如果声明来自于 “style” 属性，而不是带有选择器的规则，则记为 1，否则记为 0 (= a)</li><li>记为选择器中 ID 属性的个数 (= b)</li><li>记为选择器中其他属性和伪类的个数 (= c)</li><li>记为选择器中元素名称和伪元素的个数 (= d)</li></ul><p>将四个数字按 a-b-c-d 这样连接起来（位于大数进制的数字系统中），构成特异性。</p><p>您使用的进制取决于上述类别中的最高计数。<br>例如，如果 a=14，您可以使用十六进制。如果 a=17，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：html body div div p …（在选择器中出现了 17 个标记，这样的可能性极低）。</p><p>一些示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*             &#123;&#125;  /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span><br><span class="line">li            &#123;&#125;  /* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span><br><span class="line">li:first-line &#123;&#125;  /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span><br><span class="line">ul li         &#123;&#125;  /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span><br><span class="line">ul ol+li      &#123;&#125;  /* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span><br><span class="line">h1 + *[rel=up]&#123;&#125;  /* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span><br><span class="line">ul ol li.red  &#123;&#125;  /* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span><br><span class="line">li.red.level  &#123;&#125;  /* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span><br><span class="line">#x34y         &#123;&#125;  /* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span><br><span class="line">         /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</span><br></pre></td></tr></table></figure><h5 id="规则排序"><a href="#规则排序" class="headerlink" title="规则排序"></a>规则排序</h5><p>找到匹配的规则之后，应根据级联顺序将其排序。WebKit 对于较小的列表会使用冒泡排序，而对较大的列表则使用归并排序。对于以下规则，WebKit 通过替换 “&gt;” 运算符来实现排序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static bool operator &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)</span><br><span class="line">&#123;</span><br><span class="line">    int spec1 = r1.selector()-&gt;specificity();</span><br><span class="line">    int spec2 = r2.selector()-&gt;specificity();</span><br><span class="line">    return (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="渐进式处理"><a href="#渐进式处理" class="headerlink" title="渐进式处理"></a>渐进式处理</h4><p>WebKit 使用一个标记来表示是否所有的顶级样式表（包括 @imports）均已加载完毕。如果在附加过程中尚未完全加载样式，则使用占位符，并在文档中进行标注，等样式表加载完毕后再重新计算。</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。</p><p>HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历 (<a href="#3_5">3.5</a>)。</p><p>坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。</p><p>布局是一个递归的过程。它从根呈现器（对应于 HTML 文档的 <code>&lt;html&gt;</code> 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。</p><p>根呈现器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。</p><p>所有的呈现器都有一个 “layout” 或者 “reflow” 方法，每一个呈现器都会调用其需要进行布局的子代的 layout 方法。</p><h4 id="Dirty-位系统"><a href="#Dirty-位系统" class="headerlink" title="Dirty 位系统"></a>Dirty 位系统</h4><p>为避免对所有细小更改都进行整体布局，浏览器采用了一种 “dirty 位” 系统。如果某个呈现器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。</p><p>有两种标记：“dirty”和 “children are dirty”。“children are dirty” 表示尽管呈现器自身没有变化，但它至少有一个子代需要布局。</p><h4 id="全局布局和增量布局"><a href="#全局布局和增量布局" class="headerlink" title="全局布局和增量布局"></a>全局布局和增量布局</h4><p>全局布局是指触发了整个呈现树范围的布局，触发原因可能包括：</p><ol><li>影响所有呈现器的全局样式更改，例如字体大小更改。</li><li>屏幕大小调整。</li></ol><p>布局可以采用增量方式，也就是只对 dirty 呈现器进行布局（这样可能存在需要进行额外布局的弊端）。<br>当呈现器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 DOM 树之后，新的呈现器附加到了呈现树中。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/reflow.png" alt> 图：增量布局 - 只有 dirty 呈现器及其子代进行布局 (<a href="#3_6">3.6</a>)。</p><h4 id="异步布局和同步布局"><a href="#异步布局和同步布局" class="headerlink" title="异步布局和同步布局"></a>异步布局和同步布局</h4><p>增量布局是异步执行的。Firefox 将增量布局的 “reflow 命令” 加入队列，而调度程序会触发这些命令的批量执行。WebKit 也有用于执行增量布局的计时器：对呈现树进行遍历，并对 dirty 呈现器进行布局。<br>请求样式信息（例如 “offsetHeight”）的脚本可同步触发增量布局。<br>全局布局往往是同步触发的。<br>有时，当初始布局完成之后，如果一些属性（如滚动位置）发生变化，布局就会作为回调而触发。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>如果布局是由 “大小调整” 或呈现器的位置（而非大小）改变而触发的，那么可以从缓存中获取呈现器的大小，而无需重新计算。<br>在某些情况下，只有一个子树进行了修改，因此无需从根节点开始布局。这适用于在本地进行更改而不影响周围元素的情况，例如在文本字段中插入文本（否则每次键盘输入都将触发从根节点开始的布局）。</p><h4 id="布局处理"><a href="#布局处理" class="headerlink" title="布局处理"></a>布局处理</h4><p>布局通常具有以下模式：</p><ol><li>父呈现器确定自己的宽度。</li><li>父呈现器依次处理子呈现器，并且：<ol><li>放置子呈现器（设置 x,y 坐标）。</li><li>如果有必要，调用子呈现器的布局（如果子呈现器是 dirty 的，或者这是全局布局，或出于其他某些原因），这会计算子呈现器的高度。</li></ol></li><li>父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用。</li><li>将其 dirty 位设置为 false。</li></ol><p>Firefox 使用 “state” 对象 (nsHTMLReflowState) 作为布局的参数（称为“reflow”），这其中包括了父呈现器的宽度。<br>Firefox 布局的输出为 “metrics” 对象 (nsHTMLReflowMetrics)，其包含计算得出的呈现器高度。</p><h4 id="宽度计算"><a href="#宽度计算" class="headerlink" title="宽度计算"></a>宽度计算</h4><p>呈现器宽度是根据容器块的宽度、呈现器样式中的 “width” 属性以及边距和边框计算得出的。<br>例如以下 div 的宽度：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div/&gt;</span><br></pre></td></tr></table></figure><p>将由 WebKit 计算如下（BenderBox 类，calcWidth 方法）：</p><ul><li><p>容器的宽度取容器的 availableWidth 和 0 中的较大值。availableWidth 在本例中相当于 contentWidth，计算公式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clientWidth() - paddingLeft() - paddingRight()</span><br></pre></td></tr></table></figure><p>clientWidth 和 clientHeight 表示一个对象的内部（除去边框和滚动条）。</p></li><li>元素的宽度是 “width” 样式属性。它会根据容器宽度的百分比计算得出一个绝对值。</li><li>然后加上水平方向的边框和补白。</li></ul><p>现在计算得出的是 “preferred width”。然后需要计算最小宽度和最大宽度。<br>如果首选宽度大于最大宽度，那么应使用最大宽度。如果首选宽度小于最小宽度（最小的不可破开单位），那么应使用最小宽度。</p><p>这些值会缓存起来，以用于需要布局而宽度不变的情况。</p><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>如果呈现器在布局过程中需要换行，会立即停止布局，并告知其父代需要换行。父代会创建额外的呈现器，并对其调用布局。</p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>在绘制阶段，系统会遍历呈现树，并调用呈现器的 “paint” 方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。</p><h4 id="全局绘制和增量绘制"><a href="#全局绘制和增量绘制" class="headerlink" title="全局绘制和增量绘制"></a>全局绘制和增量绘制</h4><p>和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块 “dirty 区域”，并生成“paint” 事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。</p><h4 id="绘制顺序"><a href="#绘制顺序" class="headerlink" title="绘制顺序"></a>绘制顺序</h4><p><a href="http://www.w3.org/TR/CSS21/zindex.html" target="_blank" rel="noopener">CSS2 规范定义了绘制流程的顺序</a>。绘制的顺序其实就是元素进入<a href="#stackingcontext">堆栈样式上下文</a>的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：</p><ol><li>背景颜色</li><li>背景图片</li><li>边框</li><li>子代</li><li>轮廓</li></ol><h4 id="Firefox-显示列表"><a href="#Firefox-显示列表" class="headerlink" title="Firefox 显示列表"></a>Firefox 显示列表</h4><p>Firefox 遍历整个呈现树，为绘制的矩形建立一个显示列表。列表中按照正确的绘制顺序（先是呈现器的背景，然后是边框等等）包含了与矩形相关的呈现器。这样等到重新绘制的时候，只需遍历一次呈现树，而不用多次遍历（绘制所有背景，然后绘制所有图片，再绘制所有边框等等）。</p><p>Firefox 对此过程进行了优化，也就是不添加隐藏的元素，例如被不透明元素完全遮挡住的元素。</p><h4 id="WebKit-矩形存储"><a href="#WebKit-矩形存储" class="headerlink" title="WebKit 矩形存储"></a>WebKit 矩形存储</h4><p>在重新绘制之前，WebKit 会将原来的矩形另存为一张位图，然后只绘制新旧矩形之间的差异部分。</p><h3 id="动态变化"><a href="#动态变化" class="headerlink" title="动态变化"></a>动态变化</h3><p>在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大 “html” 元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。</p><h3 id="呈现引擎的线程"><a href="#呈现引擎的线程" class="headerlink" title="呈现引擎的线程"></a>呈现引擎的线程</h3><p>呈现引擎采用了单线程。几乎所有操作（除了网络操作）都是在单线程中进行的。在 Firefox 和 Safari 中，该线程就是浏览器的主线程。而在 Chrome 浏览器中，该线程是标签进程的主线程。<br>网络操作可由多个并行线程执行。并行连接数是有限的（通常为 2 至 6 个，以 Firefox 3 为例是 6 个）。</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>浏览器的主线程是事件循环。它是一个无限循环，永远处于接受处理状态，并等待事件（如布局和绘制事件）发生，并进行处理。这是 Firefox 中关于主事件循环的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (!mExiting)</span><br><span class="line">    NS_ProcessNextEvent(thread);</span><br></pre></td></tr></table></figure><h3 id="CSS2-可视化模型"><a href="#CSS2-可视化模型" class="headerlink" title="CSS2 可视化模型"></a>CSS2 可视化模型</h3><h4 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h4><p>根据 <a href="http://www.w3.org/TR/CSS21/intro.html#processing-model" target="_blank" rel="noopener">CSS2 规范</a>，“画布” 这一术语是指 “用来呈现格式化结构的空间”，也就是供浏览器绘制内容的区域。画布的空间尺寸大小是无限的，但是浏览器会根据视口的尺寸选择一个初始宽度。</p><p>根据 <a href="http://www.w3.org/TR/CSS2/zindex.html" target="_blank" rel="noopener">www.w3.org/TR/CSS2/zindex.html</a>，画布如果包含在其他画布内，就是透明的；否则会由浏览器指定一种颜色。</p><h4 id="CSS-框模型"><a href="#CSS-框模型" class="headerlink" title="CSS 框模型"></a>CSS 框模型</h4><p><a href="http://www.w3.org/TR/CSS2/box.html" target="_blank" rel="noopener">CSS 框模型</a>描述的是针对文档树中的元素而生成，并根据可视化格式模型进行布局的矩形框。<br>每个框都有一个内容区域（例如文本、图片等），还有可选的周围补白、边框和边距区域。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image046.jpg" alt> 图：CSS2 框模型</p><p>每一个节点都会生成 0..n 个这样的框。<br>所有元素都有一个 “display” 属性，决定了它们所对应生成的框类型。示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">block  - generates a block box.</span><br><span class="line">inline - generates one or more inline boxes.</span><br><span class="line">none - no box is generated.</span><br></pre></td></tr></table></figure><p>默认值是 inline，但是浏览器样式表设置了其他默认值。例如，“div” 元素的 display 属性默认值是 block。<br>您可以在这里找到默认样式表示例：<a href="http://www.w3.org/TR/CSS2/sample.html" target="_blank" rel="noopener">www.w3.org/TR/CSS2/sample.html</a></p><h4 id="定位方案"><a href="#定位方案" class="headerlink" title="定位方案"></a>定位方案</h4><p>有三种定位方案：</p><ol><li>普通：根据对象在文档中的位置进行定位，也就是说对象在呈现树中的位置和它在 DOM 树中的位置相似，并根据其框类型和尺寸进行布局。</li><li>浮动：对象先按照普通流进行布局，然后尽可能地向左或向右移动。</li><li>绝对：对象在呈现树中的位置和它在 DOM 树中的位置不同。</li></ol><p>定位方案是由 “position” 属性和 “float” 属性设置的。</p><ul><li>如果值是 static 和 relative，就是普通流</li><li>如果值是 absolute 和 fixed，就是绝对定位</li></ul><p>static 定位无需定义位置，而是使用默认定位。对于其他方案，网页作者需要指定位置：top、bottom、left、right。</p><p>框的布局方式是由以下因素决定的：</p><ul><li>框类型</li><li>框尺寸</li><li>定位方案</li><li>外部信息，例如图片大小和屏幕大小</li></ul><h4 id="框类型"><a href="#框类型" class="headerlink" title="框类型"></a>框类型</h4><p>block 框：形成一个 block，在浏览器窗口中拥有其自己的矩形区域。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image057.png" alt> 图：block 框</p><p>inline 框：没有自己的 block，但是位于容器 block 内。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image059.png" alt> 图：inline 框</p><p>block 采用的是一个接一个的垂直格式，而 inline 采用的是水平格式。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image061.png" alt> 图：block 和 inline 格式</p><p>inline 框放置在行中或 “行框” 中。这些行至少和最高的框一样高，还可以更高，当框根据 “底线” 对齐时，这意味着元素的底部需要根据其他框中非底部的位置对齐。如果容器的宽度不够，inline 元素就会分为多行放置。在段落中经常发生这种情况。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image063.png" alt> 图：行</p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><h4 id="相对"><a href="#相对" class="headerlink" title="相对"></a>相对</h4><p>相对定位：先按照普通方式定位，然后根据所需偏移量进行移动。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image065.png" alt> 图：相对定位</p><h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><p>浮动框会移动到行的左边或右边。有趣的特征在于，其他框会浮动在它的周围。下面这段 HTML 代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;img src=&quot;images/image.gif&quot; width=&quot;100&quot; height=&quot;100&quot;&gt;</span><br><span class="line">  Lorem ipsum dolor sit amet, consectetuer...</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>显示效果如下：</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image067.png" alt> 图：浮动</p><h4 id="绝对定位和固定定位"><a href="#绝对定位和固定定位" class="headerlink" title="绝对定位和固定定位"></a>绝对定位和固定定位</h4><p>这种布局是准确定义的，与普通流无关。元素不参与普通流。尺寸是相对于容器而言的。在固定定位中，容器就是可视区域。</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image069.png" alt> 图：固定定位</p><p>请注意，即使在文档滚动时，固定框也不会移动。</p><h3 id="分层展示"><a href="#分层展示" class="headerlink" title="分层展示"></a>分层展示</h3><p>这是由 z-index CSS 属性指定的。它代表了框的第三个维度，也就是沿 “z 轴” 方向的位置。</p><p>这些框分散到多个堆栈（称为堆栈上下文）中。在每一个堆栈中，会首先绘制后面的元素，然后在顶部绘制前面的元素，以便更靠近用户。如果出现重叠，新绘制的元素就会覆盖之前的元素。<br>堆栈是按照 z-index 属性进行排序的。具有 “z-index” 属性的框形成了本地堆栈。视口具有外部堆栈。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">      div &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 2in;</span><br><span class="line">        top: 2in;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;div</span><br><span class="line">        &gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div</span><br><span class="line">        &gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"> &lt;/p&gt;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image071.png" alt> 图：固定定位</p><p>虽然红色 div 在标记中的位置比绿色 div 靠前（按理应该在常规流程中优先绘制），但是 z-index 属性的优先级更高，因此它移动到了根框所保持的堆栈中更靠前的位置。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>浏览器架构<ol><li>Grosskurth, Alan. <a href="http://grosskurth.ca/papers/browser-refarch.pdf" target="_blank" rel="noopener">A Reference Architecture for Web Browsers (pdf)</a></li><li>Gupta, Vineet. <a href="http://www.vineetgupta.com/2010/11/how-browsers-work-part-1-architecture/" target="_blank" rel="noopener">How Browsers Work - Part 1 - Architecture</a></li></ol></li><li>解析<ol><li>Aho, Sethi, Ullman, Compilers: Principles, Techniques, and Tools（即 “Dragon book”）, Addison-Wesley, 1986</li><li>Rick Jelliffe. <a href="http://broadcast.oreilly.com/2009/05/the-bold-and-the-beautiful-two.html" target="_blank" rel="noopener">The Bold and the Beautiful: two new drafts for HTML 5.</a></li></ol></li><li>Firefox<ol><li>L. David Baron, <a href="http://dbaron.org/talks/2008-11-12-faster-html-and-css/slide-6.xhtml" target="_blank" rel="noopener">Faster HTML and CSS: Layout Engine Internals for Web Developers.</a></li><li>L. David Baron, <a href="https://www.youtube.com/watch?v=a2_6bGNZ7bA" target="_blank" rel="noopener">Faster HTML and CSS: Layout Engine Internals for Web Developers（Google 技术访谈视频）</a></li><li>L. David Baron, <a href="http://www.mozilla.org/newlayout/doc/layout-2006-07-12/slide-6.xhtml" target="_blank" rel="noopener">Mozilla’s Layout Engine</a></li><li>L. David Baron, <a href="http://www.mozilla.org/newlayout/doc/style-system.html" target="_blank" rel="noopener">Mozilla Style System Documentation</a></li><li>Chris Waterson, <a href="http://www.mozilla.org/newlayout/doc/reflow.html" target="_blank" rel="noopener">Notes on HTML Reflow</a></li><li>Chris Waterson, <a href="http://www.mozilla.org/newlayout/doc/gecko-overview.htm" target="_blank" rel="noopener">Gecko Overview</a></li><li>Alexander Larsson, <a href="https://developer.mozilla.org/en/The_life_of_an_HTML_HTTP_request" target="_blank" rel="noopener">The life of an HTML HTTP request</a></li></ol></li><li>WebKit<ol><li>David Hyatt, <a href="http://weblogs.mozillazine.org/hyatt/archives/cat_safari.html" target="_blank" rel="noopener">Implementing CSS（第一部分）</a></li><li>David Hyatt, <a href="http://weblogs.mozillazine.org/hyatt/WebCore/chapter2.html" target="_blank" rel="noopener">An Overview of WebCore</a></li><li>David Hyatt, <a href="http://webkit.org/blog/114/" target="_blank" rel="noopener">WebCore Rendering</a></li><li>David Hyatt, <a href="http://webkit.org/blog/66/the-fouc-problem/" target="_blank" rel="noopener">The FOUC Problem</a></li></ol></li><li>W3C 规范<ol><li><a href="http://www.w3.org/TR/html4/" target="_blank" rel="noopener">HTML 4.01 规范</a></li><li><a href="http://dev.w3.org/html5/spec/Overview.html" target="_blank" rel="noopener">W3C HTML5 规范</a></li><li><a href="http://www.w3.org/TR/CSS2/" target="_blank" rel="noopener">层叠样式表第 2 级第 1 次修改 (CSS 2.1) 规范</a></li></ol></li><li>浏览器构建说明<ol><li>Firefox. <a href="https://developer.mozilla.org/en/Build_Documentation" target="_blank" rel="noopener">https://developer.mozilla.org/en/Build_Documentation</a></li><li>WebKit. <a href="http://webkit.org/building/build.html" target="_blank" rel="noopener">http://webkit.org/building/build.html</a></li></ol></li></ol></div></div>]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
</search>
